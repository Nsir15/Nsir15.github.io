<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CALayer position 和 anchorPoint 的问题]]></title>
    <url>%2F2017%2F08%2F30%2FCALayer%20position%20%E5%92%8C%20anchorPoint%20%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[概要： CALayer 的position白话来讲：position就是layer 自身的anchorPoint相对于父superLayer的坐标位置。常规说来，在iOS上，一个图层的position位于父图层的左上角具体概念参考：这将是你最后一次纠结position与anchorPoint 关于画曲线的角度参考图： 正文：需求是一个扫描匹配的动画： 如上展示的是最终的效果。这里主要用的是一个自定义view PulsingView，重写 (void)drawRect:(CGRect)rect方法，在这个方法内部去画相应的元素，主要包含： 1.外部扩散的脉冲layer。 2.雷达扫面的内圈layer。 3.雷达扫描的扇形layer。首先是外部的脉冲扩散动画实现：这个比较简单，参考网上的好多雷达扫描实现，PulsingView.m文件中 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142 [super drawRect:rect]; [[UIColor whiteColor] setFill]; UIRectFill(rect); UIImage * image = [UIImage imageNamed:@&quot;radar_background&quot;]; [image drawInRect:rect]; CGFloat pulsingWidth = rect.size.width / 2.5; CGFloat pulsingX = self.center.x - pulsingWidth * 0.5; CGFloat pulsingY = self.center.y - pulsingWidth * 0.5;// 脉冲layer CALayer * pulsingLayer = [CALayer layer]; pulsingLayer.frame = CGRectMake(pulsingX, pulsingY, pulsingWidth, pulsingWidth); pulsingLayer.borderColor = [UIColor colorWithRed:201/255.0 green:201/255.0 blue:201/255.0 alpha:1].CGColor; pulsingLayer.cornerRadius = pulsingWidth * 0.5; pulsingLayer.backgroundColor = [UIColor whiteColor].CGColor;//这里必须设置layer层的背景颜色，默认应该是透明的，导致设置的阴影颜色无法显示出来 pulsingLayer.shadowColor = [UIColor blackColor].CGColor; pulsingLayer.shadowOffset = CGSizeMake(0, 0); pulsingLayer.shadowOpacity = 1; pulsingLayer.shadowRadius = 5; [self.layer addSublayer:pulsingLayer]; // 缩放动画 CABasicAnimation * scaleAnimation = [CABasicAnimation animationWithKeyPath:@&quot;transform.scale&quot;]; scaleAnimation.autoreverses = false; scaleAnimation.fromValue = @1.0f; scaleAnimation.toValue = @2.0f; // 透明动画 CAKeyframeAnimation * opacityAnimation = [CAKeyframeAnimation animationWithKeyPath:@&quot;opacity&quot;]; opacityAnimation.keyTimes = @[@0,@0.1,@0.2,@0.3,@0.4,@0.5,@0.6,@0.7,@0.8,@0.9,@1]; opacityAnimation.values = @[@1,@0.9,@0.8,@0.7,@0.6,@0.5,@0.4,@0.3,@0.2,@0.1,@0]; CAAnimationGroup * animationGroup = [CAAnimationGroup animation]; animationGroup.beginTime = CACurrentMediaTime() + 1; animationGroup.fillMode = kCAFillModeBackwards; animationGroup.repeatCount = HUGE_VAL; animationGroup.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear]; animationGroup.duration = 2; animationGroup.animations = @[scaleAnimation,opacityAnimation]; [pulsingLayer addAnimation:animationGroup forKey:@&quot;pulse&quot;]; 这一步做完会出来如下效果： 接下来就是添加雷达的内圈layer,继续在上面的代码下面添加如下代码：123456789101112// 中间圆环CALayer * middleCycle = [CALayer layer];middleCycle.frame = CGRectMake(pulsingX, pulsingY, pulsingWidth, pulsingWidth);middleCycle.cornerRadius = pulsingWidth * 0.5;middleCycle.borderColor = [UIColor colorWithRed:41/255.0 green:152/255.0 blue:241/255.0 alpha:1].CGColor;middleCycle.backgroundColor = [UIColor whiteColor].CGColor;middleCycle.shadowOffset = CGSizeMake(0, 0);middleCycle.borderWidth = 1;middleCycle.shadowRadius = 3;middleCycle.shadowOpacity = 1;middleCycle.shadowColor = [UIColor lightGrayColor].CGColor;[self.layer addSublayer:middleCycle]; 。这里的坑也是出现在这块地方。因为在外部引用PulsingView的时候，设置的frame是控制器view的bounds,此时运行出来的结果如下： 接下来就是最后一步，添加扇形的layer 并添加扫描动画(一开始扇形是打算做成渐变的效果的，不过这里没有完美实现出来，一开始使用了一个三方XHRadarView,单纯的引用里面的扇形view的类，这样就可以直接使用他内部的渐变color，不过出来并不是很完美，所以还是自己画扇形，先不做渐变效果了。）此时就出现了关于position问题导致的坑. 这里一开的思路还是和之前一样，继续在self.layer上添加扇形的layer，以self.center为圆心，画一个90度的曲线：12345678910CGPoint fanshapedCenter = self.center; UIBezierPath * fanshapedPath = [UIBezierPath bezierPath]; [fanshapedPath addArcWithCenter:fanshapedCenter radius:(pulsingWidth + 20) * 0.5 startAngle:3 * M_PI / 2 endAngle:0 clockwise:YES]; [fanshapedPath addLineToPoint:fanshapedCenter]; [fanshapedPath closePath]; CAShapeLayer * fanshapedLayer = [CAShapeLayer layer]; fanshapedLayer.path = fanshapedPath.CGPath; fanshapedLayer.opacity = 0.7; fanshapedLayer.fillColor = [UIColor colorWithRed:41/255.0 green:152/255.0 blue:241/255.0 alpha:1].CGColor; [self.layer addSublayer:fanshapedLayer]; 此时运行出来静态情况下的都没问题： 然后添加旋转动画，让扇形绕着圆心进行自转：12345678CABasicAnimation *rotationAnimation = [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.z&quot;]; rotationAnimation.toValue = [NSNumber numberWithFloat: 3 * M_PI ]; rotationAnimation.duration = 8; rotationAnimation.cumulative = YES; rotationAnimation.removedOnCompletion = NO; rotationAnimation.repeatCount = MAXFLOAT; rotationAnimation.fillMode = kCAFillModeForwards; [fanshapedLayer addAnimation:rotationAnimation forKey:@&quot;rotation&quot;]; 然而运行出来的结果并没有和我们预期的一样： 仔细观察可以发现，扇形是在围绕着self的原点(0,0)点进行公转，一开始一直以为是画扇形的时候出的问题，是不是画法不对之类的，还试过直接用Quaritz2D 去画扇形，然而效果依然如此，经过各种查找，才发现是position 导致的问题，通过断点，打印一下hanshapedLayer可以看到如下信息：12Printing description of fanshapedLayer:&lt;CAShapeLayer:0x608000233640; position = CGPoint (0 0); bounds = CGRect (0 0; 0 0); allowsGroupOpacity = YES; fillColor = &lt;CGColor 0x6080000bef00&gt; [&lt;CGColorSpace 0x600000228940&gt; (kCGColorSpaceICCBased; kCGColorSpaceModelRGB; sRGB IEC61966-2.1; extended range)] ( 0.160784 0.596078 0.945098 1 ); opacity = 0.7; path = &lt;CGPath 0x60800003bf20&gt;&gt; 可以看到hanshapedLayer的position 是 (0,0),也就是父控件的左上角原点，文章开头我们提到过，layer的position 就是自己anchorPoint 相对于父layer 的坐标，而layer自身旋转也是相对于anchorPoint 旋转，这也就解释了为什么我们上面会出现扇形绕着屏幕的最上角做公转。所以我们就需要将hanshapedLayer 的 position 移到中心点的位置：1fanshapedLayer.position = fanshapedCenter; 此时我们再来看运行结果： 此时扇形确实是绕着中心点开始转了，但是并不是我们想要的结果。。。此时内心是崩溃的。所以放弃了这种动画的方式，直接将扇形fanshapedLayer添加到中间的内圈layer上，然后让内圈layer自转，最后可以实现最终的效果。12345678910111213// 扫描的扇形 UIBezierPath * fanshapedPath = [UIBezierPath bezierPath]; [fanshapedPath addArcWithCenter:CGPointMake(middleCycle.frame.size.width * 0.5, middleCycle.frame.size.height * 0.5) radius:(pulsingWidth + 30) * 0.5 startAngle:3 * M_PI / 2 endAngle:0 clockwise:YES]; [fanshapedPath addLineToPoint:CGPointMake(middleCycle.frame.size.width * 0.5, middleCycle.frame.size.height * 0.5)]; CAShapeLayer * fanshaped = [CAShapeLayer layer]; fanshaped.fillColor = [UIColor colorWithRed:41/255.0 green:152/255.0 blue:241/255.0 alpha:1].CGColor; fanshaped.opacity = 0.7; [fanshapedPath closePath]; fanshaped.path = fanshapedPath.CGPath; [middleCycle addSublayer:fanshaped];然后将动画添加到middleCycle上： [middleCycle addAnimation:rotationAnimation forKey:@&quot;rotation&quot;]; 后来在简书上又看到以篇博客也遇到了公转的问题 CALayer旋转动画参考这位 渣孩子博主的作法，将画扇形的代码作如下修改：12[fanshapedPath addArcWithCenter:CGPointZero radius:(pulsingWidth + 20) * 0.5 startAngle:3 * M_PI / 2 endAngle:0 clockwise:YES]; [fanshapedPath addLineToPoint:CGPointZero]; 现在原点位置画出扇形，然后再设置potisionfanshapedLayer.position = fanshapedCenter;最后终于解决了这个问题。 最后，贴上draw 方法里的全部代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798// An empty implementation adversely affects performance during animation.- (void)drawRect:(CGRect)rect &#123; // Drawing code [super drawRect:rect]; [[UIColor whiteColor] setFill]; UIRectFill(rect); UIImage * image = [UIImage imageNamed:@&quot;radar_background&quot;]; [image drawInRect:rect]; CGFloat pulsingWidth = rect.size.width / 2.5; CGFloat pulsingX = self.center.x - pulsingWidth * 0.5; CGFloat pulsingY = self.center.y - pulsingWidth * 0.5; // 脉冲layer CALayer * pulsingLayer = [CALayer layer]; pulsingLayer.frame = CGRectMake(pulsingX, pulsingY, pulsingWidth, pulsingWidth); pulsingLayer.borderColor = [UIColor colorWithRed:201/255.0 green:201/255.0 blue:201/255.0 alpha:1].CGColor; pulsingLayer.cornerRadius = pulsingWidth * 0.5; pulsingLayer.backgroundColor = [UIColor whiteColor].CGColor;//这里必须设置layer层的背景颜色，默认应该是透明的，导致设置的阴影颜色无法显示出来 pulsingLayer.shadowColor = [UIColor blackColor].CGColor; pulsingLayer.shadowOffset = CGSizeMake(0, 0); pulsingLayer.shadowOpacity = 1; pulsingLayer.shadowRadius = 5; [self.layer addSublayer:pulsingLayer]; // 缩放动画 CABasicAnimation * scaleAnimation = [CABasicAnimation animationWithKeyPath:@&quot;transform.scale&quot;]; scaleAnimation.autoreverses = false; scaleAnimation.fromValue = @1.0f; scaleAnimation.toValue = @2.0f; // 透明动画 CAKeyframeAnimation * opacityAnimation = [CAKeyframeAnimation animationWithKeyPath:@&quot;opacity&quot;]; opacityAnimation.keyTimes = @[@0,@0.1,@0.2,@0.3,@0.4,@0.5,@0.6,@0.7,@0.8,@0.9,@1]; opacityAnimation.values = @[@1,@0.9,@0.8,@0.7,@0.6,@0.5,@0.4,@0.3,@0.2,@0.1,@0]; CAAnimationGroup * animationGroup = [CAAnimationGroup animation]; animationGroup.beginTime = CACurrentMediaTime() + 1; animationGroup.fillMode = kCAFillModeBackwards; animationGroup.repeatCount = HUGE_VAL; animationGroup.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear]; animationGroup.duration = 2; animationGroup.animations = @[scaleAnimation,opacityAnimation]; [pulsingLayer addAnimation:animationGroup forKey:@&quot;pulse&quot;]; // 中间圆环 CALayer * middleCycle = [CALayer layer]; middleCycle.frame = CGRectMake(pulsingX, pulsingY, pulsingWidth, pulsingWidth); middleCycle.cornerRadius = pulsingWidth * 0.5; middleCycle.borderColor = [UIColor colorWithRed:41/255.0 green:152/255.0 blue:241/255.0 alpha:1].CGColor; middleCycle.backgroundColor = [UIColor whiteColor].CGColor; middleCycle.shadowOffset = CGSizeMake(0, 0); middleCycle.borderWidth = 1; middleCycle.shadowRadius = 3; middleCycle.shadowOpacity = 1; middleCycle.shadowColor = [UIColor lightGrayColor].CGColor; [self.layer addSublayer:middleCycle]; // 添加到self.layer上 CGPoint fanshapedCenter = self.center; UIBezierPath * fanshapedPath = [UIBezierPath bezierPath]; [fanshapedPath addArcWithCenter:CGPointZero radius:(pulsingWidth + 20) * 0.5 startAngle:3 * M_PI / 2 endAngle:0 clockwise:YES]; [fanshapedPath addLineToPoint:CGPointZero]; [fanshapedPath closePath]; CAShapeLayer * fanshapedLayer = [CAShapeLayer layer]; fanshapedLayer.path = fanshapedPath.CGPath; fanshapedLayer.opacity = 0.7; fanshapedLayer.position = fanshapedCenter; fanshapedLayer.fillColor = [UIColor colorWithRed:41/255.0 green:152/255.0 blue:241/255.0 alpha:1].CGColor; [self.layer addSublayer:fanshapedLayer]; // 添加到middleCycle上// [fanshapedPath addArcWithCenter:CGPointMake(0,0) radius:(pulsingWidth + 20) * 0.5 startAngle:3 * M_PI / 2 endAngle:0 clockwise:YES];// [fanshapedPath addLineToPoint:CGPointZero];// CAShapeLayer * fanshaped = [CAShapeLayer layer];// fanshaped.fillColor = [UIColor colorWithRed:41/255.0 green:152/255.0 blue:241/255.0 alpha:1].CGColor;// fanshaped.opacity = 0.7;// fanshaped.position = CGPointMake(middleCycle.frame.size.width * 0.5, middleCycle.frame.size.height * 0.5);// [fanshapedPath closePath];// fanshaped.path = fanshapedPath.CGPath;// [middleCycle addSublayer:fanshaped];// NSLog(@&quot;fanshaped==== frame:%@,anchorPoint:%@,bounds:%@,position:%@&quot;,NSStringFromCGRect(fanshaped.frame),NSStringFromCGPoint(fanshaped.anchorPoint),NSStringFromCGRect(fanshaped.bounds),NSStringFromCGPoint(fanshaped.position)); CABasicAnimation *rotationAnimation = [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.z&quot;]; rotationAnimation.toValue = [NSNumber numberWithFloat: 3 * M_PI ]; rotationAnimation.duration = 8; rotationAnimation.cumulative = YES; rotationAnimation.removedOnCompletion = NO; rotationAnimation.repeatCount = MAXFLOAT; rotationAnimation.fillMode = kCAFillModeForwards; // [middleCycle addAnimation:rotationAnimation forKey:@&quot;rotation&quot;]; [fanshapedLayer addAnimation:rotationAnimation forKey:@&quot;rotation&quot;];&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 项目小知识点]]></title>
    <url>%2F2017%2F08%2F26%2FiOS%20%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[#自定义控件 在- (instancetype)initWithFrame:(CGRect)frame里自定义控件在- (void)layoutSubviews 里布局控件 1234567名字叫attributes并且是NSDictionary *类型的参数，它的key一般都有以下规律 1.iOS7开始 1&gt; 所有的key都来源于： NSAttributedString.h 2&gt; 格式基本都是：NS***AttributeName 2.iOS7之前 1&gt; 所有的key都来源于： UIStringDrawing.h 2&gt; 格式基本都是：UITextAttribute*** 123 NSString * title = [button currentTitle]; // 获取按钮当前title文字 CGSize size = [title sizeWithAttributes:@&#123;NSFontAttributeName:button.titleLabel.font&#125;];//根据字体计算大小_titleUnderLine.backgroundColor = [titleButton titleColorForState:UIControlStateSelected]; //根据按钮title 颜色设置下划线颜色 #cell分割线顶头操作 ##1.第一种方法，利用系统的属性去设置 项目中经常会有些需求是cell 的分割线顶头，而系统默认的是前面有一定的间距，其实这是由一个separatorInset 属性造成的(iOS7以后出的)，通过打印： 1234567- (void)viewDidAppear:(BOOL)animated&#123; NXLog(@&quot;margin:%@&quot;,NSStringFromUIEdgeInsets(self.tableView.separatorInset));&#125;打印结果：margin:&#123;0, 15, 0, 0&#125; //可以看出来系统默认有一个15的偏移量 将该属性设置为空，现在tableView里面设置： 12 self.tableView.separatorInset = UIEdgeInsetsZero; //分隔线顶头，这个只是设置tableView 顶头，还需要在cell里设置cell的顶头通过这一步设置发现分割线比之前左移了不少，但是还没顶到头，这里就判断是cell自身的原因 同时在cell 里面进行设置：1self.separatorInset = UIEdgeInsetsZero;//cell分割线顶头 这时候运行再看结果，已经OK顶到头。 ##tableView底层实现 1.tableView 先把所有cell 的尺寸计算好，保存到一个数组里。2.当cell 要显示的时候就拿到这个cell 去设置frame : cell.frame = frames[row]。 ##2.第二种方法，重写cell 的setFrame,可以随意设置cell 的间距，比较万能。 主要思路：主要就是利用了上面的tableView 的实现原理。1.首先设置tableView的背景色为分割线的颜色。2.禁掉系统的分割线3.在cell类中重写setFrame 方法。 123456789101112 self.tableView.backgroundColor = NXColor(220, 220, 221); self.tableView.separatorStyle = UITableViewCellSeparatorStyleNone;//在自定义的cell类中：- (void)setFrame:(CGRect)frame&#123; NXLog(@&quot;cellFrame:%@&quot;,NSStringFromCGRect(frame)); //因为之前的frame 都是计算好的，这是在要显示的时候去设置一下，所以这里只去将高度减1，不会影响到其他尺寸 frame.size.height -=1; // 如果想要间距更大的话可以 -=10 等，随意这种方法比较万能 //这个才是系统真正的设置frame。重写了这个方法会将系统的frame清空，所以需要调用这个 [super setFrame:frame];&#125; #屏幕适配 1.一个view从Xib 加载，需不需要重新固定一下尺寸？ 这个是一定得需要的，比较保险。2.一般添加xib view的时候是在viewDidLoad 里面加载，但是设置尺寸frame 最好在viewDidLayoutSubViews 里面去设置。因为viewDidLoad 并不会去布局frame ，只是拿到xib 设置的大小属性，只有在 viewDidLayoutSubViews 里才会去根据布局去确定控件的最终尺寸(不过添加view 的操作不能放在这里，因为这个方法会调用多次) 12345678910111213141516171819202122🌰：- (void)viewDidLoad &#123; [super viewDidLoad]; UIView * loginView = [NXLoginRegistView loginView]; [self.middleView addSubview:loginView]; UIView * registView = [NXLoginRegistView registView]; [self.middleView addSubview:registView]; UIView * fastLogin = [NXFastLoginView fastLoginView]; [self.bottomView addSubview:fastLogin];&#125;- (void)viewDidLayoutSubviews&#123; [super viewDidLayoutSubviews]; //在这里面设置尺寸 UIView * loginView = [self.middleView subviews][0]; loginView.frame = CGRectMake(0, 0, self.middleView.frame.size.width * 0.5, self.middleView.frame.size.height); UIView * registView = [self.middleView subviews][1]; registView.frame = CGRectMake(self.middleView.frame.size.width * 0.5, 0, self.middleView.frame.size.width * 0.5, self.middleView.frame.size.height); UIView * fastLogin = [self.bottomView subviews][0]; fastLogin.frame = CGRectMake(0, 0, self.bottomView.frame.size.width, self.bottomView.frame.size.height);&#125; #从Xib加载的view 设置动画 是通过操作约束去设置，比如要修改x值产生动画就找到x的约束拖线添到类文件中成为属性，然后对该属性进行操作，在设置动画时，必须加上这句 ： 1[self.view layoutIfNeeded]; //这句话很重要，只有重新布局才会产生动画效果，否则没有动画效果 例如 1234[UIView animateWithDuration:1 animations:^&#123; self.testViewWidthConstraint.constant = 200; [self.view layoutIfNeeded]; //这句话很重要，只有重新布局才会产生动画效果，否则没有动画效果&#125;]; #一个xib文件可以管理多个view #重写button 的布局 这个在项目中也很常见，默认的按钮布局是左右布局，即左边imageView + 右边label 。而好多项目中需要的是上下布局，所以需要自定义button，重新布局。这里在layoutSubViews 方法里面进行，因为在这个方法里面所有的控件尺寸都已经是计算好的，我们就不需要重新去计算，只要改一下布局就可以。 123456789🌰：- (void)layoutSubviews&#123; [super layoutSubviews]; self.imageView.nx_y = 0; self.imageView.nx_centerX = self.nx_centerX; self.titleLabel.nx_y = self.nx_height - self.titleLabel.nx_height; self.titleLabel.nx_centerX = self.nx_centerX;&#125; #自定义tabBar的问题 项目中需要定制tabBar 的时候需要用到自定义tabBar,这里需要注意的是不能直接通过如下的赋值语法进行替换： 123456🌰： NXTabBar * nTabBar = [[NXTabBar alloc]init]; self.tabBar = nTabBar;这样替换的话是没有效果的，需要用KVC 的形式进行替换： [self setValue:nTabBar forKey:@&quot;tabBar&quot;]; #iOS类私有属性的访问和修改http://www.jianshu.com/p/a667f0ce9573 #iOS 类别中添加属性（属性和实例变量的区别）【转】iOS中属性与成员变量的区别iOS Category中添加属性和成员变量的区别 #通过category 和 runtime 设置textField 的 placehold 的颜色 项目中经常会用到textField ，比如登录注册等。默认的光标是蓝色，而且placeholder的文字颜色也是灰的，不会变化。有时候项目会需求点击后光标为白色，同时placeholder 的文字高亮为白色(或其他颜色)。通过头文件一级一级往上查找，找到了一个如下属性: 1@property(nullable, nonatomic,copy) NSAttributedString *attributedPlaceholder 利用这个属性，用如下方法进行颜色修改： 123//第一个参数: 需要被设置属性的字符串//第二个参数: 需要设置的属性 self.attributedPlaceholder = [[NSAttributedString alloc]initWithString:self.placeholder attributes:@&#123;NSForegroundColorAttributeName:[UIColor whiteColor]&#125;]; 这个方法虽然达到效果了，但是比较麻烦，通过如下图的方式，随便写一个textField ,然后打上短点，我们可以看到在textField 内部有placeholderLabel的属性，所以可以尝试通过对该属性进行操作，直接修改颜色。不过通过下面的调试框可以看到这是一个私有属性。想要对私有属性进行访问和修改可以使用kvc 或者 runtime ,这里使用kvc ,新建一个类别，添加属性placeholderColor,在set 方法里面去进行设置： 1234567891011121314151617181920🌰：h 文件#import &lt;UIKit/UIKit.h&gt;@interface UITextField (NXTextField)@property (nonatomic ,strong)UIColor *placeholdColor;@endm 文件- (void)setPlaceholdColor:(UIColor *)placeholdColor&#123; //根据判断，textField 内部的 placehold 是一个label 的标签 UILabel * placeholderLabel = [self valueForKey:@&quot;placeholderLabel&quot;]; placeholderLabel.textColor = placeholdColor;&#125;- (UIColor *)placeholdColor&#123; return nil; // 暂时先不用，返回一个nil ，去掉系统的警告⚠️&#125; 然后可以在需要设置的地方引入category 的头文件，通过如下方式即可设置颜色： 1self.placeholdColor = [UIColor lightGrayColor]; 通过上面category 的方式基本可以满足需求，但是如果textField 如下设置的时候就会出现无效： 123456789// 这样设置是可以的： self.placeholder = @&quot;44444&quot;; self.placeholdColor = [UIColor lightGrayColor];//将上面的换个顺序执行，就会无效: self.placeholdColor = [UIColor lightGrayColor]; self.placeholder = @&quot;44444&quot;;//这是因为之前没有设置placeholder文字，设置颜色的时候通过断点可以看到，此时获取不到placeholderLabel,所以导致设置颜色无效。 解决这个问题就需要用到runtime1.先将 placeholderColor 保存起来2.在设置placeholder 的时候再取出来设置颜色 123456789101112131415161718192021222324- (void)setPlaceholdColor:(UIColor *)placeholdColor&#123; //先将placeholdColor 存起来 //参数一：给哪个对象添加成员属性 //参数二：成员属性的名字 //参数三：成员属性的值 objc_setAssociatedObject(self, @&quot;placeholdColor&quot;, placeholdColor, OBJC_ASSOCIATION_RETAIN_NONATOMIC); //根据判断，textField 内部的 placehold 是一个label 的标签 UILabel * placeholderLabel = [self valueForKey:@&quot;placeholderLabel&quot;]; placeholderLabel.textColor = placeholdColor;&#125;- (UIColor *)placeholdColor&#123; return objc_getAssociatedObject(self, @&quot;placeholdColor&quot;);&#125;//自顶一个setPlaceholder方法，在内部1.先设置文字。 2.设置颜色- (void)setNX_Placeholder:(NSString *)placeholder&#123; self.placeholder = placeholder; self.placeholdColor = self.placeholdColor;&#125; 上面方法有个缺点就是每次设置placeholder文字还得去调用1[self setNX_Placeholder:@&quot;hhhh&quot;]; 所以想要直接通过: self.placeholder = @”hhhh”; 去设置，就需要用到方法交换。因为交换只需要做一次操作，所以，放到+(void)load方法里去操作,在category文件中加入：12345+ (void)load&#123; Method setPlaceholder = class_getInstanceMethod(self, @selector(setPlaceholder:)); Method setNx_Placeholder = class_getInstanceMethod(self, @selector(setNX_Placeholder:)); method_exchangeImplementations(setPlaceholder, setNx_Placeholder);&#125; #计算总行数的万能公式 1row = (count -1 ) / column +1; #tableView 调整cell 间距 用storyBoard 拖出来的cell 默认显示的是如下图的间距(因为要使用到静态单元格，所以用到storyBoard,一般情况下用xib最好) 这里用的是分组style，所以可以通过设置12self.tableView.sectionFooterHeight = 0; self.tableView.sectionHeaderHeight = 0; 得到如下效果: 可以看到每个分组之间的间距已经没了，但是第一个cell 距离顶部还是有好大一部分距离，这里判断可能是tableView 的间距,通过下面打印 可以看到tableView 距离顶部确实有64 的偏移量，但是这个刚好是空出导航栏的高度，所以排除是tableView 的问题，接下来就判断是cell 的问题，通过下面打印 可以看到分组内部第一个cell 的Y 值默认是35 ，那么这里可以在viewDidLoad 方法里进行如下调整就可以（这里需要间隔为10）123self.tableView.sectionFooterHeight = 0; self.tableView.sectionHeaderHeight = 10; self.tableView.contentInset = UIEdgeInsetsMake(-25, 0, 0, 0); #跳转到网页 1.Safari openURL 自带很多功能:进度条，刷新，前进，倒退等功能。但是需要跳出到当前应用。2.UIWebView 在当前应用打开网页，并且带有Safari（自己实现），不能实现进度条。3.SFSafariViewController 专门用来显示网页,既可以在当前应用显示网页，又可以有Safari的功能。iOS9以后才可以用。4.WKWebView #判断view 是否被加载123456789101112随便一个都可以: UIViewController * vc = self.childViewControllers[button.tag]; if (vc.isViewLoaded) &#123;//如果已经被加载过就不重复加载(加载view 的时候会调用 viewDidLoad) return ; &#125; UIView * view = vc.view; if (view.superview) &#123; // 如果有父view ，说明已经被添加过 return; &#125; if (view.window) &#123; //如果有容器，说明已经被添加过 return; &#125; 一些全局常量，尽量使用extern来引用，其次再选择考虑Macro iOS const的使用关于全局常量的定义 #xib cell 拖线报错： Terminating app due to uncaught exception ‘NSUnknownKeyException’, reason: ‘[ setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key 如下图，我已开始在File`s Owner里也设置了class是NXTopicCell,所以一直出错，这里吧他清空，设置下面的Topic Cell 的class如下就可以 xib拖的UILabel 没有自动换行：设置约束时不要给定高度就可以自动换行了。 #在heightForRowAtIndexPath获取cell 崩溃http://www.jianshu.com/p/3da539540d21 在网上看到有人是这么获取：1NXTopicCell * cell = (NXTopicCell *)[self tableView:tableView cellForRowAtIndexPath:indexPath]; 试了下好像是可以。 好像xib 里设置的高度是定死的，不会根据不同屏幕去重新计算高度。 ##退出键盘 1.监听scrollView实时滚动代理方法调用[self.view endEditing:YES]或者[self.textField resignFirstResponse];2.touchBegin方法里,调用[self.view endEditing:YES]或者[self.textField resignFirstResponse]; ##父View添加手势，子View不要去响应父View点击事件iOS 点击子视图不让其响应父视图手势 在做这样一个界面的时候 背景的蒙版层是一个UIView,按钮的列表View添加到背景的蒙版View上。在蒙版层添加一个手势，点击dismiss掉这个界面和蒙版。但是遇到问题就是在点击按钮列表的View的时候也出发了单击手势。这个好像是系统默认的，参考事件响应链。为了避免这种效果，在手势触发事件中可以判断当前点击事件是否在父View上，如果是子View上则不去做操作，点击在父View上才去做dismiss的操作。代码如下： 1234567891011121314151617- (void)dismissMoreActionView:(UITapGestureRecognizer *)tap&#123; //根绝tag获取子view UIView *subView = [self viewWithTag:100]; /* BOOL contains = CGRectContainsPoint(CGRect rect, CGPoint point); 判断一个CGRect是否包含再另一个CGRect里面,常用与测试给定的对象之间是否又重叠 - (CGPoint)locationInView:(UIView *)view： 该函数返回一个CGPoint类型的值，表示触摸在view这个视图上的位置，这里返回的位置是针对view的坐标 */ // 判断手势点击的位置是不是包含在子视图上 if (!CGRectContainsPoint(subView.frame, [tap locationInView:self])) &#123; [self removeFromSuperview]; &#125;&#125; 调整导航栏leftBarButtonItem 和 rightBarbuttonItem 的偏移量 如何调整导航条上的leftBarButtonItem和rightBarButtonItem的位置 ####重点：这里需要提到BarButtonSystemItem的样式－ UIBarButtonSystemItemFixedSpace我不多说 请看官方解释:Blank space to add between other items. Only the width property is used when this value is set. 反正我是看不懂 。再来说说negativeSpacer.width = 0 表示leftBarButtonItem的x离屏幕的左边还有15像素 同样表示rightBarButtonItem的CGRectGetMaxX()离屏幕的右边还有15像素 那么好像我们就可以通过negativeSpacer.width来调整leftBarButtonItem的位置。搞了老半天原来就是得靠这家伙。但有一点：negativeSpacer.width赋值负数对于leftBarButtonItem来说是左移多少像素 对于rightBarButtonItem来说是右移多少像素 反之亦然. 我这里想要设置右边的item 右移一点，因为默认的太偏左了：123456789101112131415161718UIButton * buyBtn = [[UIButton alloc]init]; buyBtn.frame = CGRectMake(0, 0, 80, 40); buyBtn.backgroundColor = [UIColor orangeColor]; [buyBtn setTitle:@&quot;马上选购&quot; forState:UIControlStateNormal]; buyBtn.titleLabel.font = [UIFont systemFontOfSize:15]; [buyBtn addTarget:self action:@selector(buyItemAction) forControlEvents:UIControlEventTouchUpInside]; UIBarButtonItem * buyItem = [[UIBarButtonItem alloc]initWithCustomView:buyBtn]; UIBarButtonItem * space = [[UIBarButtonItem alloc]initWithBarButtonSystemItem:UIBarButtonSystemItemFixedSpace target:nil action:nil]; space.width = -10; self.navigationItem.rightBarButtonItems = @[space,buyItem]; ##动态修改UIButton的title 的时候字体闪烁的问题： UIButton-system类型 动态改变title 显示文字时闪动(解决方案) ##assign 修饰代理导致野指针的问题 在下面方法中调用了代理，崩溃指向这里显示野指针的错误，猜测是由于代理被释放而去调用产生的问题。点进去看到之前代理修饰用的是assign 修饰的，改为weak 后好像是可以了。猜测原因是由于assign 修饰的话 assign是指针赋值，不对引用计数操作，使用之后如果没有置为nil，可能就会产生野指针；而weak一旦不进行使用后，永远不会使用了，就不会产生野指针。 12345678910- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123; if ([_delegate respondsToSelector:@selector(numberOfRowsInTableView:Insection:FromView:)]) &#123; NSInteger vRows = [_dataSource numberOfRowsInTableView:tableView Insection:section FromView:self]; mRowCount = vRows; return vRows; &#125; return 0;&#125; ##单例问题 在使用单例的时候，经常性就是直接写出下面的代码。不过最近在使用的时候会遇到单例导致崩溃的问题。一开始在写 dispatch_once_t once_token的时候没有用static 来修饰，后来加上static来修饰就好了。 12345678910111213+ (instancetype)shareInstance&#123; static DrawTextView * drawText = nil; static dispatch_once_t once_token; dispatch_once(&amp;once_token, ^&#123; drawText = [[DrawTextView alloc]initWithFrame:CGRectMake(kDeviceW * 0.5- TextLayerWidth * 0.5, kDeviceH * 0.5 - TextLayerHeight * 0.5, TextLayerWidth, TextLayerHeight)]; drawText.backgroundColor = [UIColor orangeColor]; &#125;); return drawText;&#125; ##在iPhone5s （10.2系统）拨打电话没有弹框提示，其他手机（10.3）有弹框```// 用这种方法的话会出现上面的问题// NSString * phonNum = [NSString stringWithFormat:@”tel://%@”,self.footerModel.dav_phone]; NSString * phonNum = [NSString stringWithFormat:@&quot;telprompt://%@&quot;, self.footerModel.dav_phone]; ##控制器切换从下往上，并且有导航栏： 可以用CATransition 动画，或者直接用presentModalViewController。http://www.cocoachina.com/bbs/read.php?tid=7668 ##改变SearchBar 的取消按钮颜色，光标颜色 http://www.jianshu.com/p/66b5b777f5dc]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工作中的坑]]></title>
    <url>%2F2017%2F08%2F26%2F%E5%B7%A5%E4%BD%9C%E4%B8%AD%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[1.通过xib加载的控件在viewDidLoad 中重新计算布局不准确的问题 在爱山门实时上门模块，由于之前没有加网络提示器或者没网的空白页之类的，在网络情况差的情况下，直接就是一个空白页放在那里，用户体验特别不好，所以这里需要加上一个网络的提示器在加载的时候进行弹窗提示用户，记载成功的话就直接显示数据，失败的话就提示网络问题。这个直接用SVProgress就可以。由于这里的界面布局比较固定，所以最好可以再做一个本地缓存，利用FMDB将上一次的数据存到本地，下次打开的话先从数据库去获取数据，没有的话再去网络请求。这里遇到了一个问题，折腾了大半个上午。就是每次通过本地缓存去加载数据的时候滑动范围总是不准，在viewDidLoad中已经计算好了scrollView 的高度和tableView 的高度，但是在viewDidDissAppear 中再去打印的话会发现尺寸并不是我们计算的那个结果。下拉刷新或者直接去加载网络的数据的时候就没问题。后来一直调试查找猜测应该是xib 的问题，因为这里的scrollView 和 tableView 都是通过xib 去加载的，通过xib 加载的文件在viewDidLoad中加载的时候并不会去布局frame ，只是拿到xib 中设置的大小属性，只有在 viewDidLayoutSubViews 里才会去根据布局去确定控件的最终尺寸(不过添加view 的操作不能放在这里，因为这个方法会调用多次) #####2.导航栏隐藏 push 到下个界面再手势返回的时候显示和隐藏的问题。如下： 好多项目中都会有这样的需求，导航栏透明或者隐藏，但是push 到下一个界面，如果用手势返回的话就会出现如上的问题， 比如积分商城：个人中心界面需要隐藏导航栏，设置如下：12345678- (void)viewWillAppear:(BOOL)animated&#123; [super viewWillAppear:animated]; [self.navigationController setNavigationBarHidden:YES animated:animated]; [self getCenter];&#125; 点击积分商城需要显示导航栏，设置如下：12345678910- (void)viewWillAppear:(BOOL)animated&#123; [super viewWillAppear:animated];// [Glob showTabBar]; [[self rdv_tabBarController] setTabBarHidden:YES animated:YES]; [self.navigationController setNavigationBarHidden:NO animated:YES];&#125; 如果只是这样设置的话手势返回的话就会出现上面的问题。网上找了各种资料和三方库，比如 让我们一次性解决导航栏的所有问题 ),由于之前项目中使用的tabBar 是 三方的RDVTabBarController，所以用上面文章中的三方总会出先手势返回的时候上一个控制器被一个空白的UIView挡住的情况。所以又开始找其他的同样不是很完美。最后抱着瞎猫碰死耗子的心态，就试试网上的一些建议，采用如下写法，在积分商城界面加上如下代码：12345- (void)viewWillDisappear:(BOOL)animated&#123; [self.navigationController setNavigationBarHidden:NO animated:YES]; [super viewWillDisappear:animated] ; // 切记要加这个，不然没效果&#125; 一开始在一个空白的项目中做了测试，这样确实是可以了，但是放到公司项目却还是没用，一开始怀疑是 [super viewWillDisappear:animated]方法应该放在最后调用，后来测试放在前面和后面都没区别。最后发现问题是在个人中心界面，一开始个人中心界面隐藏导航栏的时候，动画那块设置的是NO：1[self.navigationController setNavigationBarHidden:YES animated:NO]; 最后改成如下：123[self.navigationController setNavigationBarHidden:YES animated:animated];至于这里的animated 写成 没有写成YES OR NO 是因为在网上看到过系统返回的属性不只是这两个（虽然我也不懂）不过这里animated 写成YES 也可以。 发现可以正常使用了。效果如下： Perfect!更新后来发现只需要在个人中心设置1[self.navigationController setNavigationBarHidden:YES animated:animated] // 这里animated 写成YES 也可以 不用再在其他界面再添加12345- (void)viewWillDisappear:(BOOL)animated&#123; [self.navigationController setNavigationBarHidden:NO animated:YES]; [super viewWillDisappear:animated] ; // 切记要加这个，不然没效果&#125; 也一样可以实现效果 ######3.使用字典转模型的时候遇到崩溃 NSInvalidArgumentException -[__NSTaggedPointerString unsignedLongLongValue]: unrecognized selector sent to instance 这个问题，是因为64bit中，NSString 中没有unsignedLongLongValue这个方法了， 而当字典中obj的类型是NSString类型，实体中的key对应的属性是NSUinteger类型，setValue:obj forKey:key 会自动做如下处理：[obj unsignedLongLongValue] 将value转为对应的属性类型，这就导致64bit中找不到该方法而crash。解决是，对NSString写一个category，重新写一个unsignedLongLongValue的方法： 123-(NSUinteger)unsignedLongLongValue &#123; return [self integerValue];&#125; 或者 避免 让系统做NSString-&gt;NSUInteger的类型装换]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清除缓存]]></title>
    <url>%2F2017%2F08%2F26%2F%E6%B8%85%E9%99%A4%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[现在的大多数APP都带有缓存功能，尤其是使用一些第三方框架，比如SDWebImage 就自带缓存功能。当用了一段时间后，缓存就会越来愈大，如果不清除的话就会影响用户体验和性能，所以大多📚APP加了清除缓存的功能。这里的主要实现思路也是根据SDWebImage 的思路去实现。这里需要用到一个 simpholders工具可以直接查看沙盒下的东西。 #1.获取缓存 既然是参考SDWebImage去实现，那么首先就是进去看看他是怎么实现的，首先先导入 #import &lt;SDWebImage/SDImageCache.h&gt;头文件，这是SDWebImage 的一个管理缓存的类，点进去在文件中搜索关键词cache,会看到好多结果，一直往下拉，会看到这么几个方法： 1234567我们看到里面有这样一个方法，很明显这个是我们常写的单例。待会儿会用到/** * Returns global shared cache instance * * @return SDImageCache global instance */+ (SDImageCache *)sharedImageCache; 再往下就看到下面的方法： 这些根据字面意思很容易看出来都是干什么的。既然这里我们的第一步是想先获取缓存，那么我们就主要先看一下getSize方法，点击进去会看到如下方法： 123456789101112- (NSUInteger)getSize &#123; __block NSUInteger size = 0; dispatch_sync(self.ioQueue, ^&#123; NSDirectoryEnumerator *fileEnumerator = [_fileManager enumeratorAtPath:self.diskCachePath]; for (NSString *fileName in fileEnumerator) &#123; NSString *filePath = [self.diskCachePath stringByAppendingPathComponent:fileName]; NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfItemAtPath:filePath error:nil]; size += [attrs fileSize]; &#125; &#125;); return size;&#125; 这里我们看到需要用到一个 _fileManager的对象，这是一个NSFileManager 的对象,我们先回到我们的类文件中，去调用一下getSize 方法获取缓存。通过上面的工具我们可以查看SDWebImage的缓存文件：在default文件下面就是 12345 NSUInteger cach = [[SDImageCache sharedImageCache] getSize]; NXLog(@&quot;sdweb-----caches:%lu&quot;,(unsigned long)cach);打印结果如下2017-02-06 23:41:09.554 BaiSi[44360:1314372] sdweb-----caches:2824429 通过右键查看文件，得到结果如下，比打印结果大是因为这里还包括了隐藏文件.DS 我们也以获取这个文件夹缓存的大小为试验，看看自己写的结果是否和SD 的一样：12345678910111213141516- (void)clearCach&#123; //1.先获取cache 目录的路径 NSString * cachePath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject]; // 这里先以获取 default 文件夹大小做实验，看看是否和 SDImageCache 获取的一样 NSString * directorPath = [cachePath stringByAppendingPathComponent:@&quot;default&quot;]; //2.声明一个文件管理对象 NSFileManager * fileManager = [NSFileManager defaultManager]; //3.在 SDImageCache 的getSize 方法里面我们看到调用了一个方法 NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfItemAtPath:filePath error:nil];所以我们也模仿他去做 NSDictionary * attrs = [fileManager attributesOfItemAtPath:directorPath error:nil]; //4.最后获取size NSUInteger size = [attrs fileSize]; NXLog(@&quot;custom----size:%lu&quot;,(unsigned long)size); //打印结果如下 // 2017-02-06 23:47:01.843 BaiSi[44442:1317486] custom----size:136&#125; 可以看到最后的结果和SD差了相当多，初步判断这个可能不可以获取文件夹的大小，智能或许文件的大小，为了验证，我们拼接一个文件的路径，在上面第一步获取路径下面再加上一个image 的路径，如下：12345NSString * imagePath = [directorPath stringByAppendingPathComponent:@&quot;com.hackemist.SDWebImageCache.default/aa96232fe024aeba562815618fd5e02a.jpg&quot;];第三步里的directorPath 改成 imagePath ,运行//打印结果如下：2017-02-07 00:00:04.244 BaiSi[44688:1326243] custom----size:169817 我们直接通过查看图片属性结果如下： 和我们得到的结果一模一样，说明该属性方法只是获取文件的大小，所以我们需要遍历目的文件夹下的所有文件，将大小累加起来，就是该文件夹的总大小。在SD 的 getSize 方法里面我们可以看到他调用的是 NSDirectoryEnumerator *fileEnumerator = [_fileManager enumeratorAtPath:self.diskCachePath];方法，然后去遍历fileEnumerator。这里我们可以用另一个属性subpathsAtPath:directorPath，改写clearCach如下：1234567891011121314151617181920212223- (void)clearCach&#123; //1.先获取cache 目录的路径 NSString * cachePath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject]; // 这里先以获取 default 文件夹大小做实验，看看是否和 SDImageCache 获取的一样 NSString * directorPath = [cachePath stringByAppendingPathComponent:@&quot;default&quot;]; //2.声明一个文件管理对象 NSFileManager * fileManager = [NSFileManager defaultManager]; //3.在 SDImageCache 的getSize 方法里面我们看到调用了一个方法 NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfItemAtPath:filePath error:nil];所以我们也模仿他去做 //这个可以获取所有的子文件及子文件下的文件 NSArray * subPaths = [fileManager subpathsAtPath:directorPath]; NXLog(@&quot;subPaths:%@&quot;,subPaths); NSDictionary * attrs = [fileManager attributesOfItemAtPath:directorPath error:nil]; //4.最后获取size NSUInteger size = [attrs fileSize]; NXLog(@&quot;custom----size:%lu&quot;,(unsigned long)size); //打印结果如下 // 2017-02-06 23:47:01.843 BaiSi[44442:1317486] custom----size:136&#125; 打印结果： 可以看到 这个方法获取到了default 文件夹下的子文件夹及子文件夹下的文件以及隐藏文件.接下来我们继续修改clearCach 方法：123456789101112131415161718192021222324- (void)clearCach&#123; //1.先获取cache 目录的路径 NSString * cachePath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject]; // 这里先以获取 default 文件夹大小做实验，看看是否和 SDImageCache 获取的一样 NSString * directorPath = [cachePath stringByAppendingPathComponent:@&quot;default&quot;]; //2.声明一个文件管理对象 NSFileManager * fileManager = [NSFileManager defaultManager]; //3.在 SDImageCache 的getSize 方法里面我们看到调用了一个方法 NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfItemAtPath:filePath error:nil];所以我们也模仿他去做 //这个可以获取所有的子文件及子文件下的文件 NSArray * subPaths = [fileManager subpathsAtPath:directorPath]; NSUInteger totoalSize = 0 ; for (NSString * path in subPaths) &#123; NSString * filePath = [directorPath stringByAppendingPathComponent:path]; NSDictionary * attrs = [fileManager attributesOfItemAtPath:filePath error:nil]; //4.最后获取size totoalSize += [attrs fileSize]; &#125; NXLog(@&quot;custom----size:%lu&quot;,(unsigned long)totoalSize);&#125; 最终打印结果如下 基本上和SD 自己获取的大小差不多，这里比SD 的大是因为这里没有排除隐藏文件.DS_Store和下面那个default 文件夹,接下来对这两个文件进行排除：123456789101112131415161718192021222324252627282930313233- (void)clearCach&#123; //1.先获取cache 目录的路径 NSString * cachePath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject]; // 这里先以获取 default 文件夹大小做实验，看看是否和 SDImageCache 获取的一样 NSString * directorPath = [cachePath stringByAppendingPathComponent:@&quot;default&quot;]; //2.声明一个文件管理对象 NSFileManager * fileManager = [NSFileManager defaultManager]; //3.在 SDImageCache 的getSize 方法里面我们看到调用了一个方法 NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfItemAtPath:filePath error:nil];所以我们也模仿他去做 //这个可以获取所有的子文件及子文件下的文件 NSArray * subPaths = [fileManager subpathsAtPath:directorPath]; NSUInteger totoalSize = 0 ; for (NSString * path in subPaths) &#123; NSString * filePath = [directorPath stringByAppendingPathComponent:path]; //判断是否是隐藏文件 if ([filePath containsString:@&quot;.DS&quot;]) &#123; continue; &#125; //判断是否是文件夹 BOOL isDirector; BOOL fileExist = [fileManager fileExistsAtPath:filePath isDirectory:&amp;isDirector]; if (!fileExist || isDirector) &#123; continue; &#125; NSDictionary * attrs = [fileManager attributesOfItemAtPath:filePath error:nil]; //4.最后获取size totoalSize += [attrs fileSize]; &#125; NXLog(@&quot;custom----size:%lu&quot;,(unsigned long)totoalSize); &#125; 这个时候得到的结果就和SD 的一样了。上面的结果基本上已经可以满足功能了，不过为了复用性，还得进行一些修改，最好是能传入一个文件夹的路径然后获取大小，这里吧方法名改了一下：123456789101112131415161718192021222324252627282930313233343536373839- (NSUInteger)getFileSize:(NSString *)directorPath&#123; //2.声明一个文件管理对象 NSFileManager * fileManager = [NSFileManager defaultManager]; //3.在 SDImageCache 的getSize 方法里面我们看到调用了一个方法 NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfItemAtPath:filePath error:nil];所以我们也模仿他去做 //这个可以获取所有的子文件及子文件下的文件 NSArray * subPaths = [fileManager subpathsAtPath:directorPath]; NSUInteger totoalSize = 0 ; for (NSString * path in subPaths) &#123; NSString * filePath = [directorPath stringByAppendingPathComponent:path]; //判断是否是隐藏文件 if ([filePath containsString:@&quot;.DS&quot;]) &#123; continue; &#125; //判断是否是文件夹 BOOL isDirector; BOOL fileExist = [fileManager fileExistsAtPath:filePath isDirectory:&amp;isDirector]; if (!fileExist || isDirector) &#123; continue; &#125; NSDictionary * attrs = [fileManager attributesOfItemAtPath:filePath error:nil]; //4.最后获取size totoalSize += [attrs fileSize]; &#125; NXLog(@&quot;custom----size:%lu&quot;,(unsigned long)totoalSize); return totoalSize;&#125;// 然后在调用的地方如下就可以了： //1.先获取cache 目录的路径 NSString * cachePath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject]; // 这里先以获取 default 文件夹大小做实验，看看是否和 SDImageCache 获取的一样 NSString * directorPath = [cachePath stringByAppendingPathComponent:@&quot;default&quot;]; [self getFileSize:directorPath]; 上面的结果已经基本满足功能了。但是如果是遇到一个很大的文件夹的话，该操作可能会造成卡线程，所以最好能放到异步线程里去操作。由于是异步操作，这里就不适合用return 来返回结果了，可以用block的形式来传结果：12345678910111213141516171819202122232425262728293031323334353637- (void)getFileSize:(NSString *)directorPath completion:(void(^)(NSUInteger totoalSize))completion&#123; //2.声明一个文件管理对象 NSFileManager * fileManager = [NSFileManager defaultManager]; //3.在 SDImageCache 的getSize 方法里面我们看到调用了一个方法 NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfItemAtPath:filePath error:nil];所以我们也模仿他去做 dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; //这个可以获取所有的子文件及子文件下的文件 NSArray * subPaths = [fileManager subpathsAtPath:directorPath]; NSUInteger totoalSize = 0 ; for (NSString * path in subPaths) &#123; NSString * filePath = [directorPath stringByAppendingPathComponent:path]; //判断是否是隐藏文件 if ([filePath containsString:@&quot;.DS&quot;]) &#123; continue; &#125; //判断是否是文件夹 BOOL isDirector; BOOL fileExist = [fileManager fileExistsAtPath:filePath isDirectory:&amp;isDirector]; if (!fileExist || isDirector) &#123; continue; &#125; NSDictionary * attrs = [fileManager attributesOfItemAtPath:filePath error:nil]; //4.最后获取size totoalSize += [attrs fileSize]; &#125; //完成之后回调 //这里需要在主线程去回调。不然接收不到值。这里可以用同步操作，不会太耗时 dispatch_sync(dispatch_get_main_queue(), ^&#123; if (completion) &#123; completion(totoalSize); &#125; &#125;); &#125;);&#125; 到这一步已经可以完成了。不过我们还可以在完善一点，因为我们永远无法想象用户会做什么操作。同样我们将这样的方法丢给同事去调用，也无法去想象他们会传一些什么稀奇古怪的参数，比如，他直接给你传个文件的路径而不是文件夹，所以我们还得加一些异常处理，比如抛异常，就像苹果经常干的那样。最终我们修改后的方法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748- (void)getFileSize:(NSString *)directorPath completion:(void(^)(NSUInteger totoalSize))completion&#123; //2.声明一个文件管理对象 NSFileManager * fileManager = [NSFileManager defaultManager]; // 在这里做一些异常的处理 //判断是否是文件夹 BOOL isDirector; BOOL fileExist = [fileManager fileExistsAtPath:directorPath isDirectory:&amp;isDirector]; if (!fileExist || !isDirector) &#123; NSException * exception = [NSException exceptionWithName:@&quot;PathError&quot; reason:@&quot;hey,man,这里需要的是一个文件夹的路径，并且是存在的&quot; userInfo:nil]; [exception raise]; &#125; //3.在 SDImageCache 的getSize 方法里面我们看到调用了一个方法 NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfItemAtPath:filePath error:nil];所以我们也模仿他去做 dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; //这个可以获取所有的子文件及子文件下的文件 NSArray * subPaths = [fileManager subpathsAtPath:directorPath]; NSUInteger totoalSize = 0 ; for (NSString * path in subPaths) &#123; NSString * filePath = [directorPath stringByAppendingPathComponent:path]; //判断是否是隐藏文件 if ([filePath containsString:@&quot;.DS&quot;]) &#123; continue; &#125; //判断是否是文件夹 BOOL isDirector; BOOL fileExist = [fileManager fileExistsAtPath:filePath isDirectory:&amp;isDirector]; if (!fileExist || isDirector) &#123; continue; &#125; NSDictionary * attrs = [fileManager attributesOfItemAtPath:filePath error:nil]; //4.最后获取size totoalSize += [attrs fileSize]; &#125; //完成之后回调 //这里需要在主线程去回调。不然接收不到值。这里可以用同步操作，不会太耗时 dispatch_sync(dispatch_get_main_queue(), ^&#123; if (completion) &#123; completion(totoalSize); &#125; &#125;); &#125;);&#125; 然后在调用的时候传入一个错误的地址，正如我们所料，Xcode崩了，在控制台出来结果如下：OK，可以收工了。 #清除缓存 清楚缓存相对比较简单，直接贴代码吧:12345678910- (void)removeFiles:(NSString *)directorPath&#123; NSFileManager * manager = [NSFileManager defaultManager]; //这个方法是获取该文件下的所有子文件夹，不会获取子文件夹里的文件(这里没必要了，直接删除文件夹就可以) NSArray * subDirectors = [manager contentsOfDirectoryAtPath:directorPath error:nil]; for (NSString * path in subDirectors) &#123; NSString * filePath = [directorPath stringByAppendingPathComponent:path]; //删除文件夹 [manager removeItemAtPath:filePath error:nil]; &#125; &#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杂记]]></title>
    <url>%2F2017%2F08%2F26%2F%E6%9D%82%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[世界那么大，我想去看看 hexo 常用命令： 123456hexo new postName #新建文章 在source/_posts 下生成hexo new page pageName #新建页面 在source/pageName 下生成hexo deploy #将.deploy目录部署到GitHub 简写指令：hexo dhexo generate #生成静态页面至public目录 简写指令：hexo ghexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）简写指令hexo shexo clean #清除所有静态页面和缓存数据 next 文档：http://theme-next.iissnan.com/getting-started.html]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F07%2F12%2Ftest%2F</url>
    <content type="text"><![CDATA[note: Atom MarkDown文件编辑快捷键：contorl + shift + M 进入预览模式 父目录 ####### 我是子目录 我是孙子目录 删除本地索引库文件1pod repo remove xxxlib 有时候想要改变本地的索引库名称，可以用这个删除掉之前的，然后通过 pod repo add newName git地址来设置新的名称。 事件响应链 寻找最合适的view ####### 我是子目录 我是孙子目录 当一个事件传递给view 的时候会调用 1- (UIView *)hitTest:(CGPOint)point withEvent:(UIEvent *)event; 判断当前点在不在调用的view 的身上。 他是在hitTest方法中调用的。 1- (BOOL)pointInsid:(CGPOint)point withEvent:(UIEvent *)event; 1.先去判断当前的View 是不是控制器的View,如果当前的View是控制器的View，那么，它的上一个响应链就是它所在的控制器 2.如果当前View 不是控制器的View ,那么父控件就是上一个响应链。 #pragma mark - C语言数组动态内存分配数组的缺点： 数组长度必须事先制定，且只能是常整数，不能是变量。 🌰12int a[5] = &#123;1,2,3,4,5&#125;; // 正确int length = 5; a[length]; // error 传统形式定义的数组，程序员无法手动释放该数组的内存。在一个函数运行期间，该函数为该数组分配的空间会一直存在，直到该函数运行完毕，数组的空间才会被释放。 数组的长度不能在函数运行的过程中动态的扩充和缩小。]]></content>
  </entry>
</search>
