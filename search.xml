<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[事件]]></title>
      <url>/Blog/2019/08/23/%E4%BA%8B%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>先占位</p>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[js基础知识]]></title>
      <url>/Blog/2019/08/22/js%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<p>学习是没有捷径的，所谓的捷径都会让你永远达不到巅峰；</p>
<blockquote>
<ol>
<li>每天的学习坚持做笔记（IT人记笔记和技术文档都用markdown）</li>
<li>经常复习：每周抽出两三天，每天抽出一到两个小时，把自己整理的学习笔记从头到尾过一遍</li>
</ol>
</blockquote>
<a id="more"></a>
<h2 id="常用的渲染内核（渲染引擎）："><a href="#常用的渲染内核（渲染引擎）：" class="headerlink" title="常用的渲染内核（渲染引擎）："></a>常用的渲染内核（渲染引擎）：</h2><ul>
<li>webkit内核(V8引擎)<ul>
<li>谷歌（必须安装）</li>
<li>Safari</li>
<li>大部分国产浏览器(360/UC/QQ浏览器…)</li>
<li>安卓和IOS手机上的大部分浏览器（移动端开发无需考虑IE低版本）</li>
<li>node（NODE是基于V8引擎渲染JS的平台或者环境）</li>
<li>web view</li>
<li>…</li>
</ul>
</li>
<li>Gecko内核<ul>
<li>火狐浏览器</li>
</ul>
</li>
<li>Trident内核<ul>
<li>IE</li>
</ul>
</li>
<li>Presto内核<ul>
<li>Opera（低版本使用的是这个内核，高版本用的也是webkit内核）</li>
</ul>
</li>
<li>…</li>
</ul>
<h2 id="JS由三部分组成："><a href="#JS由三部分组成：" class="headerlink" title="JS由三部分组成："></a>JS由三部分组成：</h2><ul>
<li>ECMAScript(ES)：JS的基础语法与核心规范</li>
<li>DOM：document object model 文档对象模型，让JS能够操作页面中的DOM元素（HTML元素）</li>
<li>BOM：browser object model 浏览器对象模型，让JS能够操作浏览器的</li>
</ul>
<h2 id="JS中定义变量的方式："><a href="#JS中定义变量的方式：" class="headerlink" title="JS中定义变量的方式："></a>JS中定义变量的方式：</h2><p> 不管变量存储的值是什么类型的，统一用以下关键词都可以创建</p>
<blockquote>
<ul>
<li>var 创建变量</li>
<li>function 创建一个函数</li>
<li>let (这个及以下是ES6语法中创建变量)  创建变量</li>
<li>const  创建常量</li>
<li>class  创建类</li>
<li>import ES6中的模块导入</li>
</ul>
</blockquote>
<h2 id="JS中的命名规范："><a href="#JS中的命名规范：" class="headerlink" title="JS中的命名规范："></a>JS中的命名规范：</h2><blockquote>
<ul>
<li>严格区分大小写：Test / test 是两个不同的变量</li>
<li>不能使用关键字和保留字</li>
<li>遵循驼峰命名法：一个名字由多个英文单词组成，第一个单词首字母小写，其余每一个有意义单词的首字母都要大写<ul>
<li>命名使用：$/数字/字母/_  数字不能作为名字的开始</li>
<li>建议命名的时候使用英文，而且用一些常用词组</li>
<li>…</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _flag = <span class="literal">true</span>; <span class="comment">//=&gt;下划线开头一般代表是全局变量（公用变量）</span></span><br><span class="line"><span class="keyword">var</span> $flag; <span class="comment">//=&gt;一般都代表基于JQ获取的信息（和类库框架有关系）</span></span><br></pre></td></tr></table></figure>
<h2 id="JS中的数据类型"><a href="#JS中的数据类型" class="headerlink" title="JS中的数据类型"></a>JS中的数据类型</h2><p><strong>【基本数据类型（值类型）】</strong><br>   数字 number<br>   字符串 string<br>   布尔 boolean<br>   空 null<br>   未定义 undefined</p>
<p><strong>【引用数据类型】</strong><br>   对象数据类型<br>      普通对象<br>      数组对象<br>      正则对象<br>      日期对象<br>      …<br>   函数数据类型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> =&gt;number</span><br><span class="line"><span class="string">'1'</span>  =&gt;string 在JS中用单引号或者双引号包裹起来的都是字符串</span><br><span class="line"><span class="literal">true</span> / <span class="function"><span class="params">false</span>  =&gt;</span>boolean 只有<span class="literal">true</span>和<span class="literal">false</span>两个值</span><br><span class="line"><span class="literal">null</span></span><br><span class="line">undeifned</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  name:<span class="string">'珠峰'</span>,</span><br><span class="line">  age:<span class="number">9</span></span><br><span class="line">&#125; =&gt;普通对象</span><br><span class="line"></span><br><span class="line">[<span class="number">12</span>,<span class="number">23</span>,<span class="number">34</span>]  =&gt;数组对象</span><br><span class="line"></span><br><span class="line">/^-?(\d|([<span class="number">1</span><span class="number">-9</span>]\d+))(\.\d+)?$/ =&gt;正则对象</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125; =&gt;函数数据类型</span><br></pre></td></tr></table></figure>
<h3 id="JS中检测数据类型的方式"><a href="#JS中检测数据类型的方式" class="headerlink" title="JS中检测数据类型的方式"></a>JS中检测数据类型的方式</h3><ul>
<li>typeof 用来检测数据类型的运算符（常用）。</li>
<li>instanceof 检测当前实例是否隶属于某个类。</li>
<li>constructor 基于构造器，查找当前实例的构造函数。</li>
<li>Object.prototype.toString.call 调用基类Object原型上的toString方法，当方法执行的时候，让方法中的this变为要检测的值，返回当前值对应的类的信息。</li>
<li>({}).toString.call(xx) 打印出效果和上面的 Object.prototype.toString.call 一样。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">语法：<span class="keyword">typeof</span> [value]</span><br><span class="line">返回值：返回的结果首先是一个字符串，其次字符串中包含了对应的数据类型，例如：<span class="string">"number"</span>/<span class="string">"string"</span>/<span class="string">"boolean"</span>/<span class="string">"undefined"</span>/<span class="string">"object"</span>/<span class="string">"function"</span></span><br><span class="line"></span><br><span class="line">【特殊】</span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> =&gt;<span class="string">"object"</span> 虽然<span class="literal">null</span>是基本值，但是它的意思叫做“空对象指针”，所以检测的结果是对象（可以理解为<span class="keyword">typeof</span>的BUG）</span><br><span class="line"></span><br><span class="line">基于<span class="keyword">typeof</span>检测对象或者数组对象再或者正则对象，返回的结果都是“object”，也就是无法基于<span class="keyword">typeof</span>判断当前对象是数组还是正则...（可以理解为<span class="keyword">typeof</span>的局限性）</span><br><span class="line"></span><br><span class="line">【面试题】</span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">typeof</span> <span class="keyword">typeof</span> []</span><br><span class="line"></span><br><span class="line">-&gt; <span class="keyword">typeof</span> []  : <span class="string">"object"</span></span><br><span class="line">-&gt; <span class="keyword">typeof</span> <span class="string">"object"</span> : <span class="string">"string"</span></span><br><span class="line">-&gt; <span class="keyword">typeof</span> <span class="string">"string"</span> : <span class="string">"string"</span></span><br><span class="line"></span><br><span class="line">考察点：检测的结果首先是一个字符串</span><br></pre></td></tr></table></figure>
<h3 id="【数字类型-number】"><a href="#【数字类型-number】" class="headerlink" title="【数字类型 number】"></a>【数字类型 number】</h3><blockquote>
<p>除了常规数字，在JS中 NaN 也是number类型的</p>
</blockquote>
<ol>
<li>NaN：not a number 不是一个有效数字</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span> =&gt;<span class="string">"number"</span></span><br><span class="line"></span><br><span class="line"><span class="literal">NaN</span>==<span class="function"><span class="params">NaN</span> =&gt;</span><span class="literal">false</span>  <span class="literal">NaN</span>和任何值都不相等，和本身也不相等（不是一个数包含范围太广了）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--</span><br><span class="line"></span><br><span class="line">我想知道num存储的值是否为有效数字,下面的代码实现不了，因为<span class="literal">NaN</span>和谁都不相等</span><br><span class="line"><span class="keyword">var</span> num = ?;</span><br><span class="line"><span class="keyword">if</span>(num==<span class="literal">NaN</span>)&#123;</span><br><span class="line">    <span class="comment">//=&gt;如果条件成立，则num存储的值不是有效数字（可惜这个条件永远都不会成立，不管num是啥）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>如何检测一个值是否为有效数字?<br>=&gt; isNaN：检测一个值是否不是有效数字，返回TRUE代表不是有效数字，FALSE代表是有效数字</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">语法：<span class="built_in">isNaN</span>([value])</span><br><span class="line"></span><br><span class="line">运作机制：当使用<span class="built_in">isNaN</span>用来检测一个值是否为有效数字的时候，如果被检测的值不是数字类型，浏览器首先会把它转换为数字类型，然后再进行检测。</span><br><span class="line"></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">'3'</span>) =&gt;<span class="literal">false</span></span><br><span class="line">  <span class="built_in">Number</span>(<span class="string">'3'</span>)-&gt;<span class="number">3</span></span><br><span class="line">  <span class="built_in">isNaN</span>(<span class="number">3</span>)-&gt;<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">'3px'</span>) =&gt;<span class="literal">true</span></span><br><span class="line">  <span class="built_in">Number</span>(<span class="string">'3px'</span>)-&gt;<span class="literal">NaN</span></span><br><span class="line">  <span class="built_in">isNaN</span>(<span class="literal">NaN</span>)-&gt;<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="【布尔-boolean】"><a href="#【布尔-boolean】" class="headerlink" title="【布尔 boolean】"></a>【布尔 boolean】</h3><blockquote>
<p>只有两个值：true / false</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//=&gt;把其它数据类型的值转换为布尔类型：</span></span><br><span class="line"><span class="comment">//=&gt;除了“NaN/0/''/null/undefined”这五个值会转换为FALSE,其余的都会转换为TRUE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt;哪些情况需要把其它类型值转换为布尔呢？</span></span><br><span class="line"><span class="comment">//[手动自己转]</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">0</span>) =&gt;<span class="literal">false</span></span><br><span class="line"><span class="built_in">Boolean</span>([]) =&gt;<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">!<span class="number">0</span> =&gt;<span class="literal">true</span>  叹号在这里是取反的意思（先转化为布尔类型然后再取反）</span><br><span class="line">!!<span class="number">0</span> =&gt;<span class="literal">false</span> 两个叹号只剩下转换为布尔类型了，等价于<span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//[程序自己需要转换 =&gt;一般都是条件判断的时候]</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span>)&#123;</span><br><span class="line">   <span class="comment">//=&gt;如果条件成立，执行大括号中的代码</span></span><br><span class="line">   <span class="comment">//=&gt;浏览器会把1作为条件：把它转换为布尔的TRUE，条件成立</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="【对象数据类型-object】"><a href="#【对象数据类型-object】" class="headerlink" title="【对象数据类型 object】"></a>【对象数据类型 object】</h3><blockquote>
<p>对象都有一个特点：每一个对象都是由零到多组属性名和属性值（键值对 key:value）组成的</p>
<p>所谓的属性，其实可以理解为对象的特征，而属性值就是对特征的描述</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">   name:<span class="string">'婉茹'</span>,</span><br><span class="line">   age:<span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt;操作对象的键值对</span></span><br><span class="line"><span class="number">1.</span> 对象.属性</span><br><span class="line"><span class="number">2.</span> 对象[属性]</span><br><span class="line"><span class="comment">//=&gt;对象的属性名是字符串和数字格式的，属性值可以是任何数据类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt;获取</span></span><br><span class="line">obj.name</span><br><span class="line">obj[<span class="string">'name'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt;增加/修改</span></span><br><span class="line"><span class="comment">//=&gt;一个对象中的属性名是不能重复的，如果当前对象属性已经存在，我们属于修改属性值，不存在才是新增加属性</span></span><br><span class="line">obj[<span class="string">'name'</span>]=<span class="string">'明明'</span>; <span class="comment">//=&gt;修改</span></span><br><span class="line">obj[<span class="string">'sex'</span>]=<span class="string">'女'</span>; <span class="comment">//=&gt;新增</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt;删除</span></span><br><span class="line">[彻底删除：属性和属性值都没有了]</span><br><span class="line"><span class="keyword">delete</span> obj.age / <span class="keyword">delete</span> obj[<span class="string">'age'</span>]</span><br><span class="line"></span><br><span class="line">[假删除：属性还在，只是值为空]</span><br><span class="line">obj[<span class="string">'age'</span>]=<span class="literal">null</span>; <span class="comment">//=&gt;赋值为null的原因：因为对象没有这个属性，默认获取的值是undefiend，假删除只是设置值为空，但是属性还在，我们最好不要设置为undefined，这样会和默认返回的结果冲突，无法区分到底是有没有这个属性</span></span><br></pre></td></tr></table></figure>
<p>属性名可能是字符串，也可能是数字，不能是其它类型值（尤其是引用类型）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">obj[&#123;<span class="attr">xxx</span>:<span class="string">'xxx'</span>&#125;]=<span class="number">100</span>;</span><br><span class="line">=&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">'[object Object]'</span>:<span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt;属性名还可以是数字</span></span><br><span class="line"><span class="keyword">var</span> ary = [<span class="number">12</span>,<span class="number">23</span>,<span class="number">34</span>];</span><br><span class="line">数组对象，我们看到的是属性值，属性名是默认生成的，而且有特点：</span><br><span class="line"><span class="number">1.</span>属性名是数字</span><br><span class="line"><span class="number">2.</span>数字是从零开始逐级递增的</span><br><span class="line"><span class="number">3.</span>有一个字符串属性名length,代表数组的长度</span><br><span class="line"></span><br><span class="line">我们把数组中的数字属性名称之为“数组的索引”</span><br><span class="line"></span><br><span class="line">ary[<span class="number">0</span>] =&gt;<span class="number">12</span></span><br><span class="line">ary<span class="number">.0</span> <span class="comment">//=&gt;Uncaught SyntaxError: Unexpected number 语法错误，如果属性名是数字，我们则不能通过 对象.数字 方式来操作属性</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> key=<span class="string">'name'</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    key:<span class="number">100</span></span><br><span class="line">&#125;;</span><br><span class="line">obj.key -&gt;<span class="number">100</span>  属性名为<span class="string">'KEY'</span></span><br><span class="line">obj[<span class="string">'key'</span>] -&gt;<span class="number">100</span> 属性名为<span class="string">'KEY'</span></span><br><span class="line"></span><br><span class="line">obj[key] =&gt;这样写绝对不是获取属性名为KEY的值，因为此时的KEY不是字符串也不是数字，而是变量；KEY代表的是存储的值<span class="string">'name'</span>，所以此处它的意思是 obj[<span class="string">'name'</span>]</span><br></pre></td></tr></table></figure>
<h3 id="基本类型值（值类型）-VS-引用类型值"><a href="#基本类型值（值类型）-VS-引用类型值" class="headerlink" title="基本类型值（值类型） VS 引用类型值"></a>基本类型值（值类型） VS 引用类型值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> m=n;</span><br><span class="line">m=<span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a=&#123;<span class="attr">name</span>:<span class="string">'珠峰'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> b=a;</span><br><span class="line">b.name=<span class="string">'培训'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a.name);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n=[<span class="number">12</span>,<span class="number">23</span>,<span class="number">34</span>];</span><br><span class="line"><span class="keyword">var</span> m=n;</span><br><span class="line">m[<span class="number">0</span>]=<span class="number">100</span>;</span><br><span class="line">m=[<span class="number">100</span>];</span><br><span class="line">n[<span class="number">1</span>]=<span class="number">200</span>;</span><br><span class="line"><span class="built_in">console</span>.log(n,m);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    n:<span class="number">10</span>,</span><br><span class="line">    m:obj.n*<span class="number">10</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.m);</span><br></pre></td></tr></table></figure>
<p>值类型操作都是“按照值来操作的”</p>
<blockquote>
<ul>
<li>赋值的时候，也是直接的把这个值赋值给变量（或者说和变量关联）</li>
<li>一个变量把自己的值赋值给另外一个变量的时候，也是重新开辟一个新的位置，把原有变量存储的值放到新位置一份（新老位置各有相同的值，但是是独立分开的，没有关联），在把新位置上的值赋值给新变量</li>
<li>…</li>
</ul>
</blockquote>
<p> 引用数据类型，操作的时候，都是按照“空间的引用地址来操作的”</p>
<blockquote>
<ol>
<li>首先不能像基本基本值一样在作用域中开辟位置存储，需要额外单独开辟一个新的空间（有一个16进制的地址，通过地址可以找到空间）</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>对于对象数据类型来说，它会把自己本身的键值对依次存储到这个空间中（对于函数来说，在空间中存储的是函数体中的代码字符串）</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>引用类型是按照引用地址来操作的，所以给变量赋的值是空间的地址，而不是对象本身，以后的操作都是通过地址找到空间然后再操作</li>
</ol>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【堆占内存】</span><br><span class="line">在JS中有两个重要的内存：堆内存/栈内存</span><br><span class="line"></span><br><span class="line">- 栈内存</span><br><span class="line">  + 提供代码执行的环境</span><br><span class="line">  + 基本类型值都是直接的存储在栈内存中的</span><br><span class="line">- 堆内存</span><br><span class="line">  + 引用类型值都存储在堆内存中</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">函数的运作机制：</span><br><span class="line"></span><br><span class="line">【创建函数】</span><br><span class="line"><span class="number">1.</span> 函数也是引用类型值，首先开辟一个新的堆内存（<span class="number">16</span>进制地址）</span><br><span class="line"><span class="number">2.</span> 把函数体中实现功能的代码“当做字符串”存储到堆内存中</span><br><span class="line"><span class="number">3.</span> 把堆内存的引用地址赋值给函数名（变量名）</span><br><span class="line"></span><br><span class="line">【执行函数】</span><br><span class="line">目的：把函数体中的JS代码执行，以此实现具体的功能和需求</span><br><span class="line"><span class="number">1.</span> 首先开辟一个新的栈内存（私有作用域），提供JS代码执行赖以生存的环境</span><br><span class="line"><span class="number">2.</span> 把原有在堆内存中存储的“字符串”，拿过来，放到新的栈内存中，变为真正的JS代码，自上而下执行</span><br></pre></td></tr></table></figure>
<h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><h3 id="把其它数据类型值转换为数字类型"><a href="#把其它数据类型值转换为数字类型" class="headerlink" title="把其它数据类型值转换为数字类型"></a>把其它数据类型值转换为数字类型</h3><blockquote>
<p>[把其它基本类型值转换为数字 =&gt; Number([value])]</p>
</blockquote>
<ul>
<li>基于parseInt/parseFloat/Number去手动转换为数字类型</li>
<li>数学运算：+ - * / %，但是“+”不仅仅是数学运算，还可能是字符串拼接</li>
<li>在基于“==”比较的时候，有时候也会把其它值转换为数字类型</li>
<li>…</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'3'</span><span class="number">-1</span> =&gt;<span class="number">2</span></span><br><span class="line">  <span class="built_in">Number</span>(<span class="string">'3'</span>)-&gt;<span class="number">3</span></span><br><span class="line">  <span class="number">3</span><span class="number">-1</span>-&gt;<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="string">'3px'</span><span class="number">-1</span> =&gt;<span class="literal">NaN</span></span><br><span class="line"></span><br><span class="line"><span class="string">'3px'</span>+<span class="number">1</span> =&gt;<span class="string">'3px1'</span> 字符串拼接</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i=<span class="string">'3'</span>;</span><br><span class="line">i=i+<span class="number">1</span>; =&gt;<span class="string">'31'</span></span><br><span class="line">i+=<span class="number">1</span>; =&gt;<span class="string">'31'</span></span><br><span class="line">i++; =&gt;<span class="number">4</span>  i++就是单纯的数学运算，已经摒弃掉字符串拼接的规则</span><br></pre></td></tr></table></figure>
<h4 id="字符串-gt-数字"><a href="#字符串-gt-数字" class="headerlink" title="字符串-&gt;数字"></a>字符串-&gt;数字</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">'1'</span>) : <span class="number">1</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'-1.3'</span>) : <span class="number">-1.3</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'1px'</span>) : <span class="literal">NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">''</span>) -&gt;<span class="number">0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">' '</span>) -&gt;<span class="number">0</span> 空格(Space)</span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'\n'</span>) -&gt;<span class="number">0</span> 换行符(Enter)</span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'\t'</span>) -&gt;<span class="number">0</span> 制表符(Tab)</span><br><span class="line">如果字符串中出现任意一个非有效数字字符，则转换为数字的<span class="literal">NaN</span></span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`    </span></span><br><span class="line"><span class="string">#### 布尔-&gt;数字</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> JavaScript</span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">true</span>) : <span class="number">1</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">false</span>) : <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h4 id="空-gt-数字"><a href="#空-gt-数字" class="headerlink" title="空-&gt;数字"></a>空-&gt;数字</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>) : <span class="number">0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">undefined</span>) : <span class="literal">NaN</span></span><br></pre></td></tr></table></figure>
<h4 id="把引用数据类型转换为数字"><a href="#把引用数据类型转换为数字" class="headerlink" title="把引用数据类型转换为数字"></a>把引用数据类型转换为数字</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> =&gt;首先toString()把引用值转换为字符串</span><br><span class="line">   =&gt;其次调取<span class="built_in">Number</span>()把字符串转换为数字</span><br><span class="line">]</span><br><span class="line">  <span class="built_in">isNaN</span>(&#123;<span class="attr">name</span>:<span class="string">'xxx'</span>&#125;)</span><br><span class="line">   -&gt;(&#123;<span class="attr">name</span>:<span class="string">'xxx'</span>&#125;).toString() : <span class="string">"[object Object]"</span>  所有普通都对象转换为字符串，结果都是它(客户扩展为啥？)</span><br><span class="line">   -&gt;<span class="built_in">Number</span>(<span class="string">"[object Object]"</span>) : <span class="literal">NaN</span></span><br><span class="line">    </span><br><span class="line">  <span class="built_in">isNaN</span>([<span class="number">12</span>,<span class="number">23</span>])</span><br><span class="line">   -&gt;[<span class="number">12</span>,<span class="number">23</span>].toString() : <span class="string">'12,23'</span></span><br><span class="line">   -&gt;<span class="built_in">Number</span>(<span class="string">'12,23'</span>) : <span class="literal">NaN</span></span><br><span class="line">    </span><br><span class="line">  <span class="built_in">isNaN</span>([])</span><br><span class="line">   -&gt;[].toString() : <span class="string">''</span></span><br><span class="line">   -&gt;<span class="built_in">Number</span>(<span class="string">''</span>) : <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">  <span class="built_in">isNaN</span>([<span class="number">12</span>])</span><br><span class="line">   -&gt;[<span class="number">12</span>].toString() : <span class="string">'12'</span></span><br><span class="line">   -&gt;<span class="built_in">Number</span>(<span class="string">'12'</span>) : <span class="number">12</span></span><br><span class="line">    </span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<h4 id="parseInt-parseFloat"><a href="#parseInt-parseFloat" class="headerlink" title="parseInt / parseFloat"></a>parseInt / parseFloat</h4><blockquote>
<p>1.Number把字符串转化数字，遇到一个非有效数字字符，结果就是NaN了，我们想要提取出字符串中有效数字的部分，需要使用 parseInt / parseFloat 两个方法</p>
</blockquote>
<blockquote>
<p>2.和Number的区别在于字符串转换分析上</p>
<p>3.Number：出现任意非有效数字字符，结果就是NaN</p>
<p>4.parseInt：把一个字符串中的整数部分解析出来，parseFloat是把一个字符串中小数(浮点数)部分解析出来</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">'1px'</span>) : <span class="literal">NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1px'</span>) : <span class="number">1</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1.5px'</span>) : <span class="number">1</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'1.5px'</span>) : <span class="number">1.5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'width:1px'</span>) : <span class="function"><span class="params">NaN</span>  =&gt;</span>从字符串最左边开始找，遇到一个非有效数字字符后就停止查找了（不管后面是否存在有效数字），把找到的变为数字，一个都没找到结果就是<span class="literal">NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1px3'</span>) : <span class="number">1</span></span><br><span class="line"></span><br><span class="line">思考题：</span><br><span class="line"><span class="built_in">parseInt</span>支持两个参数（<span class="built_in">parseInt</span>(<span class="string">'10px'</span>,<span class="number">2</span>)），这个是啥意思?</span><br></pre></td></tr></table></figure>
<h3 id="把其它类型值转换为字符串"><a href="#把其它类型值转换为字符串" class="headerlink" title="把其它类型值转换为字符串"></a>把其它类型值转换为字符串</h3><p><code>1.发生的情况</code></p>
<ul>
<li>基于alert/confirm/prompt/document.write等方法输出内容的时候，会把输出的值转换为字符串，然后再输出。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="number">1</span>) =&gt;<span class="string">'1'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>基于“+”进行字符串拼接的时候</li>
<li>把引用类型值转换为数字的时候，首先会转换为字符串，然后再转换为数字</li>
<li>给对象设置属性名，如果不是字符串，首先转换为字符串，然后再当做属性存储到对象中（对象的属性只能是数字或者字符串）</li>
<li>手动调用toString/toFixed/join/String等方法的时候，也是为了转换为字符串</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n=<span class="built_in">Math</span>.PI;<span class="comment">//=&gt;获取圆周率：</span></span><br><span class="line">n.toFixed(<span class="number">2</span>) =&gt;<span class="string">'3.14'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ary=[<span class="number">12</span>,<span class="number">23</span>,<span class="number">34</span>];</span><br><span class="line">ary.join(<span class="string">'+'</span>) =&gt;<span class="string">'12+23+34'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>…</li>
</ul>
<p><code>2.转换规律</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//=&gt;调用的方法：toString</span></span><br><span class="line"></span><br><span class="line">【除了对象，都是你理解的转换结果】</span><br><span class="line"><span class="number">1</span> -&gt;<span class="string">'1'</span></span><br><span class="line"><span class="literal">NaN</span> -&gt;<span class="string">'NaN'</span></span><br><span class="line"><span class="literal">null</span> -&gt;<span class="string">'null'</span></span><br><span class="line">[] -&gt;<span class="string">''</span></span><br><span class="line">[<span class="number">13</span>] -&gt;<span class="string">'13'</span></span><br><span class="line">[<span class="number">12</span>,<span class="number">23</span>] -&gt;<span class="string">'12,23'</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">【对象】</span><br><span class="line">&#123;<span class="attr">name</span>:<span class="string">'xxx'</span>&#125; -&gt;<span class="string">'[object Object]'</span></span><br><span class="line">&#123;&#125; -&gt;<span class="string">'[object Object]'</span></span><br><span class="line">不管是啥样的普通对象，最后结果都一样</span><br></pre></td></tr></table></figure>
<h3 id="把其它值转换为布尔类型"><a href="#把其它值转换为布尔类型" class="headerlink" title="把其它值转换为布尔类型"></a>把其它值转换为布尔类型</h3><p><code>1.发生的情况</code></p>
<ul>
<li>基于!/!!/Boolean等方法转换</li>
<li>条件判断中的条件最后都会转换为布尔类型</li>
<li>…</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(n)&#123;</span><br><span class="line">  <span class="comment">//=&gt;把n的值转换为布尔验证条件真假</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="string">'3px'</span>+<span class="number">3</span>)&#123;</span><br><span class="line">  <span class="comment">//=&gt;先计算表达式的结果'3px3'，把结果转换为布尔true，条件成立</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>2.转换的规律</code><br>只有<code>“0/NaN/&#39;&#39;/null/undefined”</code>五个值转换为布尔的false,其余都是转换为true。</p>
<p>!0 =&gt;true  叹号在这里是取反的意思（先转化为布尔类型然后再取反）</p>
<p>!!0 =&gt;false 两个叹号只剩下转换为布尔类型了，等价于Boolean</p>
<h3 id="特殊情况：数学运算和字符串拼接-“-”"><a href="#特殊情况：数学运算和字符串拼接-“-”" class="headerlink" title="特殊情况：数学运算和字符串拼接 “+”"></a>特殊情况：数学运算和字符串拼接 “+”</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//=&gt;当表达式中出现字符串，就是字符串拼接，否则就是数学运算</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>+<span class="function"><span class="params">true</span> =&gt;</span><span class="number">2</span> 数学运算</span><br><span class="line"><span class="string">'1'</span>+<span class="function"><span class="params">true</span> =&gt;</span><span class="string">'1true'</span> 字符串拼接</span><br><span class="line"></span><br><span class="line">[<span class="number">12</span>]+<span class="number">10</span> =&gt;<span class="string">'1210'</span> 虽然现在没看见字符串，但是引用类型转换为数字，首先会转换为字符串，所以变为了字符串拼接</span><br><span class="line">(&#123;&#125;)+<span class="number">10</span> =&gt;<span class="string">"[object Object]10"</span></span><br><span class="line">[]+<span class="number">10</span> =&gt;<span class="string">"10"</span></span><br><span class="line"></span><br><span class="line">&#123;&#125;+<span class="number">10</span> =&gt;<span class="number">10</span> 这个和以上说的没有半毛钱关系，因为它根本就不是数学运算，也不是字符串拼接，它是两部分代码</span><br><span class="line">  &#123;&#125; 代表一个代码块（块级作用域）</span><br><span class="line">  +<span class="number">10</span> 才是我们的操作</span><br><span class="line">  严格写法：&#123;&#125;; +<span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p><strong>实例：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span>+<span class="literal">true</span>+<span class="literal">false</span>+<span class="literal">null</span>+<span class="literal">undefined</span>+[]+<span class="string">'珠峰'</span>+<span class="literal">null</span>+<span class="literal">undefined</span>+[]+<span class="literal">true</span></span><br><span class="line">=&gt;<span class="string">'NaN珠峰nullundefinedtrue'</span></span><br><span class="line"></span><br><span class="line"><span class="number">12</span>+<span class="literal">true</span> -&gt;<span class="number">13</span></span><br><span class="line"><span class="number">13</span>+<span class="literal">false</span> -&gt;<span class="number">13</span></span><br><span class="line"><span class="number">13</span>+<span class="literal">null</span> -&gt;<span class="number">13</span></span><br><span class="line"><span class="number">13</span>+<span class="literal">undefined</span> -&gt;<span class="literal">NaN</span></span><br><span class="line"><span class="literal">NaN</span>+[] -&gt;<span class="string">'NaN'</span></span><br><span class="line"><span class="string">'NaN'</span>+<span class="string">'珠峰'</span> -&gt;<span class="string">'NaN珠峰'</span></span><br><span class="line">...</span><br><span class="line"><span class="string">'NaN珠峰trueundefined'</span></span><br><span class="line"><span class="string">'NaN珠峰trueundefined'</span>+[] -&gt;<span class="string">'NaN珠峰trueundefined'</span></span><br><span class="line">...</span><br><span class="line">=&gt;<span class="string">'NaN珠峰trueundefinedtrue'</span></span><br></pre></td></tr></table></figure>
<h3 id="特殊情况：“-”在进行比较的时候，如果左右两边的数据类型不一样，则先转换为相同的类型，再进行比较"><a href="#特殊情况：“-”在进行比较的时候，如果左右两边的数据类型不一样，则先转换为相同的类型，再进行比较" class="headerlink" title="特殊情况：“==”在进行比较的时候，如果左右两边的数据类型不一样，则先转换为相同的类型，再进行比较"></a>特殊情况：“==”在进行比较的时候，如果左右两边的数据类型不一样，则先转换为相同的类型，再进行比较</h3><p>对象==对象：不一定相等，因为对象操作的是引用地址，地址不相同则不相等</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">name</span>:<span class="string">'xxx'</span>&#125;==&#123;<span class="attr">name</span>:<span class="string">'xxx'</span>&#125; =&gt;<span class="literal">false</span></span><br><span class="line">[]==[] =&gt;<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1=&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2=obj1;</span><br><span class="line">obj1==<span class="function"><span class="params">obj2</span> =&gt;</span><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><strong>比较规律：</strong></p>
<p><strong>不同情况的比较，都是把其它值转换为数字，然后再进行比较的。</strong></p>
<pre><code>对象==数字：把对象转换为数字
对象==布尔：把对象转换为数字，把布尔也转换为数字
对象==字符串：把对象转换为数字，把字符串也转换为数字
字符串==数字：字符串转换为数字
字符串==布尔：都转换为数字
布尔==数字：把布尔转换为数字
</code></pre><p><strong>需要特殊记忆的特殊情况：</strong></p>
<pre><code>null==undefined：true
null===undefined：false
null&amp;&amp;undefined和其它值都不相等

NaN==NaN：false
NaN和谁都不相等包括自己
</code></pre><p><strong>案例：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>==<span class="function"><span class="params">true</span> =&gt;</span><span class="literal">true</span></span><br><span class="line"><span class="number">1</span>==<span class="function"><span class="params">false</span> =&gt;</span><span class="literal">false</span></span><br><span class="line"><span class="number">2</span>==<span class="function"><span class="params">true</span> =&gt;</span><span class="literal">false</span>  规律不要混淆，这里是把<span class="literal">true</span>变为数字<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[]==<span class="literal">true</span>：<span class="literal">false</span>  都转换为数字 <span class="number">0</span>==<span class="number">1</span></span><br><span class="line">![]==<span class="literal">true</span>：<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">[]==<span class="literal">false</span>：<span class="literal">true</span>  都转换为数字 <span class="number">0</span>==<span class="number">0</span></span><br><span class="line">![]==<span class="literal">false</span>：<span class="literal">true</span>  先算![]，把数组转换为布尔取反=&gt;<span class="function"><span class="params">false</span>  =&gt;</span><span class="literal">false</span>==<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h2 id="switch-case"><a href="#switch-case" class="headerlink" title="switch case"></a>switch case</h2><blockquote>
<p>JS中的一种判断方式</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">if</span>(num==<span class="number">10</span>)&#123;</span><br><span class="line">	num++;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(num==<span class="number">5</span>)&#123;</span><br><span class="line">	num--;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	num=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt;改成switch case</span></span><br><span class="line"><span class="keyword">switch</span>(num)&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">		num++;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">		num--;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		num=<span class="number">0</span>;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt;switch case 应用于变量（或者表达式等）在不同值情况下的不同操作，每一种case结束后都要加break（结束整个判断）</span></span><br></pre></td></tr></table></figure>
<p>switch case中每一种case情况的比较都是基于”===”绝对相等来完成的</p>
<h3 id="绝对比较"><a href="#绝对比较" class="headerlink" title="=== 绝对比较"></a>=== 绝对比较</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'10'</span>==<span class="number">10</span> </span><br><span class="line">=&gt;<span class="literal">true</span> 相等比较,如果等号左右两边的类型不一样，首先会转换为一样的数据类型，然后再进行比较</span><br><span class="line">=&gt;当前案例中，就是把字符串<span class="string">'10'</span>转换为数字了，然后再比较的</span><br><span class="line"></span><br><span class="line"><span class="string">'10'</span>===<span class="number">10</span> 绝对比较，如果两边的数据类型不一样，则直接不相等，它要求类型和值都完全一样才会相等（真实项目中为了保证代码的严谨性，我们应该更多使用绝对比较）</span><br></pre></td></tr></table></figure>
<h2 id="FOR-IN循环"><a href="#FOR-IN循环" class="headerlink" title="FOR-IN循环"></a>FOR-IN循环</h2><ul>
<li><p>遍历一个对象中的键值对的，有多少组键值对，我们就遍历多少次。也支持BREAK和CONTINUE等关键词。</p>
</li>
<li><p>FOR-IN遍历的时候有自己的顺序：先遍历数字属性名（按照小-&gt;大），再遍历字符串属性名（按照书写顺序）。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>: <span class="string">'xxx'</span>, <span class="attr">age</span>: <span class="number">27</span>, <span class="number">0</span>: <span class="number">0</span>, <span class="attr">sex</span>: <span class="number">0</span>, <span class="attr">score</span>: <span class="number">100</span>, <span class="number">1</span>: <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> attr <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(attr);<span class="comment">//=&gt;0 1 name age sex score</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*//=&gt;obj.__proto__===Object.prototype : obj是Object这个类的一个实例</span></span><br><span class="line"><span class="comment">//=&gt;大括号中的是OBJ的私有属性，Object.prototype上的是OBJ公有属性</span></span><br><span class="line"><span class="comment">Object.prototype.bbbb = 1000;</span></span><br><span class="line"><span class="comment">for (let key in obj) &#123;</span></span><br><span class="line"><span class="comment">    //=&gt;FOR-IN循环只遍历当前对象可枚举（可遍历）的属性</span></span><br><span class="line"><span class="comment">    //1.对象的私有属性(自己写的)是可枚举的</span></span><br><span class="line"><span class="comment">    //2.浏览器内置的属性一般都是不可枚举的</span></span><br><span class="line"><span class="comment">    //3.自己在类的原型上设置的属性也是可枚举的,FOR-IN循环的时候也会被遍历出来（一般情况下我们是不想遍历到原型上的公有属性的）</span></span><br><span class="line"><span class="comment">    if (obj.hasOwnProperty(key)) &#123;//=&gt;一般使用FOR-IN在遍历对象的时候，我们加一个私有属性的验证，只有是私有的属性，我们才做操作</span></span><br><span class="line"><span class="comment">        console.log(key);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h2><p> 把多维数组变为一维数组。</p>
<h2 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p><strong><code>重载</code></strong>：方法名相同，参数的个数或者类型不同，此时名字相同的方法叫做方法的重载（后台语言中的重载），JS中不存在重载的。<br><strong><code>重写</code></strong>：子类重写父类的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//=&gt;根据传递参数的不同执行不同的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn</span><span class="params">(string n,string m)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//iOS里面多态也是重载父类方法。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 但是JS中不能重载，只会覆盖</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">n, m</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">n, m, x</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//=&gt;后面的方法会把前面的方法覆盖掉，不管传递多少实参，执行的都是后面的这个方法（JS中的重载指的是：同一个方法根据传参不一样，实现不同的功能）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>子类继承父类的属性和方法</p>
<ul>
<li><ol>
<li>原型继承</li>
</ol>
</li>
<li><ol start="2">
<li>call继承</li>
</ol>
</li>
<li><ol start="3">
<li>寄生组合继承</li>
</ol>
</li>
<li><ol start="4">
<li>ES6中class类实现继承</li>
</ol>
</li>
</ul>
<h4 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h4><p><code>定义</code>：让子类的原型指向父类的一个实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: A,</span><br><span class="line">    getX: function () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.y = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line">B.prototype = <span class="keyword">new</span> A();</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> B();</span><br></pre></td></tr></table></figure>
<p><strong><code>原理和缺点</code></strong></p>
<p>A的实例本来就具有父类A的私有属性和prototype上的共有方法，子类B的原型指向它，B的实例就可以访问这些属性和方法了。</p>
<p>JS子类继承父类，并不是把父类的属性方法完全克隆一份给子类的（这样子类和父类就是完全独立的两部分）。JS中的原型继承是让子类和父类建立原型链接的机制，子类的实例调取父类上的方法都是基于原型查找机制完成的。</p>
<p><code>存在问题：子类可以重写父类原型上的方法，子类和父类不够独立。</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B.prototype.__proto__.getX = <span class="literal">null</span>; <span class="comment">// 这样A的实例也会受到影响。</span></span><br></pre></td></tr></table></figure>
<p><img src="evernotecid://02E440F6-0665-4256-A013-1E829A2F4F57/appyinxiangcom/11951979/ENResource/p115" alt="942e6467333d0ddd4a4f72cc55a070ff.png"></p>
<h4 id="call继承"><a href="#call继承" class="headerlink" title="call继承"></a>call继承</h4><p><code>CALL继承：</code> 把父类A做为普通函数执行，让A中的THIS变为B的实例，相当于给B的实例增加一些属性和方法（<code>弊端：把父类A当做普通函数执行，和父类原型没啥关系了，仅仅是把A中的私有属性变为子类B实例的私有属性而已，A原型上的公有属性方法和B及它的实例没啥关系</code>）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//new A() 把A作为类创建它的实例 this:实例</span></span><br><span class="line"><span class="comment">//A() 把A作为普通函数执行 this:window</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//=&gt;this:f</span></span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">100</span>; <span class="comment">//=&gt;f.x=100</span></span><br><span class="line">&#125;</span><br><span class="line">A.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: A,</span><br><span class="line">    getX: function () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//=&gt;this:f</span></span><br><span class="line">    A.call(<span class="keyword">this</span>);<span class="comment">//=&gt;call继承  把A执行，让A中的this变为f</span></span><br><span class="line">    <span class="keyword">this</span>.y = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> B();</span><br></pre></td></tr></table></figure>
<h4 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Object.create：内置Object类天生自带的方法</span></span><br><span class="line"><span class="comment"> *   1.创建一个空对象</span></span><br><span class="line"><span class="comment"> *   2.让新创建的空对象的__proto__指向第一个传递进来的对象（把OBJ作为新创建空对象的原型）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: A,</span><br><span class="line">    getX: function () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    A.call(<span class="keyword">this</span>);<span class="comment">//=&gt;基于CALL把A的私有变为B的私有  f.x=100</span></span><br><span class="line">    <span class="keyword">this</span>.y = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// B.prototype = A.prototype; //=&gt;一般都不这样处理，因为这种模式可以轻易修改父类A原型上的东西（重写“太方便”了），这样会导致A的其它实例也受到影响</span></span><br><span class="line">B.prototype=<span class="built_in">Object</span>.create(A.prototype);</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> B();</span><br></pre></td></tr></table></figure>
<p><img src="evernotecid://02E440F6-0665-4256-A013-1E829A2F4F57/appyinxiangcom/11951979/ENResource/p117" alt="7a9aff263e13c7d45a593a973c8dcb74.png"></p>
<h4 id="ES6中的类和继承"><a href="#ES6中的类和继承" class="headerlink" title="ES6中的类和继承"></a>ES6中的类和继承</h4><p>ES6中创建类是有自己标准语法的（<code>这种语法创建出来的类只能NEW执行，不能当做普通函数执行</code>）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给A的原型上设置方法，写在这里（只能设置方法不能设置属性）</span></span><br><span class="line">    getX() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//=&gt;把AA当做一个普通对象设置的私有方法（和实例没有关系），同样也只能设置方法不能写属性</span></span><br><span class="line">    <span class="keyword">static</span> AA()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 想要添加属性还是得以这样的方式</span></span><br><span class="line">A.prototype.BB = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;<span class="comment">//=&gt;extends类似于实现了原型继承</span></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>();<span class="comment">//=&gt;类似于CALL继承：在这里SUPER相当于把A的CONSTRUCTOR给执行了，并且让方法中的THIS是B的实例，SUPER当中传递的实参都是在给A的CONSTRUCTOR传递</span></span><br><span class="line">        <span class="keyword">this</span>.y = <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getY() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> B();</span><br></pre></td></tr></table></figure>
<h3 id="图片延迟加载"><a href="#图片延迟加载" class="headerlink" title="图片延迟加载"></a>图片延迟加载</h3><h3 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h3>]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CALayer position 和 anchorPoint 的问题]]></title>
      <url>/Blog/2017/08/29/CALayer%20position%20%E5%92%8C%20anchorPoint%20%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h2 id="概要："><a href="#概要：" class="headerlink" title="概要："></a>概要：</h2><blockquote>
<p><code>CALayer</code> 的<code>position</code>白话来讲：<code>position</code>就是layer 自身的<code>anchorPoint</code>相对于父<code>superLayer</code>的坐标位置。<br>常规说来，在iOS上，一个图层的position位于父图层的左上角<br>具体概念参考：<a href="http://kittenyang.com/anchorpoint/" target="_blank" rel="noopener">这将是你最后一次纠结position与anchorPoint</a></p>
</blockquote>
<a id="more"></a>
<p>关于画曲线的角度参考图：<br><img src="http://upload-images.jianshu.io/upload_images/120336-7f77dcb0cc28e0ef.png?imageMogr2/auto-orient/strip%7CimageView2/2" alt></p>
<h3 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h3><p>需求是一个扫描匹配的动画：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/972822-840319654c340d62.gif?imageMogr2/auto-orient/strip" alt="hhhh.gif"><br>如上展示的是最终的效果。这里主要用的是一个自定义view <code>PulsingView</code>，重写 <code>(void)drawRect:(CGRect)rect</code>方法，在这个方法内部去画相应的元素，主要包含：</p>
<ul>
<li><h6 id="1-外部扩散的脉冲layer。"><a href="#1-外部扩散的脉冲layer。" class="headerlink" title="1.外部扩散的脉冲layer。"></a>1.外部扩散的脉冲layer。</h6></li>
<li><h6 id="2-雷达扫面的内圈layer。"><a href="#2-雷达扫面的内圈layer。" class="headerlink" title="2.雷达扫面的内圈layer。"></a>2.雷达扫面的内圈layer。</h6></li>
<li><h6 id="3-雷达扫描的扇形layer。"><a href="#3-雷达扫描的扇形layer。" class="headerlink" title="3.雷达扫描的扇形layer。"></a>3.雷达扫描的扇形layer。</h6>首先是外部的脉冲扩散动画实现：<br>这个比较简单，参考网上的好多雷达扫描实现，<code>PulsingView.m</code>文件中 代码如下：<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">   [<span class="keyword">super</span> drawRect:rect];</span><br><span class="line">   [[<span class="built_in">UIColor</span> whiteColor] setFill];</span><br><span class="line">   <span class="built_in">UIRectFill</span>(rect);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">UIImage</span> * image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"radar_background"</span>];</span><br><span class="line">   [image drawInRect:rect];</span><br><span class="line"></span><br><span class="line">   <span class="built_in">CGFloat</span> pulsingWidth = rect.size.width / <span class="number">2.5</span>;</span><br><span class="line">   <span class="built_in">CGFloat</span> pulsingX = <span class="keyword">self</span>.center.x - pulsingWidth * <span class="number">0.5</span>;</span><br><span class="line">   <span class="built_in">CGFloat</span> pulsingY = <span class="keyword">self</span>.center.y - pulsingWidth * <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 脉冲layer</span></span><br><span class="line">   <span class="built_in">CALayer</span> * pulsingLayer = [<span class="built_in">CALayer</span> layer];</span><br><span class="line">   pulsingLayer.frame = <span class="built_in">CGRectMake</span>(pulsingX, pulsingY, pulsingWidth, pulsingWidth);</span><br><span class="line">   pulsingLayer.borderColor = [<span class="built_in">UIColor</span> colorWithRed:<span class="number">201</span>/<span class="number">255.0</span> green:<span class="number">201</span>/<span class="number">255.0</span> blue:<span class="number">201</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>].CGColor;</span><br><span class="line">   pulsingLayer.cornerRadius = pulsingWidth * <span class="number">0.5</span>;</span><br><span class="line">   pulsingLayer.backgroundColor = [<span class="built_in">UIColor</span> whiteColor].CGColor;<span class="comment">//这里必须设置layer层的背景颜色，默认应该是透明的，导致设置的阴影颜色无法显示出来</span></span><br><span class="line">   pulsingLayer.shadowColor = [<span class="built_in">UIColor</span> blackColor].CGColor;</span><br><span class="line">   pulsingLayer.shadowOffset = <span class="built_in">CGSizeMake</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">   pulsingLayer.shadowOpacity = <span class="number">1</span>;</span><br><span class="line">   pulsingLayer.shadowRadius = <span class="number">5</span>;</span><br><span class="line">   [<span class="keyword">self</span>.layer addSublayer:pulsingLayer];</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 缩放动画</span></span><br><span class="line">   <span class="built_in">CABasicAnimation</span> * scaleAnimation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"transform.scale"</span>];</span><br><span class="line">   scaleAnimation.autoreverses = <span class="literal">false</span>;</span><br><span class="line">   scaleAnimation.fromValue = @<span class="number">1.0</span>f;</span><br><span class="line">   scaleAnimation.toValue = @<span class="number">2.0</span>f;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 透明动画</span></span><br><span class="line">   <span class="built_in">CAKeyframeAnimation</span> * opacityAnimation = [<span class="built_in">CAKeyframeAnimation</span> animationWithKeyPath:<span class="string">@"opacity"</span>];</span><br><span class="line">   opacityAnimation.keyTimes = @[@<span class="number">0</span>,@<span class="number">0.1</span>,@<span class="number">0.2</span>,@<span class="number">0.3</span>,@<span class="number">0.4</span>,@<span class="number">0.5</span>,@<span class="number">0.6</span>,@<span class="number">0.7</span>,@<span class="number">0.8</span>,@<span class="number">0.9</span>,@<span class="number">1</span>];</span><br><span class="line">   opacityAnimation.values = @[@<span class="number">1</span>,@<span class="number">0.9</span>,@<span class="number">0.8</span>,@<span class="number">0.7</span>,@<span class="number">0.6</span>,@<span class="number">0.5</span>,@<span class="number">0.4</span>,@<span class="number">0.3</span>,@<span class="number">0.2</span>,@<span class="number">0.1</span>,@<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">   <span class="built_in">CAAnimationGroup</span> * animationGroup = [<span class="built_in">CAAnimationGroup</span> animation];</span><br><span class="line">   animationGroup.beginTime = <span class="built_in">CACurrentMediaTime</span>() + <span class="number">1</span>;</span><br><span class="line">   animationGroup.fillMode = kCAFillModeBackwards;</span><br><span class="line">   animationGroup.repeatCount = HUGE_VAL;</span><br><span class="line">   animationGroup.timingFunction = [<span class="built_in">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionLinear];</span><br><span class="line">   animationGroup.duration = <span class="number">2</span>;</span><br><span class="line">   animationGroup.animations = @[scaleAnimation,opacityAnimation];</span><br><span class="line">   [pulsingLayer addAnimation:animationGroup forKey:<span class="string">@"pulse"</span>];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这一步做完会出来如下效果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/972822-1ff188608b5c50cd.gif?imageMogr2/auto-orient/strip" alt="hhhh1.gif"></p>
<p>接下来就是添加雷达的内圈layer,继续在上面的代码下面添加如下代码：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中间圆环</span></span><br><span class="line"><span class="built_in">CALayer</span> * middleCycle = [<span class="built_in">CALayer</span> layer];</span><br><span class="line">middleCycle.frame = <span class="built_in">CGRectMake</span>(pulsingX, pulsingY, pulsingWidth, pulsingWidth);</span><br><span class="line">middleCycle.cornerRadius = pulsingWidth * <span class="number">0.5</span>;</span><br><span class="line">middleCycle.borderColor = [<span class="built_in">UIColor</span> colorWithRed:<span class="number">41</span>/<span class="number">255.0</span> green:<span class="number">152</span>/<span class="number">255.0</span> blue:<span class="number">241</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>].CGColor;</span><br><span class="line">middleCycle.backgroundColor = [<span class="built_in">UIColor</span> whiteColor].CGColor;</span><br><span class="line">middleCycle.shadowOffset = <span class="built_in">CGSizeMake</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">middleCycle.borderWidth = <span class="number">1</span>;</span><br><span class="line">middleCycle.shadowRadius = <span class="number">3</span>;</span><br><span class="line">middleCycle.shadowOpacity = <span class="number">1</span>;</span><br><span class="line">middleCycle.shadowColor = [<span class="built_in">UIColor</span> lightGrayColor].CGColor;</span><br><span class="line">[<span class="keyword">self</span>.layer addSublayer:middleCycle];</span><br></pre></td></tr></table></figure></p>
<p>。这里的坑也是出现在这块地方。因为在外部引用<code>PulsingView</code>的时候，设置的<code>frame</code>是控制器<code>view</code>的<code>bounds</code>,此时运行出来的结果如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/972822-bfb64c532af60924.gif?imageMogr2/auto-orient/strip" alt="middleCycle.gif"></p>
<p>接下来就是最后一步，添加扇形的layer 并添加扫描动画(一开始扇形是打算做成渐变的效果的，不过这里没有完美实现出来，一开始使用了一个三方<strong><a href="https://github.com/heartfly/XHRadarView" target="_blank" rel="noopener">XHRadarView</a></strong>,单纯的引用里面的扇形view的类，这样就可以直接使用他内部的渐变color，不过出来并不是很完美，所以还是自己画扇形，先不做渐变效果了。）此时就出现了关于position问题导致的坑.<br>  这里一开的思路还是和之前一样，继续在<code>self.layer</code>上添加扇形的layer，以<code>self.center</code>为圆心，画一个90度的曲线：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGPoint</span> fanshapedCenter = <span class="keyword">self</span>.center;</span><br><span class="line">  <span class="built_in">UIBezierPath</span> * fanshapedPath = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line">  [fanshapedPath addArcWithCenter:fanshapedCenter radius:(pulsingWidth + <span class="number">20</span>) * <span class="number">0.5</span> startAngle:<span class="number">3</span> * M_PI / <span class="number">2</span> endAngle:<span class="number">0</span> clockwise:<span class="literal">YES</span>];</span><br><span class="line">  [fanshapedPath addLineToPoint:fanshapedCenter];</span><br><span class="line">  [fanshapedPath closePath];</span><br><span class="line">  <span class="built_in">CAShapeLayer</span> * fanshapedLayer = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">  fanshapedLayer.path = fanshapedPath.CGPath;</span><br><span class="line">  fanshapedLayer.opacity = <span class="number">0.7</span>;</span><br><span class="line">  fanshapedLayer.fillColor = [<span class="built_in">UIColor</span> colorWithRed:<span class="number">41</span>/<span class="number">255.0</span> green:<span class="number">152</span>/<span class="number">255.0</span> blue:<span class="number">241</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>].CGColor;</span><br><span class="line">  [<span class="keyword">self</span>.layer addSublayer:fanshapedLayer];</span><br></pre></td></tr></table></figure>
<p>此时运行出来静态情况下的都没问题：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/972822-58549cd738eaf890.gif?imageMogr2/auto-orient/strip" alt="middleCyclestatic.gif"><br>然后添加旋转动画，让扇形绕着圆心进行自转：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CABasicAnimation</span> *rotationAnimation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"transform.rotation.z"</span>];</span><br><span class="line">  rotationAnimation.toValue = [<span class="built_in">NSNumber</span> numberWithFloat: <span class="number">3</span> * M_PI ];</span><br><span class="line">  rotationAnimation.duration = <span class="number">8</span>;</span><br><span class="line">  rotationAnimation.cumulative = <span class="literal">YES</span>;</span><br><span class="line">  rotationAnimation.removedOnCompletion = <span class="literal">NO</span>;</span><br><span class="line">  rotationAnimation.repeatCount = MAXFLOAT;</span><br><span class="line">  rotationAnimation.fillMode = kCAFillModeForwards;</span><br><span class="line">  [fanshapedLayer addAnimation:rotationAnimation forKey:<span class="string">@"rotation"</span>];</span><br></pre></td></tr></table></figure>
<p>然而运行出来的结果并没有和我们预期的一样：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/972822-c3aebf7b0edd1168.gif?imageMogr2/auto-orient/strip" alt="middleCycle.gif"><br>仔细观察可以发现，扇形是在围绕着self的原点(0,0)点进行公转，一开始一直以为是画扇形的时候出的问题，是不是画法不对之类的，还试过直接用Quaritz2D 去画扇形，然而效果依然如此，经过各种查找，才发现是position 导致的问题，通过断点，打印一下<code>hanshapedLayer</code>可以看到如下信息：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Printing description of fanshapedLayer:</span><br><span class="line">&lt;<span class="built_in">CAShapeLayer</span>:<span class="number">0x608000233640</span>; position = <span class="built_in">CGPoint</span> (<span class="number">0</span> <span class="number">0</span>); bounds = <span class="built_in">CGRect</span> (<span class="number">0</span> <span class="number">0</span>; <span class="number">0</span> <span class="number">0</span>); allowsGroupOpacity = <span class="literal">YES</span>; fillColor = &lt;<span class="built_in">CGColor</span> <span class="number">0x6080000bef00</span>&gt; [&lt;<span class="built_in">CGColorSpace</span> <span class="number">0x600000228940</span>&gt; (kCGColorSpaceICCBased; kCGColorSpaceModelRGB; sRGB IEC61966<span class="number">-2.1</span>; extended range)] ( <span class="number">0.160784</span> <span class="number">0.596078</span> <span class="number">0.945098</span> <span class="number">1</span> ); opacity = <span class="number">0.7</span>; path = &lt;<span class="built_in">CGPath</span> <span class="number">0x60800003bf20</span>&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>可以看到hanshapedLayer的position 是 (0,0),也就是父控件的左上角原点，文章开头我们提到过，layer的position 就是自己anchorPoint 相对于父layer 的坐标，而layer自身旋转也是相对于anchorPoint 旋转，这也就解释了为什么我们上面会出现扇形绕着屏幕的最上角做公转。所以我们就需要将<code>hanshapedLayer</code> 的 position 移到中心点的位置：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fanshapedLayer.position = fanshapedCenter;</span><br></pre></td></tr></table></figure>
<p>此时我们再来看运行结果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/972822-488a773988df36ff.gif?imageMogr2/auto-orient/strip" alt="middleCycle.gif"></p>
<p>此时扇形确实是绕着中心点开始转了，但是并不是我们想要的结果。。。此时内心是崩溃的。所以放弃了这种动画的方式，直接将扇形<code>fanshapedLayer</code>添加到中间的内圈layer上，然后让内圈layer自转<br>，最后可以实现最终的效果。</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扫描的扇形</span></span><br><span class="line">     <span class="built_in">UIBezierPath</span> * fanshapedPath = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line">     [fanshapedPath addArcWithCenter:<span class="built_in">CGPointMake</span>(middleCycle.frame.size.width * <span class="number">0.5</span>, middleCycle.frame.size.height * <span class="number">0.5</span>) radius:(pulsingWidth + <span class="number">30</span>) * <span class="number">0.5</span> startAngle:<span class="number">3</span> * M_PI / <span class="number">2</span> endAngle:<span class="number">0</span> clockwise:<span class="literal">YES</span>];</span><br><span class="line">     [fanshapedPath addLineToPoint:<span class="built_in">CGPointMake</span>(middleCycle.frame.size.width * <span class="number">0.5</span>, middleCycle.frame.size.height * <span class="number">0.5</span>)];</span><br><span class="line">     <span class="built_in">CAShapeLayer</span> * fanshaped = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">     fanshaped.fillColor = [<span class="built_in">UIColor</span> colorWithRed:<span class="number">41</span>/<span class="number">255.0</span> green:<span class="number">152</span>/<span class="number">255.0</span> blue:<span class="number">241</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>].CGColor;</span><br><span class="line">     fanshaped.opacity = <span class="number">0.7</span>;</span><br><span class="line">     [fanshapedPath closePath];</span><br><span class="line">     fanshaped.path = fanshapedPath.CGPath;</span><br><span class="line">     [middleCycle addSublayer:fanshaped];</span><br><span class="line"></span><br><span class="line">然后将动画添加到middleCycle上：</span><br><span class="line">     [middleCycle addAnimation:rotationAnimation forKey:<span class="string">@"rotation"</span>];</span><br></pre></td></tr></table></figure>
<p>后来在简书上又看到以篇博客也遇到了公转的问题 <a href="http://www.jianshu.com/p/85d2ebbce5ce" target="_blank" rel="noopener">CALayer旋转动画</a><br>参考这位 <code>渣孩子</code>博主的作法，将画扇形的代码作如下修改：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[fanshapedPath addArcWithCenter:<span class="built_in">CGPointZero</span> radius:(pulsingWidth + <span class="number">20</span>) * <span class="number">0.5</span> startAngle:<span class="number">3</span> * M_PI / <span class="number">2</span> endAngle:<span class="number">0</span> clockwise:<span class="literal">YES</span>];</span><br><span class="line"> [fanshapedPath addLineToPoint:<span class="built_in">CGPointZero</span>];</span><br></pre></td></tr></table></figure>
<p>现在原点位置画出扇形，然后再设置potision<code>fanshapedLayer.position = fanshapedCenter;</code>最后终于解决了这个问题。</p>
<h5 id="最后，贴上draw-方法里的全部代码："><a href="#最后，贴上draw-方法里的全部代码：" class="headerlink" title="最后，贴上draw 方法里的全部代码："></a>最后，贴上draw 方法里的全部代码：</h5><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An empty implementation adversely affects performance during animation.</span></span><br><span class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</span><br><span class="line">    <span class="comment">// Drawing code</span></span><br><span class="line">    [<span class="keyword">super</span> drawRect:rect];</span><br><span class="line">    [[<span class="built_in">UIColor</span> whiteColor] setFill];</span><br><span class="line">    <span class="built_in">UIRectFill</span>(rect);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIImage</span> * image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"radar_background"</span>];</span><br><span class="line">    [image drawInRect:rect];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGFloat</span> pulsingWidth = rect.size.width / <span class="number">2.5</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> pulsingX = <span class="keyword">self</span>.center.x - pulsingWidth * <span class="number">0.5</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> pulsingY = <span class="keyword">self</span>.center.y - pulsingWidth * <span class="number">0.5</span>;</span><br><span class="line">    <span class="comment">// 脉冲layer</span></span><br><span class="line">    <span class="built_in">CALayer</span> * pulsingLayer = [<span class="built_in">CALayer</span> layer];</span><br><span class="line">    pulsingLayer.frame = <span class="built_in">CGRectMake</span>(pulsingX, pulsingY, pulsingWidth, pulsingWidth);</span><br><span class="line">    pulsingLayer.borderColor = [<span class="built_in">UIColor</span> colorWithRed:<span class="number">201</span>/<span class="number">255.0</span> green:<span class="number">201</span>/<span class="number">255.0</span> blue:<span class="number">201</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>].CGColor;</span><br><span class="line">    pulsingLayer.cornerRadius = pulsingWidth * <span class="number">0.5</span>;</span><br><span class="line">    pulsingLayer.backgroundColor = [<span class="built_in">UIColor</span> whiteColor].CGColor;<span class="comment">//这里必须设置layer层的背景颜色，默认应该是透明的，导致设置的阴影颜色无法显示出来</span></span><br><span class="line">    pulsingLayer.shadowColor = [<span class="built_in">UIColor</span> blackColor].CGColor;</span><br><span class="line">    pulsingLayer.shadowOffset = <span class="built_in">CGSizeMake</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    pulsingLayer.shadowOpacity = <span class="number">1</span>;</span><br><span class="line">    pulsingLayer.shadowRadius = <span class="number">5</span>;</span><br><span class="line">    [<span class="keyword">self</span>.layer addSublayer:pulsingLayer];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缩放动画</span></span><br><span class="line">    <span class="built_in">CABasicAnimation</span> * scaleAnimation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"transform.scale"</span>];</span><br><span class="line">    scaleAnimation.autoreverses = <span class="literal">false</span>;</span><br><span class="line">    scaleAnimation.fromValue = @<span class="number">1.0</span>f;</span><br><span class="line">    scaleAnimation.toValue = @<span class="number">2.0</span>f;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 透明动画</span></span><br><span class="line">    <span class="built_in">CAKeyframeAnimation</span> * opacityAnimation = [<span class="built_in">CAKeyframeAnimation</span> animationWithKeyPath:<span class="string">@"opacity"</span>];</span><br><span class="line">    opacityAnimation.keyTimes = @[@<span class="number">0</span>,@<span class="number">0.1</span>,@<span class="number">0.2</span>,@<span class="number">0.3</span>,@<span class="number">0.4</span>,@<span class="number">0.5</span>,@<span class="number">0.6</span>,@<span class="number">0.7</span>,@<span class="number">0.8</span>,@<span class="number">0.9</span>,@<span class="number">1</span>];</span><br><span class="line">    opacityAnimation.values = @[@<span class="number">1</span>,@<span class="number">0.9</span>,@<span class="number">0.8</span>,@<span class="number">0.7</span>,@<span class="number">0.6</span>,@<span class="number">0.5</span>,@<span class="number">0.4</span>,@<span class="number">0.3</span>,@<span class="number">0.2</span>,@<span class="number">0.1</span>,@<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CAAnimationGroup</span> * animationGroup = [<span class="built_in">CAAnimationGroup</span> animation];</span><br><span class="line">    animationGroup.beginTime = <span class="built_in">CACurrentMediaTime</span>() + <span class="number">1</span>;</span><br><span class="line">    animationGroup.fillMode = kCAFillModeBackwards;</span><br><span class="line">    animationGroup.repeatCount = HUGE_VAL;</span><br><span class="line">    animationGroup.timingFunction = [<span class="built_in">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionLinear];</span><br><span class="line">    animationGroup.duration = <span class="number">2</span>;</span><br><span class="line">    animationGroup.animations = @[scaleAnimation,opacityAnimation];</span><br><span class="line">    [pulsingLayer addAnimation:animationGroup forKey:<span class="string">@"pulse"</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中间圆环</span></span><br><span class="line">    <span class="built_in">CALayer</span> * middleCycle = [<span class="built_in">CALayer</span> layer];</span><br><span class="line">    middleCycle.frame = <span class="built_in">CGRectMake</span>(pulsingX, pulsingY, pulsingWidth, pulsingWidth);</span><br><span class="line">    middleCycle.cornerRadius = pulsingWidth * <span class="number">0.5</span>;</span><br><span class="line">    middleCycle.borderColor = [<span class="built_in">UIColor</span> colorWithRed:<span class="number">41</span>/<span class="number">255.0</span> green:<span class="number">152</span>/<span class="number">255.0</span> blue:<span class="number">241</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>].CGColor;</span><br><span class="line">    middleCycle.backgroundColor = [<span class="built_in">UIColor</span> whiteColor].CGColor;</span><br><span class="line">    middleCycle.shadowOffset = <span class="built_in">CGSizeMake</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    middleCycle.borderWidth = <span class="number">1</span>;</span><br><span class="line">    middleCycle.shadowRadius = <span class="number">3</span>;</span><br><span class="line">    middleCycle.shadowOpacity = <span class="number">1</span>;</span><br><span class="line">    middleCycle.shadowColor = [<span class="built_in">UIColor</span> lightGrayColor].CGColor;</span><br><span class="line">    [<span class="keyword">self</span>.layer addSublayer:middleCycle];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加到self.layer上</span></span><br><span class="line">    <span class="built_in">CGPoint</span> fanshapedCenter = <span class="keyword">self</span>.center;</span><br><span class="line">    <span class="built_in">UIBezierPath</span> * fanshapedPath = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line">    [fanshapedPath addArcWithCenter:<span class="built_in">CGPointZero</span> radius:(pulsingWidth + <span class="number">20</span>) * <span class="number">0.5</span> startAngle:<span class="number">3</span> * M_PI / <span class="number">2</span> endAngle:<span class="number">0</span> clockwise:<span class="literal">YES</span>];</span><br><span class="line">    [fanshapedPath addLineToPoint:<span class="built_in">CGPointZero</span>];</span><br><span class="line">    [fanshapedPath closePath];</span><br><span class="line">    <span class="built_in">CAShapeLayer</span> * fanshapedLayer = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">    fanshapedLayer.path = fanshapedPath.CGPath;</span><br><span class="line">    fanshapedLayer.opacity = <span class="number">0.7</span>;</span><br><span class="line">    fanshapedLayer.position = fanshapedCenter;</span><br><span class="line">    fanshapedLayer.fillColor = [<span class="built_in">UIColor</span> colorWithRed:<span class="number">41</span>/<span class="number">255.0</span> green:<span class="number">152</span>/<span class="number">255.0</span> blue:<span class="number">241</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>].CGColor;</span><br><span class="line">    [<span class="keyword">self</span>.layer addSublayer:fanshapedLayer];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加到middleCycle上</span></span><br><span class="line"><span class="comment">//    [fanshapedPath addArcWithCenter:CGPointMake(0,0) radius:(pulsingWidth + 20) * 0.5 startAngle:3 * M_PI / 2 endAngle:0 clockwise:YES];</span></span><br><span class="line"><span class="comment">//    [fanshapedPath addLineToPoint:CGPointZero];</span></span><br><span class="line"><span class="comment">//    CAShapeLayer * fanshaped = [CAShapeLayer layer];</span></span><br><span class="line"><span class="comment">//    fanshaped.fillColor = [UIColor colorWithRed:41/255.0 green:152/255.0 blue:241/255.0 alpha:1].CGColor;</span></span><br><span class="line"><span class="comment">//    fanshaped.opacity = 0.7;</span></span><br><span class="line"><span class="comment">//    fanshaped.position = CGPointMake(middleCycle.frame.size.width * 0.5, middleCycle.frame.size.height * 0.5);</span></span><br><span class="line"><span class="comment">//    [fanshapedPath closePath];</span></span><br><span class="line"><span class="comment">//    fanshaped.path = fanshapedPath.CGPath;</span></span><br><span class="line"><span class="comment">//    [middleCycle addSublayer:fanshaped];</span></span><br><span class="line"><span class="comment">//    NSLog(@"fanshaped==== frame:%@,anchorPoint:%@,bounds:%@,position:%@",NSStringFromCGRect(fanshaped.frame),NSStringFromCGPoint(fanshaped.anchorPoint),NSStringFromCGRect(fanshaped.bounds),NSStringFromCGPoint(fanshaped.position));</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">CABasicAnimation</span> *rotationAnimation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"transform.rotation.z"</span>];</span><br><span class="line">    rotationAnimation.toValue = [<span class="built_in">NSNumber</span> numberWithFloat: <span class="number">3</span> * M_PI ];</span><br><span class="line">    rotationAnimation.duration = <span class="number">8</span>;</span><br><span class="line">    rotationAnimation.cumulative = <span class="literal">YES</span>;</span><br><span class="line">    rotationAnimation.removedOnCompletion = <span class="literal">NO</span>;</span><br><span class="line">    rotationAnimation.repeatCount = MAXFLOAT;</span><br><span class="line">    rotationAnimation.fillMode = kCAFillModeForwards;</span><br><span class="line">    <span class="comment">//    [middleCycle addAnimation:rotationAnimation forKey:@"rotation"];</span></span><br><span class="line"></span><br><span class="line">    [fanshapedLayer addAnimation:rotationAnimation forKey:<span class="string">@"rotation"</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[杂记]]></title>
      <url>/Blog/2017/08/27/%E6%9D%82%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>世界那么大，我想去看看</p>
<a id="more"></a>
<blockquote>
<h4 id="hexo-常用命令："><a href="#hexo-常用命令：" class="headerlink" title="hexo 常用命令："></a>hexo 常用命令：</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hexo new postName       #新建文章 在source/_posts 下生成</span><br><span class="line">hexo new page pageName  #新建页面 在source/pageName 下生成</span><br><span class="line">hexo deploy             #将.deploy目录部署到GitHub 简写指令：hexo d</span><br><span class="line">hexo generate           #生成静态页面至public目录 简写指令：hexo g</span><br><span class="line">hexo server             #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）简写指令hexo s</span><br><span class="line">hexo clean              #清除所有静态页面和缓存数据</span><br></pre></td></tr></table></figure>
<blockquote>
<p>next 文档：<br><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">http://theme-next.iissnan.com/getting-started.html</a></p>
</blockquote>
<p><a href="http://prozhuchen.com/2017/01/05/%E7%BD%91%E7%AB%99%E6%94%B9%E5%8A%A8/" target="_blank" rel="noopener">网站改动-加入背景特效 &amp; 自定义页面存放特定文章</a></p>
]]></content>
      
        <categories>
            
            <category> hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[test]]></title>
      <url>/Blog/2017/07/12/test/</url>
      <content type="html"><![CDATA[<h6 id="note"><a href="#note" class="headerlink" title="note:"></a>note:</h6><blockquote>
<p><code>Atom MarkDown文件编辑快捷键：contorl + shift + M 进入预览模式</code></p>
</blockquote>
<a id="more"></a>
<ul>
<li><h6 id="父目录"><a href="#父目录" class="headerlink" title="父目录"></a>父目录</h6><ul>
<li>####### 我是子目录<ul>
<li>我是孙子目录</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="删除本地索引库文件"><a href="#删除本地索引库文件" class="headerlink" title="删除本地索引库文件"></a>删除本地索引库文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod repo remove xxxlib</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有时候想要改变本地的索引库名称，可以用这个删除掉之前的，然后<code>通过 pod repo add newName git地址</code>来设置新的名称。</p>
</blockquote>
<!--  more-->
<h4 id="事件响应链"><a href="#事件响应链" class="headerlink" title="事件响应链"></a>事件响应链</h4><blockquote>
<ul>
<li><h6 id="寻找最合适的view"><a href="#寻找最合适的view" class="headerlink" title="寻找最合适的view"></a>寻找最合适的view</h6><ul>
<li>####### 我是子目录<ul>
<li>我是孙子目录</li>
</ul>
</li>
</ul>
</li>
<li><h6 id="当一个事件传递给view-的时候会调用"><a href="#当一个事件传递给view-的时候会调用" class="headerlink" title="当一个事件传递给view 的时候会调用"></a>当一个事件传递给view 的时候会调用</h6></li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (UIView *)hitTest:(CGPOint)point withEvent:(UIEvent *)event;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<ul>
<li><h6 id="判断当前点在不在调用的view-的身上。"><a href="#判断当前点在不在调用的view-的身上。" class="headerlink" title="判断当前点在不在调用的view 的身上。"></a>判断当前点在不在调用的view 的身上。</h6></li>
<li><h6 id="他是在hitTest方法中调用的。"><a href="#他是在hitTest方法中调用的。" class="headerlink" title="他是在hitTest方法中调用的。"></a>他是在hitTest方法中调用的。</h6></li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)pointInsid:(CGPOint)point withEvent:(UIEvent *)event;</span><br></pre></td></tr></table></figure>
<ul>
<li><h6 id="1-先去判断当前的View-是不是控制器的View-如果当前的View是控制器的View，那么，它的上一个响应链就是它所在的控制器"><a href="#1-先去判断当前的View-是不是控制器的View-如果当前的View是控制器的View，那么，它的上一个响应链就是它所在的控制器" class="headerlink" title="1.先去判断当前的View 是不是控制器的View,如果当前的View是控制器的View，那么，它的上一个响应链就是它所在的控制器"></a>1.先去判断当前的View 是不是控制器的View,如果当前的View是控制器的View，那么，它的上一个响应链就是它所在的控制器</h6></li>
<li><h6 id="2-如果当前View-不是控制器的View-那么父控件就是上一个响应链。"><a href="#2-如果当前View-不是控制器的View-那么父控件就是上一个响应链。" class="headerlink" title="2.如果当前View 不是控制器的View ,那么父控件就是上一个响应链。"></a>2.如果当前View 不是控制器的View ,那么父控件就是上一个响应链。</h6></li>
</ul>
<h3 id="pragma-mark-C语言"><a href="#pragma-mark-C语言" class="headerlink" title="#pragma mark - C语言"></a>#pragma mark - C语言</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><h5 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h5><p>数组的缺点：</p>
<ul>
<li><h5 id="数组长度必须事先制定，且只能是常整数，不能是变量。"><a href="#数组长度必须事先制定，且只能是常整数，不能是变量。" class="headerlink" title="数组长度必须事先制定，且只能是常整数，不能是变量。"></a>数组长度必须事先制定，且只能是常整数，不能是变量。</h5><ul>
<li><h6 id="🌰"><a href="#🌰" class="headerlink" title="🌰"></a>🌰</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a[5] = &#123;1,2,3,4,5&#125;;  // 正确</span><br><span class="line">int length = 5; a[length];  // error</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><h5 id="传统形式定义的数组，程序员无法手动释放该数组的内存。在一个函数运行期间，该函数为该数组分配的空间会一直存在，直到该函数运行完毕，数组的空间才会被释放。"><a href="#传统形式定义的数组，程序员无法手动释放该数组的内存。在一个函数运行期间，该函数为该数组分配的空间会一直存在，直到该函数运行完毕，数组的空间才会被释放。" class="headerlink" title="传统形式定义的数组，程序员无法手动释放该数组的内存。在一个函数运行期间，该函数为该数组分配的空间会一直存在，直到该函数运行完毕，数组的空间才会被释放。"></a>传统形式定义的数组，程序员无法手动释放该数组的内存。在一个函数运行期间，该函数为该数组分配的空间会一直存在，直到该函数运行完毕，数组的空间才会被释放。</h5></li>
<li><h5 id="数组的长度不能在函数运行的过程中动态的扩充和缩小。"><a href="#数组的长度不能在函数运行的过程中动态的扩充和缩小。" class="headerlink" title="数组的长度不能在函数运行的过程中动态的扩充和缩小。"></a>数组的长度不能在函数运行的过程中动态的扩充和缩小。</h5></li>
</ul>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript]]></title>
      <url>/Blog/2017/06/27/javascript/</url>
      <content type="html"><![CDATA[<h1 id="JavaScript基础"><a href="#JavaScript基础" class="headerlink" title="JavaScript基础"></a>JavaScript基础</h1><blockquote>
<p>1.JavaScript 包含:<code>ECMA</code>,<code>DOM</code>和<code>BOM</code>。<br>2.JavaScript 的基础类型有<em><strong>number</strong></em>,<strong><em>string</em></strong>和<strong><em>boolean</em></strong> (<strong>这些都是小写</strong>)。<br>3.JavaScript的复合类型有<code>Number</code>,<code>Array</code>,<code>Date</code>,<code>String</code>,<code>Boolean</code>,<code>RegExp</code>,<code>Math</code>,还有两个核心类型<code>Object</code>和<code>Function</code>。<br>4.JavaScript</p>
</blockquote>
<a id="more"></a>
<h4 id="map-和-reduce"><a href="#map-和-reduce" class="headerlink" title="map 和 reduce"></a>map 和 reduce</h4><p><strong>“不要使用JavaScript内置的parseInt()函数，利用map和reduce操作实现一个string2int()函数”</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function str2Int(s)&#123;</span><br><span class="line">        // map 是针对数组使用的，所以这里需要先将s转换成字符串数组</span><br><span class="line">        // split() 方法用于把一个字符串分割成字符串数组。</span><br><span class="line">        var aStr = s.split(&apos;&apos;);</span><br><span class="line">        // 这里得到的数组里面的元素还是单个字符串，需要转换成数字类型，才能进行reduce  操作</span><br><span class="line">        var iArr = aStr.map(x=&gt;+x);</span><br><span class="line">        return iArr.reduce((x,y)=&gt;x * 10 + y);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">// 使用     </span><br><span class="line"> if(str2Int.toString().indexOf(&apos;parseInt&apos;)!==-1)&#123;</span><br><span class="line">        alert(&apos;不能使用parseInt&apos;)</span><br><span class="line">      &#125;else if(str2Int(&apos;123&apos;)===123 &amp;&amp; str2Int(&apos;1500&apos;) === 1500 &amp;&amp; str2Int(&apos;1201&apos;)===1201)</span><br><span class="line">      &#123;</span><br><span class="line">        alert(&apos;验证通过&apos;);</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        alert(&apos;验证不通过&apos;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><p><a href="http://www.cnblogs.com/justany/archive/2013/01/30/2882582.html" target="_blank" rel="noopener">Javascript中字符串转数字</a></p>
<p><a href="http://www.w3school.com.cn/jsref/jsref_split.asp" target="_blank" rel="noopener">JavaScript split() 方法</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[工作中的坑]]></title>
      <url>/Blog/2017/04/01/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E7%9A%84%E5%9D%91/</url>
      <content type="html"><![CDATA[<h5 id="1-通过xib加载的控件在viewDidLoad-中重新计算布局不准确的问题"><a href="#1-通过xib加载的控件在viewDidLoad-中重新计算布局不准确的问题" class="headerlink" title="1.通过xib加载的控件在viewDidLoad 中重新计算布局不准确的问题"></a>1.通过xib加载的控件在viewDidLoad 中重新计算布局不准确的问题</h5><p>在爱山门<code>实时上门</code>模块，由于之前没有加网络提示器或者没网的空白页之类的，在网络情况差的情况下，直接就是一个空白页放在那里，用户体验特别不好，所以这里需要加上一个网络的提示器在加载的时候进行弹窗提示用户，记载成功的话就直接显示数据，失败的话就提示网络问题。这个直接用SVProgress就可以。由于这里的界面布局比较固定，所以最好可以再做一个本地缓存，利用FMDB将上一次的数据存到本地，下次打开的话先从数据库去获取数据，没有的话再去网络请求。这里遇到了一个问题，折腾了大半个上午。就是每次通过本地缓存去加载数据的时候滑动范围总是不准，在viewDidLoad中已经计算好了scrollView 的高度和tableView 的高度，但是在viewDidDissAppear 中再去打印的话会发现尺寸并不是我们计算的那个结果。下拉刷新或者直接去加载网络的数据的时候就没问题。后来一直调试查找猜测应该是xib 的问题，<code>因为这里的scrollView 和 tableView 都是通过xib 去加载的，通过xib 加载的文件在viewDidLoad中加载的时候并不会去布局frame ，只是拿到xib 中设置的大小属性，只有在 viewDidLayoutSubViews 里才会去根据布局去确定控件的最终尺寸(不过添加view 的操作不能放在这里，因为这个方法会调用多次)</code></p>
<hr>
<a id="more"></a>
<!-- 这里是截断，显示阅读全文 -->
<h5 id="2-导航栏隐藏-push-到下个界面再手势返回的时候显示和隐藏的问题。如下："><a href="#2-导航栏隐藏-push-到下个界面再手势返回的时候显示和隐藏的问题。如下：" class="headerlink" title="2.导航栏隐藏 push 到下个界面再手势返回的时候显示和隐藏的问题。如下："></a>2.导航栏隐藏 push 到下个界面再手势返回的时候显示和隐藏的问题。如下：</h5><p><img src="http://upload-images.jianshu.io/upload_images/972822-4abd7d944d99ddc5.gif?imageMogr2/auto-orient/strip" alt="before.gif"></p>
<blockquote>
<p>好多项目中都会有这样的需求，导航栏透明或者隐藏，但是push 到下一个界面，如果用手势返回的话就会出现如上的问题，</p>
</blockquote>
<p>比如<strong>积分商城</strong>：<br>个人中心界面需要隐藏导航栏，设置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewWillAppear:(BOOL)animated</span><br><span class="line">&#123;</span><br><span class="line">     [super viewWillAppear:animated];</span><br><span class="line"></span><br><span class="line">     [self.navigationController setNavigationBarHidden:YES animated:animated];</span><br><span class="line"></span><br><span class="line">     [self getCenter];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>点击积分商城需要显示导航栏，设置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewWillAppear:(BOOL)animated</span><br><span class="line">&#123;</span><br><span class="line">     [super viewWillAppear:animated];</span><br><span class="line"></span><br><span class="line">//     [Glob showTabBar];</span><br><span class="line"></span><br><span class="line">     [[self rdv_tabBarController] setTabBarHidden:YES animated:YES];</span><br><span class="line"></span><br><span class="line">     [self.navigationController setNavigationBarHidden:NO animated:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果只是这样设置的话手势返回的话就会出现上面的问题。网上找了各种资料和三方库，比如 <a href="[http://www.jianshu.com/p/31f177158c9e](https://link.juejin.im/?target=http%3A%2F%2Fwww.jianshu.com%2Fp%2F31f177158c9e">让我们一次性解决导航栏的所有问题
</a>),由于之前项目中使用的tabBar 是 三方的<code>RDVTabBarController</code>，所以用上面文章中的三方总会出先手势返回的时候上一个控制器被一个空白的UIView挡住的情况。所以又开始找其他的同样不是很完美。最后抱着瞎猫碰死耗子的心态，就试试网上的一些建议，采用如下写法，在<code>积分商城界面</code>加上如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewWillDisappear:(BOOL)animated</span><br><span class="line">&#123;</span><br><span class="line">     [self.navigationController setNavigationBarHidden:NO animated:YES];</span><br><span class="line">     [super viewWillDisappear:animated] ;  // 切记要加这个，不然没效果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一开始在一个空白的项目中做了测试，这样确实是可以了，但是放到公司项目却还是没用，一开始怀疑是  <code>[super viewWillDisappear:animated]</code>方法应该放在最后调用，后来测试放在前面和后面都没区别。最后发现问题是在<code>个人中心界面</code>，一开始个人中心界面隐藏导航栏的时候，动画那块设置的是NO：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.navigationController setNavigationBarHidden:YES animated:NO];</span><br></pre></td></tr></table></figure></p>
<p>最后改成如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[self.navigationController setNavigationBarHidden:YES animated:animated];</span><br><span class="line"></span><br><span class="line">至于这里的animated 写成 没有写成YES OR NO 是因为在网上看到过系统返回的属性不只是这两个（虽然我也不懂）不过这里animated 写成YES 也可以。</span><br></pre></td></tr></table></figure></p>
<p>发现可以正常使用了。效果如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/972822-339b15f2d12c83ce.gif?imageMogr2/auto-orient/strip" alt="hhhh.gif"></p>
<p>Perfect!<br><code>更新</code><br><code>后来发现只需要在个人中心设置</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.navigationController setNavigationBarHidden:YES animated:animated] // 这里animated 写成YES 也可以</span><br></pre></td></tr></table></figure></p>
<p><code>不用再在其他界面再添加</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewWillDisappear:(BOOL)animated</span><br><span class="line">&#123;</span><br><span class="line">     [self.navigationController setNavigationBarHidden:NO animated:YES];</span><br><span class="line">     [super viewWillDisappear:animated] ;  // 切记要加这个，不然没效果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>也一样可以实现效果</code></p>
<h6 id="3-使用字典转模型的时候遇到崩溃-NSInvalidArgumentException-NSTaggedPointerString-unsignedLongLongValue-unrecognized-selector-sent-to-instance"><a href="#3-使用字典转模型的时候遇到崩溃-NSInvalidArgumentException-NSTaggedPointerString-unsignedLongLongValue-unrecognized-selector-sent-to-instance" class="headerlink" title="3.使用字典转模型的时候遇到崩溃 NSInvalidArgumentException -[__NSTaggedPointerString unsignedLongLongValue]: unrecognized selector sent to instance"></a>3.使用字典转模型的时候遇到崩溃 <code>NSInvalidArgumentException -[__NSTaggedPointerString unsignedLongLongValue]: unrecognized selector sent to instance</code></h6><blockquote>
<p>这个问题，是因为64bit中，NSString 中没有unsignedLongLongValue这个方法了， 而当字典中obj的类型是NSString类型，实体中的key对应的属性是NSUinteger类型，setValue:obj forKey:key 会自动做如下处理：<br>[obj unsignedLongLongValue] 将value转为对应的属性类型，这就导致64bit中找不到该方法而crash。解决是，对NSString写一个category，重新写一个unsignedLongLongValue的方法：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-(NSUinteger)unsignedLongLongValue &#123;</span><br><span class="line">   return [self integerValue];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者 避免 让系统做NSString-&gt;NSUInteger的类型装换</p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[清除缓存]]></title>
      <url>/Blog/2017/02/07/%E6%B8%85%E9%99%A4%E7%BC%93%E5%AD%98/</url>
      <content type="html"><![CDATA[<blockquote>
<p>现在的大多数APP都带有缓存功能，尤其是使用一些第三方框架，比如SDWebImage 就自带缓存功能。当用了一段时间后，缓存就会越来愈大，如果不清除的话就会影响用户体验和性能，所以大多📚APP加了清除缓存的功能。这里的主要实现思路也是根据SDWebImage 的思路去实现。这里需要用到一个 <code>simpholders</code>工具可以直接查看沙盒下的东西。</p>
</blockquote>
<a id="more"></a>
<p>#1.获取缓存</p>
<blockquote>
<p>既然是参考SDWebImage去实现，那么首先就是进去看看他是怎么实现的，首先先导入  <code>#import &lt;SDWebImage/SDImageCache.h&gt;</code>头文件，这是SDWebImage 的一个管理缓存的类，点进去在文件中搜索关键词<code>cache</code>,会看到好多结果，一直往下拉，会看到这么几个方法：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">我们看到里面有这样一个方法，很明显这个是我们常写的单例。待会儿会用到</span><br><span class="line">/**</span><br><span class="line"> * Returns global shared cache instance</span><br><span class="line"> *</span><br><span class="line"> * @return SDImageCache global instance</span><br><span class="line"> */</span><br><span class="line">+ (SDImageCache *)sharedImageCache;</span><br></pre></td></tr></table></figure>
<p>再往下就看到下面的方法：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/972822-76b9698975a5678b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>这些根据字面意思很容易看出来都是干什么的。既然这里我们的第一步是想先获取缓存，那么我们就主要先看一下<code>getSize</code>方法，点击进去会看到如下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInteger)getSize &#123;</span><br><span class="line">    __block NSUInteger size = 0;</span><br><span class="line">    dispatch_sync(self.ioQueue, ^&#123;</span><br><span class="line">        NSDirectoryEnumerator *fileEnumerator = [_fileManager enumeratorAtPath:self.diskCachePath];</span><br><span class="line">        for (NSString *fileName in fileEnumerator) &#123;</span><br><span class="line">            NSString *filePath = [self.diskCachePath stringByAppendingPathComponent:fileName];</span><br><span class="line">            NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfItemAtPath:filePath error:nil];</span><br><span class="line">            size += [attrs fileSize];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们看到需要用到一个 <code>_fileManager</code>的对象，这是一个<code>NSFileManager</code> 的对象,我们先回到我们的类文件中，去调用一下getSize 方法获取缓存。通过上面的工具我们可以查看SDWebImage的缓存文件：<code>在default文件下面就是</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/972822-3aa2931213721d05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> NSUInteger  cach = [[SDImageCache sharedImageCache] getSize];</span><br><span class="line"> NXLog(@&quot;sdweb-----caches:%lu&quot;,(unsigned long)cach);</span><br><span class="line"></span><br><span class="line">打印结果如下</span><br><span class="line">2017-02-06 23:41:09.554 BaiSi[44360:1314372] sdweb-----caches:2824429</span><br></pre></td></tr></table></figure>
<p>通过右键查看文件，得到结果如下，比打印结果大是因为这里还包括了隐藏文件.DS</p>
<p><img src="http://upload-images.jianshu.io/upload_images/972822-28f89493e425914d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>我们也以获取这个文件夹缓存的大小为试验，看看自己写的结果是否和SD 的一样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)clearCach&#123;</span><br><span class="line">    //1.先获取cache 目录的路径</span><br><span class="line">    NSString * cachePath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject];</span><br><span class="line">    // 这里先以获取 default  文件夹大小做实验，看看是否和 SDImageCache 获取的一样</span><br><span class="line">    NSString * directorPath = [cachePath stringByAppendingPathComponent:@&quot;default&quot;];</span><br><span class="line">    //2.声明一个文件管理对象</span><br><span class="line">    NSFileManager * fileManager = [NSFileManager defaultManager];</span><br><span class="line">    //3.在 SDImageCache 的getSize 方法里面我们看到调用了一个方法  NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfItemAtPath:filePath error:nil];所以我们也模仿他去做</span><br><span class="line">    NSDictionary * attrs = [fileManager attributesOfItemAtPath:directorPath error:nil];</span><br><span class="line">    //4.最后获取size</span><br><span class="line">    NSUInteger size = [attrs fileSize];</span><br><span class="line">    NXLog(@&quot;custom----size:%lu&quot;,(unsigned long)size);</span><br><span class="line"></span><br><span class="line">    //打印结果如下</span><br><span class="line">    // 2017-02-06 23:47:01.843 BaiSi[44442:1317486] custom----size:136</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到最后的结果和SD差了相当多，初步判断这个可能不可以获取文件夹的大小，智能或许文件的大小，为了验证，我们拼接一个文件的路径，在上面第一步获取路径下面再加上一个image 的路径，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSString * imagePath = [directorPath stringByAppendingPathComponent:@&quot;com.hackemist.SDWebImageCache.default/aa96232fe024aeba562815618fd5e02a.jpg&quot;];</span><br><span class="line">第三步里的directorPath  改成  imagePath ,运行</span><br><span class="line"></span><br><span class="line">//打印结果如下：</span><br><span class="line">2017-02-07 00:00:04.244 BaiSi[44688:1326243] custom----size:169817</span><br></pre></td></tr></table></figure></p>
<p>我们直接通过查看图片属性结果如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/972822-325c1217fd73bda4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>和我们得到的结果一模一样，说明该属性方法只是获取文件的大小，所以我们需要遍历目的文件夹下的所有文件，将大小累加起来，就是该文件夹的总大小。<br>在SD 的 getSize 方法里面我们可以看到他调用的是 <code>NSDirectoryEnumerator *fileEnumerator = [_fileManager enumeratorAtPath:self.diskCachePath];</code>方法，然后去遍历<code>fileEnumerator</code>。这里我们可以用另一个属性<code>subpathsAtPath:directorPath</code>，改写<code>clearCach</code>如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (void)clearCach&#123;</span><br><span class="line">    //1.先获取cache 目录的路径</span><br><span class="line">    NSString * cachePath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject];</span><br><span class="line">    // 这里先以获取 default  文件夹大小做实验，看看是否和 SDImageCache 获取的一样</span><br><span class="line">    NSString * directorPath = [cachePath stringByAppendingPathComponent:@&quot;default&quot;];</span><br><span class="line"></span><br><span class="line">    //2.声明一个文件管理对象</span><br><span class="line">    NSFileManager * fileManager = [NSFileManager defaultManager];</span><br><span class="line">    //3.在 SDImageCache 的getSize 方法里面我们看到调用了一个方法  NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfItemAtPath:filePath error:nil];所以我们也模仿他去做</span><br><span class="line"></span><br><span class="line">    //这个可以获取所有的子文件及子文件下的文件</span><br><span class="line">    NSArray * subPaths = [fileManager subpathsAtPath:directorPath];</span><br><span class="line">    NXLog(@&quot;subPaths:%@&quot;,subPaths);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    NSDictionary * attrs = [fileManager attributesOfItemAtPath:directorPath error:nil];</span><br><span class="line">    //4.最后获取size</span><br><span class="line">    NSUInteger size = [attrs fileSize];</span><br><span class="line">    NXLog(@&quot;custom----size:%lu&quot;,(unsigned long)size);</span><br><span class="line"></span><br><span class="line">    //打印结果如下</span><br><span class="line">    // 2017-02-06 23:47:01.843 BaiSi[44442:1317486] custom----size:136</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>打印结果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/972822-f377bd54afa6389e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>可以看到 这个方法获取到了default  文件夹下的子文件夹及子文件夹下的文件以及隐藏文件.接下来我们继续修改clearCach 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (void)clearCach&#123;</span><br><span class="line">    //1.先获取cache 目录的路径</span><br><span class="line">    NSString * cachePath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject];</span><br><span class="line">    // 这里先以获取 default  文件夹大小做实验，看看是否和 SDImageCache 获取的一样</span><br><span class="line">    NSString * directorPath = [cachePath stringByAppendingPathComponent:@&quot;default&quot;];</span><br><span class="line"></span><br><span class="line">    //2.声明一个文件管理对象</span><br><span class="line">    NSFileManager * fileManager = [NSFileManager defaultManager];</span><br><span class="line">    //3.在 SDImageCache 的getSize 方法里面我们看到调用了一个方法  NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfItemAtPath:filePath error:nil];所以我们也模仿他去做</span><br><span class="line"></span><br><span class="line">    //这个可以获取所有的子文件及子文件下的文件</span><br><span class="line">    NSArray * subPaths = [fileManager subpathsAtPath:directorPath];</span><br><span class="line">    NSUInteger totoalSize = 0 ;</span><br><span class="line">    for (NSString * path in subPaths) &#123;</span><br><span class="line">        NSString * filePath = [directorPath stringByAppendingPathComponent:path];</span><br><span class="line"></span><br><span class="line">        NSDictionary * attrs = [fileManager attributesOfItemAtPath:filePath error:nil];</span><br><span class="line">        //4.最后获取size</span><br><span class="line">        totoalSize += [attrs fileSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NXLog(@&quot;custom----size:%lu&quot;,(unsigned long)totoalSize);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终打印结果如下</p>
<p><img src="http://upload-images.jianshu.io/upload_images/972822-811e023926c561a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>基本上和SD 自己获取的大小差不多，这里比SD  的大是因为这里没有排除隐藏文件.DS_Store和下面那个default 文件夹,接下来对这两个文件进行排除：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">- (void)clearCach&#123;</span><br><span class="line">    //1.先获取cache 目录的路径</span><br><span class="line">    NSString * cachePath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject];</span><br><span class="line">    // 这里先以获取 default  文件夹大小做实验，看看是否和 SDImageCache 获取的一样</span><br><span class="line">    NSString * directorPath = [cachePath stringByAppendingPathComponent:@&quot;default&quot;];</span><br><span class="line"></span><br><span class="line">    //2.声明一个文件管理对象</span><br><span class="line">    NSFileManager * fileManager = [NSFileManager defaultManager];</span><br><span class="line">    //3.在 SDImageCache 的getSize 方法里面我们看到调用了一个方法  NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfItemAtPath:filePath error:nil];所以我们也模仿他去做</span><br><span class="line"></span><br><span class="line">    //这个可以获取所有的子文件及子文件下的文件</span><br><span class="line">    NSArray * subPaths = [fileManager subpathsAtPath:directorPath];</span><br><span class="line">    NSUInteger totoalSize = 0 ;</span><br><span class="line">    for (NSString * path in subPaths) &#123;</span><br><span class="line">        NSString * filePath = [directorPath stringByAppendingPathComponent:path];</span><br><span class="line"></span><br><span class="line">        //判断是否是隐藏文件</span><br><span class="line">        if ([filePath containsString:@&quot;.DS&quot;]) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断是否是文件夹</span><br><span class="line">        BOOL isDirector;</span><br><span class="line">        BOOL fileExist = [fileManager fileExistsAtPath:filePath isDirectory:&amp;isDirector];</span><br><span class="line">        if (!fileExist || isDirector) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        NSDictionary * attrs = [fileManager attributesOfItemAtPath:filePath error:nil];</span><br><span class="line">        //4.最后获取size</span><br><span class="line">        totoalSize += [attrs fileSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NXLog(@&quot;custom----size:%lu&quot;,(unsigned long)totoalSize);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个时候得到的结果就和SD 的一样了。<br>上面的结果基本上已经可以满足功能了，不过为了复用性，还得进行一些修改，最好是能传入一个文件夹的路径然后获取大小，这里吧方法名改了一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInteger)getFileSize:(NSString *)directorPath&#123;</span><br><span class="line"></span><br><span class="line">    //2.声明一个文件管理对象</span><br><span class="line">    NSFileManager * fileManager = [NSFileManager defaultManager];</span><br><span class="line">    //3.在 SDImageCache 的getSize 方法里面我们看到调用了一个方法  NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfItemAtPath:filePath error:nil];所以我们也模仿他去做</span><br><span class="line"></span><br><span class="line">    //这个可以获取所有的子文件及子文件下的文件</span><br><span class="line">    NSArray * subPaths = [fileManager subpathsAtPath:directorPath];</span><br><span class="line">    NSUInteger totoalSize = 0 ;</span><br><span class="line">    for (NSString * path in subPaths) &#123;</span><br><span class="line">        NSString * filePath = [directorPath stringByAppendingPathComponent:path];</span><br><span class="line"></span><br><span class="line">        //判断是否是隐藏文件</span><br><span class="line">        if ([filePath containsString:@&quot;.DS&quot;]) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断是否是文件夹</span><br><span class="line">        BOOL isDirector;</span><br><span class="line">        BOOL fileExist = [fileManager fileExistsAtPath:filePath isDirectory:&amp;isDirector];</span><br><span class="line">        if (!fileExist || isDirector) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        NSDictionary * attrs = [fileManager attributesOfItemAtPath:filePath error:nil];</span><br><span class="line">        //4.最后获取size</span><br><span class="line">        totoalSize += [attrs fileSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NXLog(@&quot;custom----size:%lu&quot;,(unsigned long)totoalSize);</span><br><span class="line">    return  totoalSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 然后在调用的地方如下就可以了：</span><br><span class="line"></span><br><span class="line"> //1.先获取cache 目录的路径</span><br><span class="line">    NSString * cachePath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject];</span><br><span class="line">    // 这里先以获取 default  文件夹大小做实验，看看是否和 SDImageCache 获取的一样</span><br><span class="line">    NSString * directorPath = [cachePath stringByAppendingPathComponent:@&quot;default&quot;];</span><br><span class="line"></span><br><span class="line"> [self getFileSize:directorPath];</span><br></pre></td></tr></table></figure></p>
<p>上面的结果已经基本满足功能了。但是如果是遇到一个很大的文件夹的话，该操作可能会造成卡线程，所以最好能放到异步线程里去操作。由于是异步操作，这里就不适合用return 来返回结果了，可以用block的形式来传结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">- (void)getFileSize:(NSString *)directorPath completion:(void(^)(NSUInteger totoalSize))completion&#123;</span><br><span class="line"></span><br><span class="line">    //2.声明一个文件管理对象</span><br><span class="line">    NSFileManager * fileManager = [NSFileManager defaultManager];</span><br><span class="line">    //3.在 SDImageCache 的getSize 方法里面我们看到调用了一个方法  NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfItemAtPath:filePath error:nil];所以我们也模仿他去做</span><br><span class="line"></span><br><span class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">        //这个可以获取所有的子文件及子文件下的文件</span><br><span class="line">        NSArray * subPaths = [fileManager subpathsAtPath:directorPath];</span><br><span class="line">        NSUInteger totoalSize = 0 ;</span><br><span class="line">        for (NSString * path in subPaths) &#123;</span><br><span class="line">            NSString * filePath = [directorPath stringByAppendingPathComponent:path];</span><br><span class="line"></span><br><span class="line">            //判断是否是隐藏文件</span><br><span class="line">            if ([filePath containsString:@&quot;.DS&quot;]) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            //判断是否是文件夹</span><br><span class="line">            BOOL isDirector;</span><br><span class="line">            BOOL fileExist = [fileManager fileExistsAtPath:filePath isDirectory:&amp;isDirector];</span><br><span class="line">            if (!fileExist || isDirector) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            NSDictionary * attrs = [fileManager attributesOfItemAtPath:filePath error:nil];</span><br><span class="line">            //4.最后获取size</span><br><span class="line">            totoalSize += [attrs fileSize];</span><br><span class="line">        &#125;</span><br><span class="line">        //完成之后回调</span><br><span class="line">        //这里需要在主线程去回调。不然接收不到值。这里可以用同步操作，不会太耗时</span><br><span class="line">        dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            if (completion) &#123;</span><br><span class="line">                completion(totoalSize);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到这一步已经可以完成了。不过我们还可以在完善一点，因为我们永远无法想象用户会做什么操作。同样我们将这样的方法丢给同事去调用，也无法去想象他们会传一些什么稀奇古怪的参数，比如，他直接给你传个文件的路径而不是文件夹，所以我们还得加一些异常处理，比如抛异常，就像苹果经常干的那样。<br>最终我们修改后的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">- (void)getFileSize:(NSString *)directorPath completion:(void(^)(NSUInteger totoalSize))completion&#123;</span><br><span class="line"></span><br><span class="line">    //2.声明一个文件管理对象</span><br><span class="line">    NSFileManager * fileManager = [NSFileManager defaultManager];</span><br><span class="line"></span><br><span class="line">    // 在这里做一些异常的处理</span><br><span class="line">    //判断是否是文件夹</span><br><span class="line">    BOOL isDirector;</span><br><span class="line">    BOOL fileExist = [fileManager fileExistsAtPath:directorPath isDirectory:&amp;isDirector];</span><br><span class="line">    if (!fileExist || !isDirector) &#123;</span><br><span class="line">       NSException * exception = [NSException exceptionWithName:@&quot;PathError&quot; reason:@&quot;hey,man,这里需要的是一个文件夹的路径，并且是存在的&quot; userInfo:nil];</span><br><span class="line">        [exception raise];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //3.在 SDImageCache 的getSize 方法里面我们看到调用了一个方法  NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfItemAtPath:filePath error:nil];所以我们也模仿他去做</span><br><span class="line"></span><br><span class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">        //这个可以获取所有的子文件及子文件下的文件</span><br><span class="line">        NSArray * subPaths = [fileManager subpathsAtPath:directorPath];</span><br><span class="line">        NSUInteger totoalSize = 0 ;</span><br><span class="line">        for (NSString * path in subPaths) &#123;</span><br><span class="line">            NSString * filePath = [directorPath stringByAppendingPathComponent:path];</span><br><span class="line"></span><br><span class="line">            //判断是否是隐藏文件</span><br><span class="line">            if ([filePath containsString:@&quot;.DS&quot;]) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            //判断是否是文件夹</span><br><span class="line">            BOOL isDirector;</span><br><span class="line">            BOOL fileExist = [fileManager fileExistsAtPath:filePath isDirectory:&amp;isDirector];</span><br><span class="line">            if (!fileExist || isDirector) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            NSDictionary * attrs = [fileManager attributesOfItemAtPath:filePath error:nil];</span><br><span class="line">            //4.最后获取size</span><br><span class="line">            totoalSize += [attrs fileSize];</span><br><span class="line">        &#125;</span><br><span class="line">        //完成之后回调</span><br><span class="line">        //这里需要在主线程去回调。不然接收不到值。这里可以用同步操作，不会太耗时</span><br><span class="line">        dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            if (completion) &#123;</span><br><span class="line">                completion(totoalSize);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在调用的时候传入一个错误的地址，正如我们所料，Xcode崩了，在控制台出来结果如下：<br><img src="http://upload-images.jianshu.io/upload_images/972822-98f810968b0b9fed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>OK，可以收工了。</p>
<p>#清除缓存</p>
<blockquote>
<p>清楚缓存相对比较简单，直接贴代码吧:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)removeFiles:(NSString *)directorPath&#123;</span><br><span class="line">     NSFileManager * manager = [NSFileManager defaultManager];</span><br><span class="line">    //这个方法是获取该文件下的所有子文件夹，不会获取子文件夹里的文件(这里没必要了，直接删除文件夹就可以)</span><br><span class="line">    NSArray * subDirectors = [manager contentsOfDirectoryAtPath:directorPath error:nil];</span><br><span class="line">    for (NSString * path in subDirectors) &#123;</span><br><span class="line">        NSString * filePath = [directorPath stringByAppendingPathComponent:path];</span><br><span class="line">        //删除文件夹</span><br><span class="line">        [manager removeItemAtPath:filePath error:nil];</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS 项目小知识点]]></title>
      <url>/Blog/2017/02/05/iOS%20%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      <content type="html"><![CDATA[<p>[toc]</p>
<h1 id="自定义控件"><a href="#自定义控件" class="headerlink" title="自定义控件"></a>自定义控件</h1><blockquote>
<p>在- (instancetype)initWithFrame:(CGRect)frame<br>里自定义控件<br>在- (void)layoutSubviews  里布局控件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">名字叫attributes并且是NSDictionary *类型的参数，它的key一般都有以下规律</span><br><span class="line"> 1.iOS7开始</span><br><span class="line"> 1&gt; 所有的key都来源于： NSAttributedString.h</span><br><span class="line"> 2&gt; 格式基本都是：NS***AttributeName</span><br><span class="line"> 2.iOS7之前</span><br><span class="line"> 1&gt; 所有的key都来源于： UIStringDrawing.h</span><br><span class="line"> 2&gt; 格式基本都是：UITextAttribute***</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  NSString * title = [button currentTitle]; // 获取按钮当前title文字</span><br><span class="line">  CGSize size = [title sizeWithAttributes:@&#123;NSFontAttributeName:button.titleLabel.font&#125;];//根据字体计算大小</span><br><span class="line">_titleUnderLine.backgroundColor = [titleButton titleColorForState:UIControlStateSelected]; //根据按钮title 颜色设置下划线颜色</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="cell分割线顶头操作"><a href="#cell分割线顶头操作" class="headerlink" title="cell分割线顶头操作"></a>cell分割线顶头操作</h1><h2 id="1-第一种方法，利用系统的属性去设置"><a href="#1-第一种方法，利用系统的属性去设置" class="headerlink" title="1.第一种方法，利用系统的属性去设置"></a>1.第一种方法，利用系统的属性去设置</h2><blockquote>
<p>项目中经常会有些需求是cell 的分割线顶头，而系统默认的是前面有一定的间距，其实这是由一个separatorInset 属性造成的(iOS7以后出的)，通过打印：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidAppear:(BOOL)animated</span><br><span class="line">&#123;</span><br><span class="line">    NXLog(@&quot;margin:%@&quot;,NSStringFromUIEdgeInsets(self.tableView.separatorInset));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line">margin:&#123;0, 15, 0, 0&#125;   //可以看出来系统默认有一个15的偏移量</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将该属性设置为空，现在tableView里面设置：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> self.tableView.separatorInset = UIEdgeInsetsZero; //分隔线顶头，这个只是设置tableView 顶头，还需要在cell里设置cell的顶头</span><br><span class="line">通过这一步设置发现分割线比之前左移了不少，但是还没顶到头，这里就判断是cell自身的原因</span><br></pre></td></tr></table></figure>
<blockquote>
<p>同时在cell 里面进行设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.separatorInset = UIEdgeInsetsZero;//cell分割线顶头</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>这时候运行再看结果，已经OK顶到头。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/972822-494914586ad9f117.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<h2 id="tableView底层实现"><a href="#tableView底层实现" class="headerlink" title="tableView底层实现"></a>tableView底层实现</h2><blockquote>
<p>1.tableView 先把所有cell 的尺寸计算好，保存到一个数组里。<br>2.当cell 要显示的时候就拿到这个cell 去设置frame : cell.frame = frames[row]。</p>
</blockquote>
<h2 id="2-第二种方法，重写cell-的setFrame-可以随意设置cell-的间距，比较万能。"><a href="#2-第二种方法，重写cell-的setFrame-可以随意设置cell-的间距，比较万能。" class="headerlink" title="2.第二种方法，重写cell 的setFrame,可以随意设置cell 的间距，比较万能。"></a>2.第二种方法，重写cell 的setFrame,可以随意设置cell 的间距，比较万能。</h2><blockquote>
<p>主要思路：主要就是利用了上面的tableView 的实现原理。<br>1.首先设置tableView的背景色为分割线的颜色。<br>2.禁掉系统的分割线<br>3.在cell类中重写setFrame 方法。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> self.tableView.backgroundColor = NXColor(220, 220, 221);</span><br><span class="line"> self.tableView.separatorStyle = UITableViewCellSeparatorStyleNone;</span><br><span class="line"></span><br><span class="line">//在自定义的cell类中：</span><br><span class="line">- (void)setFrame:(CGRect)frame</span><br><span class="line">&#123;</span><br><span class="line">    NXLog(@&quot;cellFrame:%@&quot;,NSStringFromCGRect(frame));</span><br><span class="line">    //因为之前的frame 都是计算好的，这是在要显示的时候去设置一下，所以这里只去将高度减1，不会影响到其他尺寸</span><br><span class="line">    frame.size.height -=1;  // 如果想要间距更大的话可以 -=10 等，随意这种方法比较万能</span><br><span class="line">    //这个才是系统真正的设置frame。重写了这个方法会将系统的frame清空，所以需要调用这个</span><br><span class="line">    [super setFrame:frame];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="屏幕适配"><a href="#屏幕适配" class="headerlink" title="屏幕适配"></a>屏幕适配</h1><blockquote>
<p>1.一个view从Xib 加载，需不需要重新固定一下尺寸？    这个是一定得需要的，比较保险。<br>2.一般添加xib view的时候是在viewDidLoad 里面加载，但是设置尺寸frame  最好在viewDidLayoutSubViews  里面去设置。因为viewDidLoad 并不会去布局frame ，只是拿到xib 设置的大小属性，只有在 viewDidLayoutSubViews 里才会去根据布局去确定控件的最终尺寸(不过添加view 的操作不能放在这里，因为这个方法会调用多次)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">🌰：</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    UIView * loginView = [NXLoginRegistView loginView];</span><br><span class="line">    [self.middleView addSubview:loginView];</span><br><span class="line">    UIView * registView = [NXLoginRegistView registView];</span><br><span class="line">    [self.middleView addSubview:registView];</span><br><span class="line">    UIView * fastLogin = [NXFastLoginView fastLoginView];</span><br><span class="line">    [self.bottomView addSubview:fastLogin];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLayoutSubviews</span><br><span class="line">&#123;</span><br><span class="line">    [super viewDidLayoutSubviews];</span><br><span class="line">    //在这里面设置尺寸</span><br><span class="line">    UIView * loginView = [self.middleView subviews][0];</span><br><span class="line">    loginView.frame = CGRectMake(0, 0, self.middleView.frame.size.width * 0.5, self.middleView.frame.size.height);</span><br><span class="line">    UIView * registView = [self.middleView subviews][1];</span><br><span class="line">    registView.frame = CGRectMake(self.middleView.frame.size.width * 0.5, 0, self.middleView.frame.size.width * 0.5, self.middleView.frame.size.height);</span><br><span class="line">    UIView * fastLogin = [self.bottomView subviews][0];</span><br><span class="line">    fastLogin.frame = CGRectMake(0, 0, self.bottomView.frame.size.width, self.bottomView.frame.size.height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="从Xib加载的view-设置动画"><a href="#从Xib加载的view-设置动画" class="headerlink" title="从Xib加载的view 设置动画"></a>从Xib加载的view 设置动画</h1><blockquote>
<p>是通过操作约束去设置，比如要修改x值产生动画就找到x的约束拖线添到类文件中成为属性，然后对该属性进行操作，在设置动画时，必须加上这句 ：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.view layoutIfNeeded]; //这句话很重要，只有重新布局才会产生动画效果，否则没有动画效果</span><br></pre></td></tr></table></figure>
<blockquote>
<p>例如</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[UIView animateWithDuration:1 animations:^&#123;</span><br><span class="line">        self.testViewWidthConstraint.constant = 200;</span><br><span class="line">        [self.view layoutIfNeeded]; //这句话很重要，只有重新布局才会产生动画效果，否则没有动画效果</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h1 id="一个xib文件可以管理多个view"><a href="#一个xib文件可以管理多个view" class="headerlink" title="一个xib文件可以管理多个view"></a>一个xib文件可以管理多个view</h1><h1 id="重写button-的布局"><a href="#重写button-的布局" class="headerlink" title="重写button 的布局"></a>重写button 的布局</h1><blockquote>
<p>这个在项目中也很常见，默认的按钮布局是左右布局，即左边imageView + 右边label 。而好多项目中需要的是上下布局，所以需要自定义button，重新布局。这里在layoutSubViews 方法里面进行，因为在这个方法里面所有的控件尺寸都已经是计算好的，我们就不需要重新去计算，只要改一下布局就可以。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">🌰：</span><br><span class="line">- (void)layoutSubviews</span><br><span class="line">&#123;</span><br><span class="line">    [super layoutSubviews];</span><br><span class="line">    self.imageView.nx_y = 0;</span><br><span class="line">    self.imageView.nx_centerX = self.nx_centerX;</span><br><span class="line">    self.titleLabel.nx_y = self.nx_height - self.titleLabel.nx_height;</span><br><span class="line">    self.titleLabel.nx_centerX = self.nx_centerX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="自定义tabBar的问题"><a href="#自定义tabBar的问题" class="headerlink" title="自定义tabBar的问题"></a>自定义tabBar的问题</h1><blockquote>
<p>项目中需要定制tabBar 的时候需要用到自定义tabBar,这里需要注意的是不能直接通过如下的赋值语法进行替换：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">🌰：</span><br><span class="line">   NXTabBar * nTabBar = [[NXTabBar alloc]init];</span><br><span class="line">   self.tabBar = nTabBar;</span><br><span class="line">这样替换的话是没有效果的，需要用KVC 的形式进行替换：</span><br><span class="line"></span><br><span class="line"> [self setValue:nTabBar forKey:@&quot;tabBar&quot;];</span><br></pre></td></tr></table></figure>
<h1 id="iOS类私有属性的访问和修改"><a href="#iOS类私有属性的访问和修改" class="headerlink" title="iOS类私有属性的访问和修改"></a>iOS类私有属性的访问和修改</h1><p><a href="http://www.jianshu.com/p/a667f0ce9573" target="_blank" rel="noopener">http://www.jianshu.com/p/a667f0ce9573</a></p>
<h1 id="iOS-类别中添加属性（属性和实例变量的区别）"><a href="#iOS-类别中添加属性（属性和实例变量的区别）" class="headerlink" title="iOS 类别中添加属性（属性和实例变量的区别）"></a>iOS 类别中添加属性（属性和实例变量的区别）</h1><p><a href="http://www.cnblogs.com/crazypebble/p/3439261.html" target="_blank" rel="noopener">【转】iOS中属性与成员变量的区别</a><br><a href="http://www.jianshu.com/p/535d1574cb86" target="_blank" rel="noopener">iOS Category中添加属性和成员变量的区别</a></p>
<h1 id="通过category-和-runtime-设置textField-的-placehold-的颜色"><a href="#通过category-和-runtime-设置textField-的-placehold-的颜色" class="headerlink" title="通过category 和 runtime 设置textField 的 placehold  的颜色"></a>通过category 和 runtime 设置textField 的 placehold  的颜色</h1><blockquote>
<p>项目中经常会用到textField ，比如登录注册等。默认的光标是蓝色，而且placeholder的文字颜色也是灰的，不会变化。有时候项目会需求点击后光标为白色，同时placeholder 的文字高亮为白色(或其他颜色)。通过头文件一级一级往上查找，找到了一个如下属性:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property(nullable, nonatomic,copy)   NSAttributedString     *attributedPlaceholder</span><br></pre></td></tr></table></figure>
<blockquote>
<p>利用这个属性，用如下方法进行颜色修改：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//第一个参数: 需要被设置属性的字符串</span><br><span class="line">//第二个参数: 需要设置的属性</span><br><span class="line">   self.attributedPlaceholder = [[NSAttributedString alloc]initWithString:self.placeholder attributes:@&#123;NSForegroundColorAttributeName:[UIColor whiteColor]&#125;];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个方法虽然达到效果了，但是比较麻烦，通过如下图的方式，随便写一个textField ,然后打上短点，我们可以看到在textField 内部有placeholderLabel的属性，所以可以尝试通过对该属性进行操作，直接修改颜色。不过通过下面的调试框可以看到这是一个私有属性。想要对私有属性进行访问和修改可以使用kvc 或者 runtime ,这里使用kvc ,新建一个类别，添加属性placeholderColor,在set 方法里面去进行设置：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">🌰：</span><br><span class="line">h 文件</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface UITextField (NXTextField)</span><br><span class="line">@property (nonatomic ,strong)UIColor *placeholdColor;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">m 文件</span><br><span class="line">- (void)setPlaceholdColor:(UIColor *)placeholdColor</span><br><span class="line">&#123;</span><br><span class="line">    //根据判断，textField 内部的 placehold  是一个label 的标签</span><br><span class="line"></span><br><span class="line">    UILabel * placeholderLabel = [self valueForKey:@&quot;placeholderLabel&quot;];</span><br><span class="line">    placeholderLabel.textColor = placeholdColor;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">- (UIColor *)placeholdColor&#123;</span><br><span class="line">    return nil;  // 暂时先不用，返回一个nil ，去掉系统的警告⚠️</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>然后可以在需要设置的地方引入category 的头文件，通过如下方式即可设置颜色：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.placeholdColor = [UIColor lightGrayColor];</span><br></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/972822-438449526306909c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<blockquote>
<p>通过上面category 的方式基本可以满足需求，但是如果textField 如下设置的时候就会出现无效：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 这样设置是可以的：</span><br><span class="line">  self.placeholder = @&quot;44444&quot;;</span><br><span class="line">  self.placeholdColor = [UIColor lightGrayColor];</span><br><span class="line"></span><br><span class="line">//将上面的换个顺序执行，就会无效:</span><br><span class="line"> self.placeholdColor = [UIColor lightGrayColor];</span><br><span class="line"> self.placeholder = @&quot;44444&quot;;</span><br><span class="line"></span><br><span class="line">//这是因为之前没有设置placeholder文字，设置颜色的时候通过断点可以看到，此时获取不到placeholderLabel,所以导致设置颜色无效。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解决这个问题就需要用到runtime<br>1.先将 placeholderColor 保存起来<br>2.在设置placeholder 的时候再取出来设置颜色</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (void)setPlaceholdColor:(UIColor *)placeholdColor</span><br><span class="line">&#123;</span><br><span class="line">    //先将placeholdColor 存起来</span><br><span class="line">    //参数一：给哪个对象添加成员属性</span><br><span class="line">    //参数二：成员属性的名字</span><br><span class="line">    //参数三：成员属性的值</span><br><span class="line">    objc_setAssociatedObject(self, @&quot;placeholdColor&quot;, placeholdColor, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line"></span><br><span class="line">    //根据判断，textField 内部的 placehold  是一个label 的标签</span><br><span class="line"></span><br><span class="line">    UILabel * placeholderLabel = [self valueForKey:@&quot;placeholderLabel&quot;];</span><br><span class="line">    placeholderLabel.textColor = placeholdColor;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">- (UIColor *)placeholdColor&#123;</span><br><span class="line">    return objc_getAssociatedObject(self, @&quot;placeholdColor&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//自顶一个setPlaceholder方法，在内部1.先设置文字。 2.设置颜色</span><br><span class="line">- (void)setNX_Placeholder:(NSString *)placeholder</span><br><span class="line">&#123;</span><br><span class="line">    self.placeholder = placeholder;</span><br><span class="line">    self.placeholdColor = self.placeholdColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面方法有个缺点就是每次设置placeholder文字还得去调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self setNX_Placeholder:@&quot;hhhh&quot;];</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>所以想要直接通过:    <strong> self.placeholder = @”hhhh”; </strong>去设置，就需要用到方法交换。因为交换只需要做一次操作，所以，放到<strong>+(void)load</strong>方法里去操作,在category文件中加入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load&#123;</span><br><span class="line">    Method setPlaceholder = class_getInstanceMethod(self, @selector(setPlaceholder:));</span><br><span class="line">    Method setNx_Placeholder = class_getInstanceMethod(self, @selector(setNX_Placeholder:));</span><br><span class="line">    method_exchangeImplementations(setPlaceholder, setNx_Placeholder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="计算总行数的万能公式"><a href="#计算总行数的万能公式" class="headerlink" title="计算总行数的万能公式"></a>计算总行数的万能公式</h1><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">row = (count -1 ) / column +1;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="tableView-调整cell-间距"><a href="#tableView-调整cell-间距" class="headerlink" title="tableView  调整cell 间距"></a>tableView  调整cell 间距</h1><blockquote>
<p>用storyBoard 拖出来的cell 默认显示的是如下图的间距(因为要使用到静态单元格，所以用到storyBoard,一般情况下用xib最好)<br><img src="http://upload-images.jianshu.io/upload_images/972822-1b72dbea6ce3c123.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
</blockquote>
<p>这里用的是分组style，所以可以通过设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.tableView.sectionFooterHeight = 0;</span><br><span class="line"> self.tableView.sectionHeaderHeight = 0;</span><br></pre></td></tr></table></figure></p>
<p>得到如下效果:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/972822-13edc8b059e545ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>可以看到每个分组之间的间距已经没了，但是第一个cell 距离顶部还是有好大一部分距离，这里判断可能是tableView 的间距,通过下面打印</p>
<p><img src="http://upload-images.jianshu.io/upload_images/972822-ae86d387b8e4f8e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>可以看到tableView 距离顶部确实有64 的偏移量，但是这个刚好是空出导航栏的高度，所以排除是tableView 的问题，接下来就判断是cell 的问题，通过下面打印</p>
<p><img src="http://upload-images.jianshu.io/upload_images/972822-bc281de06bbc0996.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>可以看到分组内部第一个cell 的Y 值默认是35 ，那么这里可以在viewDidLoad 方法里进行如下调整就可以（这里需要间隔为10）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.tableView.sectionFooterHeight = 0;</span><br><span class="line"> self.tableView.sectionHeaderHeight = 10;</span><br><span class="line"> self.tableView.contentInset = UIEdgeInsetsMake(-25, 0, 0, 0);</span><br></pre></td></tr></table></figure></p>
<h1 id="跳转到网页"><a href="#跳转到网页" class="headerlink" title="跳转到网页"></a>跳转到网页</h1><blockquote>
<p>1.<code>Safari  openURL</code>  自带很多功能:进度条，刷新，前进，倒退等功能。但是需要跳出到当前应用。<br>2.<code>UIWebView</code>  在当前应用打开网页，并且带有Safari（自己实现），不能实现进度条。<br>3.<code>SFSafariViewController</code>   专门用来显示网页,既可以在当前应用显示网页，又可以有Safari的功能。iOS9以后才可以用。<br>4.WKWebView</p>
</blockquote>
<h1 id="判断view-是否被加载"><a href="#判断view-是否被加载" class="headerlink" title="判断view 是否被加载"></a>判断view 是否被加载</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">随便一个都可以:</span><br><span class="line">  UIViewController * vc = self.childViewControllers[button.tag];</span><br><span class="line">   if (vc.isViewLoaded) &#123;//如果已经被加载过就不重复加载(加载view  的时候会调用 viewDidLoad)</span><br><span class="line">            return ;</span><br><span class="line">    &#125;</span><br><span class="line">    UIView * view = vc.view;</span><br><span class="line">    if (view.superview) &#123; // 如果有父view ，说明已经被添加过</span><br><span class="line">            return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (view.window) &#123; //如果有容器，说明已经被添加过</span><br><span class="line">            return;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="一些全局常量，尽量使用extern来引用，其次再选择考虑Macro"><a href="#一些全局常量，尽量使用extern来引用，其次再选择考虑Macro" class="headerlink" title="一些全局常量，尽量使用extern来引用，其次再选择考虑Macro"></a>一些全局常量，尽量使用extern来引用，其次再选择考虑Macro</h1><blockquote>
<p><a href="http://www.cnblogs.com/oumygade/p/4316024.html" target="_blank" rel="noopener">iOS const的使用</a><br><a href="http://www.jianshu.com/p/ed2dfbca6e73" target="_blank" rel="noopener">关于全局常量的定义</a></p>
</blockquote>
<h1 id="xib-cell-拖线报错：-Terminating-app-due-to-uncaught-exception-‘NSUnknownKeyException’-reason-‘-setValue-forUndefinedKey-this-class-is-not-key-value-coding-compliant-for-the-key"><a href="#xib-cell-拖线报错：-Terminating-app-due-to-uncaught-exception-‘NSUnknownKeyException’-reason-‘-setValue-forUndefinedKey-this-class-is-not-key-value-coding-compliant-for-the-key" class="headerlink" title="xib cell 拖线报错： Terminating app due to uncaught exception ‘NSUnknownKeyException’, reason: ‘[ setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key"></a>xib cell 拖线报错： Terminating app due to uncaught exception ‘NSUnknownKeyException’, reason: ‘[<nsobject 0x8a4b500> setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key</nsobject></h1><blockquote>
<p>如下图，我已开始在File`s Owner里也设置了class是NXTopicCell,所以一直出错，这里吧他清空，设置下面的Topic Cell 的class如下就可以<br><img src="http://upload-images.jianshu.io/upload_images/972822-ab6ca235996cb993.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
</blockquote>
<blockquote>
<p>xib拖的UILabel 没有自动换行：设置约束时不要给定高度就可以自动换行了。</p>
</blockquote>
<p>#在heightForRowAtIndexPath获取cell 崩溃<br><a href="http://www.jianshu.com/p/3da539540d21" target="_blank" rel="noopener">http://www.jianshu.com/p/3da539540d21</a></p>
<blockquote>
<p>在网上看到有人是这么获取：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NXTopicCell * cell = (NXTopicCell *)[self tableView:tableView cellForRowAtIndexPath:indexPath];</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>试了下好像是可以。</p>
<blockquote>
<p>好像xib  里设置的高度是定死的，不会根据不同屏幕去重新计算高度。</p>
</blockquote>
<h2 id="退出键盘"><a href="#退出键盘" class="headerlink" title="退出键盘"></a>退出键盘</h2><blockquote>
<p>1.监听scrollView实时滚动代理方法调用[self.view endEditing:YES]或者[self.textField resignFirstResponse];<br>2.touchBegin方法里,调用[self.view endEditing:YES]或者[self.textField resignFirstResponse];</p>
</blockquote>
<h2 id="父View添加手势，子View不要去响应父View点击事件"><a href="#父View添加手势，子View不要去响应父View点击事件" class="headerlink" title="父View添加手势，子View不要去响应父View点击事件"></a>父View添加手势，子View不要去响应父View点击事件</h2><p><a href="http://www.it610.com/article/4821007.htm" target="_blank" rel="noopener">iOS 点击子视图不让其响应父视图手势</a></p>
<blockquote>
<p>在做这样一个界面的时候</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/972822-719483b12316733c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<blockquote>
<p>背景的蒙版层是一个UIView,按钮的列表View添加到背景的蒙版View上。在蒙版层添加一个手势，点击dismiss掉这个界面和蒙版。但是遇到问题就是在点击按钮列表的View的时候也出发了单击手势。这个好像是系统默认的，参考事件响应链。为了避免这种效果，在手势触发事件中可以判断当前点击事件是否在父View上，如果是子View上则不去做操作，点击在父View上才去做dismiss的操作。代码如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)dismissMoreActionView:(UITapGestureRecognizer *)tap</span><br><span class="line">&#123;</span><br><span class="line">    //根绝tag获取子view</span><br><span class="line">    UIView *subView = [self viewWithTag:100];</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     BOOL contains = CGRectContainsPoint(CGRect rect, CGPoint point);</span><br><span class="line">    判断一个CGRect是否包含再另一个CGRect里面,常用与测试给定的对象之间是否又重叠</span><br><span class="line"></span><br><span class="line">     - (CGPoint)locationInView:(UIView *)view：</span><br><span class="line">     该函数返回一个CGPoint类型的值，表示触摸在view这个视图上的位置，这里返回的位置是针对view的坐标</span><br><span class="line">    */    </span><br><span class="line">    // 判断手势点击的位置是不是包含在子视图上</span><br><span class="line">    if (!CGRectContainsPoint(subView.frame, [tap locationInView:self])) &#123;      </span><br><span class="line">        [self removeFromSuperview];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="调整导航栏leftBarButtonItem-和-rightBarbuttonItem-的偏移量"><a href="#调整导航栏leftBarButtonItem-和-rightBarbuttonItem-的偏移量" class="headerlink" title="调整导航栏leftBarButtonItem 和 rightBarbuttonItem 的偏移量"></a>调整导航栏leftBarButtonItem 和 rightBarbuttonItem 的偏移量</h2><p><a href="http://yikuwang.blog.51cto.com/6186082/1696156" target="_blank" rel="noopener"> 如何调整导航条上的leftBarButtonItem和rightBarButtonItem的位置</a></p>
<blockquote>
<p>####重点：<br>这里需要提到BarButtonSystemItem的样式－ UIBarButtonSystemItemFixedSpace<br>我不多说 请看官方解释:Blank space to add between other items. Only the <a href="https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIBarButtonItem_Class/index.html#//apple_ref/occ/instp/UIBarButtonItem/width" target="_blank" rel="noopener">width</a> property is used when this value is set.  反正我是看不懂 。再来说说negativeSpacer.width = 0 表示leftBarButtonItem的x离屏幕的左边还有15像素 同样表示rightBarButtonItem的CGRectGetMaxX()离屏幕的右边还有15像素 那么好像我们就可以通过negativeSpacer.width来调整leftBarButtonItem的位置。搞了老半天原来就是得靠这家伙。但有一点：negativeSpacer.width赋值负数对于leftBarButtonItem来说是左移多少像素 对于rightBarButtonItem来说是右移多少像素  反之亦然.</p>
</blockquote>
<p>我这里想要设置右边的item 右移一点，因为默认的太偏左了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">UIButton * buyBtn = [[UIButton alloc]init];</span><br><span class="line"></span><br><span class="line">    buyBtn.frame = CGRectMake(0, 0, 80, 40);</span><br><span class="line"></span><br><span class="line">    buyBtn.backgroundColor = [UIColor orangeColor];</span><br><span class="line"></span><br><span class="line">    [buyBtn setTitle:@&quot;马上选购&quot; forState:UIControlStateNormal];</span><br><span class="line"></span><br><span class="line">    buyBtn.titleLabel.font = [UIFont systemFontOfSize:15];</span><br><span class="line"></span><br><span class="line">    [buyBtn addTarget:self action:@selector(buyItemAction) forControlEvents:UIControlEventTouchUpInside];</span><br><span class="line"></span><br><span class="line">    UIBarButtonItem * buyItem = [[UIBarButtonItem alloc]initWithCustomView:buyBtn];</span><br><span class="line"></span><br><span class="line">    UIBarButtonItem * space = [[UIBarButtonItem alloc]initWithBarButtonSystemItem:UIBarButtonSystemItemFixedSpace target:nil action:nil];</span><br><span class="line">    space.width = -10;</span><br><span class="line"></span><br><span class="line">    self.navigationItem.rightBarButtonItems = @[space,buyItem];</span><br></pre></td></tr></table></figure></p>
<h2 id="动态修改UIButton的title-的时候字体闪烁的问题："><a href="#动态修改UIButton的title-的时候字体闪烁的问题：" class="headerlink" title="动态修改UIButton的title 的时候字体闪烁的问题："></a>动态修改UIButton的title 的时候字体闪烁的问题：</h2><p> <a href="http://blog.csdn.net/a330416020/article/details/41648787" target="_blank" rel="noopener">UIButton-system类型 动态改变title 显示文字时闪动(解决方案)</a></p>
<hr>
<h2 id="assign-修饰代理导致野指针的问题"><a href="#assign-修饰代理导致野指针的问题" class="headerlink" title="assign 修饰代理导致野指针的问题"></a>assign 修饰代理导致野指针的问题</h2><blockquote>
<p>在下面方法中调用了代理，崩溃指向这里显示野指针的错误，猜测是由于代理被释放而去调用产生的问题。点进去看到之前代理修饰用的是assign 修饰的，改为weak 后好像是可以了。猜测原因是由于assign 修饰的话 assign是指针赋值，不对引用计数操作，使用之后如果没有置为nil，可能就会产生野指针；而weak一旦不进行使用后，永远不会使用了，就不会产生野指针。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section</span><br><span class="line">&#123;</span><br><span class="line">     if ([_delegate respondsToSelector:@selector(numberOfRowsInTableView:Insection:FromView:)])</span><br><span class="line">     &#123;</span><br><span class="line">          NSInteger vRows = [_dataSource numberOfRowsInTableView:tableView Insection:section FromView:self];</span><br><span class="line">          mRowCount = vRows;</span><br><span class="line">          return vRows;</span><br><span class="line">     &#125;</span><br><span class="line">     return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单例问题"><a href="#单例问题" class="headerlink" title="单例问题"></a>单例问题</h2><blockquote>
<p>在使用单例的时候，经常性就是直接写出下面的代码。不过最近在使用的时候会遇到单例导致崩溃的问题。一开始在写 <code>dispatch_once_t once_token</code>的时候没有用static 来修饰，后来加上static来修饰就好了。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)shareInstance</span><br><span class="line">&#123;</span><br><span class="line">    static DrawTextView * drawText = nil;</span><br><span class="line"></span><br><span class="line">    static dispatch_once_t once_token;</span><br><span class="line"></span><br><span class="line">    dispatch_once(&amp;once_token, ^&#123;</span><br><span class="line"></span><br><span class="line">        drawText = [[DrawTextView alloc]initWithFrame:CGRectMake(kDeviceW * 0.5- TextLayerWidth * 0.5, kDeviceH * 0.5 - TextLayerHeight * 0.5, TextLayerWidth, TextLayerHeight)];</span><br><span class="line">        drawText.backgroundColor = [UIColor orangeColor];</span><br><span class="line">    &#125;);</span><br><span class="line">    return drawText;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在iPhone5s-（10-2系统）拨打电话没有弹框提示，其他手机（10-3）有弹框"><a href="#在iPhone5s-（10-2系统）拨打电话没有弹框提示，其他手机（10-3）有弹框" class="headerlink" title="在iPhone5s （10.2系统）拨打电话没有弹框提示，其他手机（10.3）有弹框"></a>在iPhone5s （10.2系统）拨打电话没有弹框提示，其他手机（10.3）有弹框</h2><p><code>`</code><br>//   用这种方法的话会出现上面的问题<br>//     NSString * phonNum = [NSString stringWithFormat:@”tel://%@”,self.footerModel.dav_phone];</p>
<pre><code>NSString * phonNum = [NSString stringWithFormat:@&quot;telprompt://%@&quot;, self.footerModel.dav_phone];
</code></pre><p>##控制器切换从下往上，并且有导航栏：</p>
<blockquote>
<p>可以用CATransition 动画，或者直接用presentModalViewController。<br><a href="http://www.cocoachina.com/bbs/read.php?tid=7668" target="_blank" rel="noopener">http://www.cocoachina.com/bbs/read.php?tid=7668</a></p>
</blockquote>
<p>##改变SearchBar 的取消按钮颜色，光标颜色</p>
<blockquote>
<p><a href="http://www.jianshu.com/p/66b5b777f5dc" target="_blank" rel="noopener">http://www.jianshu.com/p/66b5b777f5dc</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[微信小程序]]></title>
      <url>/Blog/2016/12/14/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h2 id="快速创建页面"><a href="#快速创建页面" class="headerlink" title="快速创建页面"></a>快速创建页面</h2><p><code>操作步骤说明
新建一个默认（HelloWorld）或者空白项目，或者打开自己的项；
假设我们要在根目录下创建一个页面，取名为：tianxiaxue；
打开微信小程序配置文件【app.json】，在&quot;pages&quot;:[]数据中写入一条页面路径；
同时按住电脑【Ctrl+S】保存。其他同理，需要创建某一路径的页面，可以通过输入页面路径快速创建；</code></p>
<h3 id="链接：快速创建页面及正则使用技巧"><a href="#链接：快速创建页面及正则使用技巧" class="headerlink" title="链接：快速创建页面及正则使用技巧"></a>链接：<a href="https://link.zhihu.com/?target=http%3A//www.wxapp-union.com/forum.php%3Fmod%3Dviewthread%26tid%3D1482%26highlight%3D%25E9%259D%25A2%25E5%2590%2591%25E6%2596%25B0%25E6%2589%258B" target="_blank" rel="noopener">快速创建页面及正则使用技巧</a></h3><a id="more"></a>
<h6 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h6><blockquote>
<ul>
<li>app.js 相当于Appdelegate , 是整个程序的入口</li>
<li>index.js/log.js 相当于是每个控制器viewController,对应每个页面逻辑</li>
<li>http/https : 协议, .com/.cn…. : 域名</li>
<li>当有APPID的情况下，进行网络通信，只能和指定的域名进行通信。如果没有进行配置，编译时会报如下错误：</li>
</ul>
</blockquote>
<p><img src="http://img.blog.csdn.net/20161115135942850" alt></p>
<p><code>在 iOS 上，小程序的 javascript 代码是运行在 JavaScriptCore 中
在 Android 上，小程序的 javascript 代码是通过 X5 内核来解析
在 开发工具上， 小程序的 javascript 代码是运行在 nwjs（chrome内核） 中。所以开发工具上的效果跟实际效果有所出入。</code></p>
<h5 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h5><p><img src="http://www.wxapp-union.com/data/attachment/portal/201612/12/011611l21b6p1xr6zeenh3.png" alt></p>
<blockquote>
<p>小程序包含一个描述整体程序的 app 和多个描述各自页面的 page。<br> 一个小程序主体部分由三个文件组成，必须放在项目的根目录，如下：</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">文件</th>
<th style="text-align:center">必须</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">app.js</td>
<td style="text-align:center">是</td>
<td style="text-align:center">小程序逻辑</td>
</tr>
<tr>
<td style="text-align:center">app.json</td>
<td style="text-align:center">是</td>
<td style="text-align:center">小程序公共设置</td>
</tr>
<tr>
<td style="text-align:center">app.wxss</td>
<td style="text-align:center">否</td>
<td style="text-align:center">小程序公共样式表，定义在 app.wxss 中的样式为全局样式，可用于任何Page。在 Page 里的 wxss 文件中定义的样式为局部样式，只作用在当前页面，并会覆盖 app.wxss 中相同的选择器</td>
</tr>
</tbody>
</table>
<blockquote>
<p>pages目录下为小程序页面，每个页面须建立独立的文件夹，例如上面生成的小程序有两个页面，分别为pages/index、pages/logs，一个页面由四个文件组成，分别是：</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">文件</th>
<th style="text-align:left">必须</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">js</td>
<td style="text-align:left">是</td>
<td>页面逻辑</td>
</tr>
<tr>
<td style="text-align:center">wxml</td>
<td style="text-align:left">是</td>
<td>页面结构</td>
</tr>
<tr>
<td style="text-align:center">wxss</td>
<td style="text-align:left">否</td>
<td>页面样式表</td>
</tr>
<tr>
<td style="text-align:center">json</td>
<td style="text-align:left">否</td>
<td>页面配置</td>
</tr>
</tbody>
</table>
<h6 id="page-json"><a href="#page-json" class="headerlink" title="page.json"></a>page.json</h6><blockquote>
<p>每一个小程序页面也可以使用.json文件来对本页面的窗口表现进行配置。 页面的配置比app.json全局配置简单得多，只是设置 app.json 中的 window 配置项的内容，页面中配置项会覆盖 app.json 的 window 中相同的配置项。</p>
</blockquote>
<blockquote>
<p>页面的.json只能设置 window 相关的配置项，以决定本页面的窗口表现，所以无需写 window 这个键，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;navigationBarBackgroundColor&quot;: &quot;#ffffff&quot;,</span><br><span class="line">  &quot;navigationBarTextStyle&quot;: &quot;black&quot;,</span><br><span class="line">  &quot;navigationBarTitleText&quot;: &quot;微信接口功能演示&quot;,</span><br><span class="line">  &quot;backgroundColor&quot;: &quot;#eeeeee&quot;,</span><br><span class="line">  &quot;backgroundTextStyle&quot;: &quot;light&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h3><blockquote>
<p><a href="http://www.wxappclub.com/topic/734" target="_blank" rel="noopener">从0到1：初学者入门Demo</a></p>
</blockquote>
<blockquote>
<p><a href="http://www.wxapp-union.com/article-713-1.html" target="_blank" rel="noopener">微信小程序框架详解《一》配置文件及其支持的配置属性</a></p>
</blockquote>
<blockquote>
<p><a href="http://www.wxapp-union.com/article-402-1.html" target="_blank" rel="noopener">CTT团队实战教程系列《一》小安娜B站系列：准备与事先须知</a></p>
</blockquote>
<blockquote>
<p><a href="http://www.wxapp-union.com/article-465-1.html" target="_blank" rel="noopener">程序员开发实战系列《二》微信小程序架构篇</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 小程序 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSS]]></title>
      <url>/Blog/2016/12/01/css/</url>
      <content type="html"><![CDATA[<h2 id="CSS选择器-selectors"><a href="#CSS选择器-selectors" class="headerlink" title="CSS选择器(selectors)"></a>CSS选择器(selectors)</h2><p>引用.css布局:<br><img src="/assets/445BE7FD-6066-4D86-B0E4-8BDD24100808.png" alt></p>
<h3 id="资料：-HTML-Tag-link"><a href="#资料：-HTML-Tag-link" class="headerlink" title="资料： HTML Tag: link"></a>资料： <a href="http://htmldog.com/references/html/tags/link/" target="_blank" rel="noopener">HTML Tag: link</a></h3><a id="more"></a>
<blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">选择器</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1.</td>
<td style="text-align:center">*</td>
<td style="text-align:left">通用元素选择器，匹配任何元素</td>
</tr>
<tr>
<td style="text-align:center">2.</td>
<td style="text-align:center">E</td>
<td style="text-align:left">标签选择器，匹配所有使用E标签的元素</td>
</tr>
<tr>
<td style="text-align:center">3.</td>
<td style="text-align:center">.info</td>
<td style="text-align:left">class选择器，匹配所有class属性中包含info的元素</td>
</tr>
<tr>
<td style="text-align:center">4.</td>
<td style="text-align:center">#footer</td>
<td style="text-align:left">id选择器，匹配所有id属性等于footer的元素</td>
</tr>
</tbody>
</table>
<h4 id="一个标签可以有多个类选择器，不同的值用空格隔开，这样多个样式便可以应用的一个标签上，如"><a href="#一个标签可以有多个类选择器，不同的值用空格隔开，这样多个样式便可以应用的一个标签上，如" class="headerlink" title="一个标签可以有多个类选择器，不同的值用空格隔开，这样多个样式便可以应用的一个标签上，如:"></a>一个标签可以有多个类选择器，不同的值用空格隔开，这样多个样式便可以应用的一个标签上，如:</h4><p><code>&lt;div class=&quot;style1 style2&quot;&gt;多个类选择器&lt;/div&gt;</code></p>
</blockquote>
<h3 id="资料："><a href="#资料：" class="headerlink" title="资料："></a>资料：</h3><h4 id="CSS选择器笔记"><a href="#CSS选择器笔记" class="headerlink" title="CSS选择器笔记"></a><a href="http://www.ruanyifeng.com/blog/2009/03/css_selectors.html" target="_blank" rel="noopener">CSS选择器笔记</a></h4><h4 id="css选择器优先级深入理解"><a href="#css选择器优先级深入理解" class="headerlink" title="css选择器优先级深入理解"></a><a href="http://www.jb51.net/css/67029.html" target="_blank" rel="noopener">css选择器优先级深入理解</a></h4><h4 id="10-CSS选择器-小码哥的笔记"><a href="#10-CSS选择器-小码哥的笔记" class="headerlink" title="10-CSS选择器(小码哥的笔记)"></a><a href="http://www.jianshu.com/p/01017ee7b08b" target="_blank" rel="noopener">10-CSS选择器(小码哥的笔记)</a></h4><h2 id="CSS属性"><a href="#CSS属性" class="headerlink" title="CSS属性"></a>CSS属性</h2><h3 id="margin-属性"><a href="#margin-属性" class="headerlink" title="margin 属性"></a><a href="http://www.w3school.com.cn/cssref/pr_margin.asp" target="_blank" rel="noopener">margin 属性</a></h3><p><code>margin 属性接受任何长度单位，可以是像素、英寸、毫米或 em。</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例子1：</span><br><span class="line">margin:10px 5px 15px 20px;</span><br></pre></td></tr></table></figure>
<ul>
<li>上外边距是 10px</li>
<li>右外边距是 5px</li>
<li>下外边距是 15px</li>
<li>左外边距是 20px</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例子2：</span><br><span class="line">margin:10px 5px 15px;</span><br></pre></td></tr></table></figure>
<ul>
<li>上外边距是 10px</li>
<li>右外边距和左外边距是 5px</li>
<li>下外边距是 15px</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例子3：</span><br><span class="line">margin:10px 5px;</span><br></pre></td></tr></table></figure>
<ul>
<li>上外边距和下外边距是 10px</li>
<li>右外边距和左外边距是 5px</li>
</ul>
<h3 id="float"><a href="#float" class="headerlink" title="float"></a><a href="http://www.w3school.com.cn/cssref/pr_class_float.asp" target="_blank" rel="noopener">float</a></h3><p><code>float 属性定义元素在哪个方向浮动</code></p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>left</td>
<td>元素向左浮动。</td>
</tr>
<tr>
<td>right</td>
<td>元素向右浮动。</td>
</tr>
<tr>
<td>none</td>
<td>默认值。元素不浮动，并会显示在其在文本中出现的位置。</td>
</tr>
<tr>
<td>inherit</td>
<td>规定应该从父元素继承 float 属性的值。</td>
</tr>
</tbody>
</table>
<h3 id="background-size-属性"><a href="#background-size-属性" class="headerlink" title="background-size 属性"></a><a href="http://www.w3school.com.cn/cssref/pr_background-size.asp" target="_blank" rel="noopener">background-size 属性</a></h3><p><code>规定背景图像的尺寸</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">background:url(img_flwr.gif);</span><br><span class="line">background-size:80px 60px;</span><br><span class="line">background-repeat:no-repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CSS元素显示模式转换"><a href="#CSS元素显示模式转换" class="headerlink" title="CSS元素显示模式转换"></a>CSS元素显示模式转换</h2><ul>
<li><h4 id="如何转换CSS元素的显示模式"><a href="#如何转换CSS元素的显示模式" class="headerlink" title="如何转换CSS元素的显示模式?"></a>如何转换CSS元素的显示模式?</h4><ul>
<li><h6 id="设置元素的display属性"><a href="#设置元素的display属性" class="headerlink" title="设置元素的display属性"></a>设置元素的display属性</h6><ul>
<li>display取值</li>
<li>block 块级</li>
<li>inline 行内</li>
<li>inline-block 行内块级</li>
</ul>
</li>
<li><h6 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h6><ul>
<li>di display: inline;</li>
<li>db display: block;</li>
<li>dib display: inline-block;</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="块级元素和行内元素的区别"><a href="#块级元素和行内元素的区别" class="headerlink" title="块级元素和行内元素的区别?"></a>块级元素和行内元素的区别?</h4></li>
<li><h6 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h6><ul>
<li>独占一行<br>如果没有设置宽度, 那么默认和父元素一样宽</li>
<li>如果设置了宽高, 那么就按照设置的来显示</li>
</ul>
</li>
<li><h6 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h6><ul>
<li>不会独占一行</li>
<li>如果没有设置宽度, 那么默认和内容一样宽</li>
<li>行内元素是不可以设置宽度和高度的</li>
</ul>
</li>
<li><h6 id="行内块级元素"><a href="#行内块级元素" class="headerlink" title="行内块级元素"></a>行内块级元素</h6><ul>
<li>为了能够让元素既能够不独占一行, 又可以设置宽度和高度, 那么就出现了行内块级元素</li>
<li>不独占一行, 并且可以设置宽高</li>
</ul>
</li>
</ul>
<h2 id="网页布局方式——定位流"><a href="#网页布局方式——定位流" class="headerlink" title="网页布局方式——定位流"></a>网页布局方式——定位流</h2><p><code>默认情况下，所有的网页标签都是在标准流布局中</code></p>
<ul>
<li>从上到下，从做往右。</li>
</ul>
<p><code>脱离标准流的方法有：</code></p>
<ul>
<li>float属性</li>
<li>position属性和 left、right、top、bottom属性</li>
</ul>
<p><code>这里的各种定位都是相对各种流的，对于一个非前端来说，脑子里完全没有这些所谓流的概念，这里先插入一下所谓标准流，定位流的概念</code><a href="http://blog.sina.com.cn/s/blog_6970cb0c0102vxim.html" target="_blank" rel="noopener">css定位机制：标准流，定位和浮动</a>, <a href="http://www.caopeng.net/2011/02/what-is-the-normal-flow-of-css-standard-streams/" target="_blank" rel="noopener">什么是CSS普通流/标准流?</a></p>
<p><strong> 相对定位和绝对定位一般都是用来做覆盖效果的, 当看到某个元素覆盖在另外一个元素上时, 第一时间就要想到定位流 </strong></p>
<ul>
<li><h6 id="绝对定位使用口诀-子绝父相"><a href="#绝对定位使用口诀-子绝父相" class="headerlink" title="绝对定位使用口诀(子绝父相)"></a>绝对定位使用口诀(子绝父相)</h6><h2 id="资料-定位流-小码哥"><a href="#资料-定位流-小码哥" class="headerlink" title="资料: 定位流(小码哥)"></a>资料: <a href="http://www.jianshu.com/p/454a0eaa39ef" target="_blank" rel="noopener">定位流(小码哥)</a></h2></li>
</ul>
<h4 id="所有标签想要水平居中"><a href="#所有标签想要水平居中" class="headerlink" title="所有标签想要水平居中"></a>所有标签想要水平居中</h4><ul>
<li><code>行内标签和行内块级标签：在父标签中设置 text-align:center ;</code></li>
<li><code>块级标签：在自身设置：margin : 0 auto ;</code></li>
</ul>
<h4 id="所有标签垂直居中"><a href="#所有标签垂直居中" class="headerlink" title="所有标签垂直居中"></a>所有标签垂直居中</h4><ul>
<li><code>行内标签和行内块级标签：设置行高：line-height:100%;</code></li>
</ul>
<h2 id="HTML属性"><a href="#HTML属性" class="headerlink" title="HTML属性"></a>HTML属性</h2><h3 id="HTML-style-属性"><a href="#HTML-style-属性" class="headerlink" title="HTML style 属性"></a><a href="http://www.w3school.com.cn/tags/att_standard_style.asp" target="_blank" rel="noopener">HTML style 属性</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">style 属性将覆盖任何全局的样式设定</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">在 HTML 文档中使用 style 属性：</span><br><span class="line">&lt;h1 style=&quot;color:blue; text-align:center&quot;&gt;This is a header&lt;/h1&gt;</span><br><span class="line">&lt;p style=&quot;color:red&quot;&gt;This is a paragraph.&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Flex布局属性"><a href="#Flex布局属性" class="headerlink" title="Flex布局属性"></a>Flex布局属性</h2><blockquote>
<p><a href="http://zh.learnlayout.com/position.html" target="_blank" rel="noopener">position</a></p>
<p><a href="http://zh.learnlayout.com/float.html" target="_blank" rel="noopener">float</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">Flex 布局教程：语法篇</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="noopener">Flex 布局教程：实例篇</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2009/02/basic_html_template_and_css_styling_part_i.html" target="_blank" rel="noopener">HTML模板和CSS基准样式（一）</a></p>
</blockquote>
<h2 id="集锦："><a href="#集锦：" class="headerlink" title="集锦："></a>集锦：</h2><blockquote>
<p><code>&lt;a href=&quot;#&quot;&gt;</code>是链接到本页，因为你有的时候需要有个链接<br> 的样式，但是又不希望他跳转</p>
<p><a href="http://www.adminwang.com/css/90.html" target="_blank" rel="noopener">HTML标签元素的分类(行内标签、块级标签、行内块级标签)</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git]]></title>
      <url>/Blog/2015/10/01/git/</url>
      <content type="html"><![CDATA[<h2 id="一、git常用操作命令"><a href="#一、git常用操作命令" class="headerlink" title="一、git常用操作命令"></a>一、git常用操作命令</h2><a id="more"></a>
<ul>
<li><h4 id="使用git进行版本管理"><a href="#使用git进行版本管理" class="headerlink" title="使用git进行版本管理"></a>使用git进行版本管理</h4><ul>
<li><h5 id="进入到项目根目录"><a href="#进入到项目根目录" class="headerlink" title="进入到项目根目录"></a>进入到项目根目录</h5></li>
<li><h5 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h5></li>
<li><h5 id="git-add"><a href="#git-add" class="headerlink" title="git add ."></a>git add .</h5></li>
<li><h5 id="git-commit-m-‘初始化’"><a href="#git-commit-m-‘初始化’" class="headerlink" title="git commit -m ‘初始化’"></a>git commit -m ‘初始化’</h5></li>
</ul>
</li>
<li><h4 id="提交代码到远程仓库"><a href="#提交代码到远程仓库" class="headerlink" title="提交代码到远程仓库"></a>提交代码到远程仓库</h4><ul>
<li><h5 id="创建远程代码仓库"><a href="#创建远程代码仓库" class="headerlink" title="创建远程代码仓库"></a>创建远程代码仓库</h5></li>
<li><h5 id="添加远程仓库关联"><a href="#添加远程仓库关联" class="headerlink" title="添加远程仓库关联"></a>添加远程仓库关联</h5></li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin  远程仓库地址</span><br></pre></td></tr></table></figure>
<pre><code>* ##### 提交代码到远程仓库
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<hr>
<h6 id="备注：关于权限"><a href="#备注：关于权限" class="headerlink" title="备注：关于权限"></a>备注：关于权限</h6><ul>
<li><h6 id="使用用户名和密码"><a href="#使用用户名和密码" class="headerlink" title="使用用户名和密码"></a>使用用户名和密码</h6></li>
<li><h6 id="生成公钥和私钥。"><a href="#生成公钥和私钥。" class="headerlink" title="生成公钥和私钥。"></a>生成公钥和私钥。</h6><ul>
<li><h6 id="ssh-keygen"><a href="#ssh-keygen" class="headerlink" title="ssh-keygen"></a>ssh-keygen</h6></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><h4 id="本地打标签备份并提交标签"><a href="#本地打标签备份并提交标签" class="headerlink" title="本地打标签备份并提交标签"></a>本地打标签备份并提交标签</h4><ul>
<li><h5 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h5></li>
<li><h5 id="git-push-–tags"><a href="#git-push-–tags" class="headerlink" title="git push –tags"></a>git push –tags</h5></li>
</ul>
</li>
<li><h4 id="删除本地-远程标签"><a href="#删除本地-远程标签" class="headerlink" title="删除本地/远程标签"></a>删除本地/远程标签</h4><ul>
<li><h5 id="删除本地标签"><a href="#删除本地标签" class="headerlink" title="删除本地标签"></a>删除本地标签</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d 标签名称</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="删除远程"><a href="#删除远程" class="headerlink" title="删除远程"></a>删除远程</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin : 标签名称</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="二、cocoapods"><a href="#二、cocoapods" class="headerlink" title="二、cocoapods"></a>二、cocoapods</h2><h3 id="1-cocoapods的基本使用"><a href="#1-cocoapods的基本使用" class="headerlink" title="1.cocoapods的基本使用"></a>1.cocoapods的基本使用</h3><ul>
<li><h3 id="cocoapods的安装"><a href="#cocoapods的安装" class="headerlink" title="cocoapods的安装"></a>cocoapods的安装</h3><ul>
<li><h4 id="gem"><a href="#gem" class="headerlink" title="gem"></a>gem</h4></li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
