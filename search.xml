<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[事件]]></title>
    <url>%2F2019%2F08%2F23%2F%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[先占位]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js基础知识]]></title>
    <url>%2F2019%2F08%2F22%2Fjs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[学习是没有捷径的，所谓的捷径都会让你永远达不到巅峰； 每天的学习坚持做笔记（IT人记笔记和技术文档都用markdown） 经常复习：每周抽出两三天，每天抽出一到两个小时，把自己整理的学习笔记从头到尾过一遍 常用的渲染内核（渲染引擎）： webkit内核(V8引擎) 谷歌（必须安装） Safari 大部分国产浏览器(360/UC/QQ浏览器…) 安卓和IOS手机上的大部分浏览器（移动端开发无需考虑IE低版本） node（NODE是基于V8引擎渲染JS的平台或者环境） web view … Gecko内核 火狐浏览器 Trident内核 IE Presto内核 Opera（低版本使用的是这个内核，高版本用的也是webkit内核） … JS由三部分组成： ECMAScript(ES)：JS的基础语法与核心规范 DOM：document object model 文档对象模型，让JS能够操作页面中的DOM元素（HTML元素） BOM：browser object model 浏览器对象模型，让JS能够操作浏览器的 JS中定义变量的方式： 不管变量存储的值是什么类型的，统一用以下关键词都可以创建 var 创建变量 function 创建一个函数 let (这个及以下是ES6语法中创建变量) 创建变量 const 创建常量 class 创建类 import ES6中的模块导入 JS中的命名规范： 严格区分大小写：Test / test 是两个不同的变量 不能使用关键字和保留字 遵循驼峰命名法：一个名字由多个英文单词组成，第一个单词首字母小写，其余每一个有意义单词的首字母都要大写 命名使用：$/数字/字母/_ 数字不能作为名字的开始 建议命名的时候使用英文，而且用一些常用词组 … 12var _flag = true; //=&gt;下划线开头一般代表是全局变量（公用变量）var $flag; //=&gt;一般都代表基于JQ获取的信息（和类库框架有关系） JS中的数据类型【基本数据类型（值类型）】 数字 number 字符串 string 布尔 boolean 空 null 未定义 undefined 【引用数据类型】 对象数据类型 普通对象 数组对象 正则对象 日期对象 … 函数数据类型 1234567891011121314151617181 =&gt;number'1' =&gt;string 在JS中用单引号或者双引号包裹起来的都是字符串true / false =&gt;boolean 只有true和false两个值nullundeifned&#123; name:'珠峰', age:9&#125; =&gt;普通对象[12,23,34] =&gt;数组对象/^-?(\d|([1-9]\d+))(\.\d+)?$/ =&gt;正则对象function fn()&#123;&#125; =&gt;函数数据类型 JS中检测数据类型的方式 typeof 用来检测数据类型的运算符（常用）。 instanceof 检测当前实例是否隶属于某个类。 constructor 基于构造器，查找当前实例的构造函数。 Object.prototype.toString.call 调用基类Object原型上的toString方法，当方法执行的时候，让方法中的this变为要检测的值，返回当前值对应的类的信息。 ({}).toString.call(xx) 打印出效果和上面的 Object.prototype.toString.call 一样。 12345678910111213141516语法：typeof [value]返回值：返回的结果首先是一个字符串，其次字符串中包含了对应的数据类型，例如："number"/"string"/"boolean"/"undefined"/"object"/"function"【特殊】typeof null =&gt;"object" 虽然null是基本值，但是它的意思叫做“空对象指针”，所以检测的结果是对象（可以理解为typeof的BUG）基于typeof检测对象或者数组对象再或者正则对象，返回的结果都是“object”，也就是无法基于typeof判断当前对象是数组还是正则...（可以理解为typeof的局限性）【面试题】typeof typeof typeof []-&gt; typeof [] : "object"-&gt; typeof "object" : "string"-&gt; typeof "string" : "string"考察点：检测的结果首先是一个字符串 【数字类型 number】 除了常规数字，在JS中 NaN 也是number类型的 NaN：not a number 不是一个有效数字 123456789101112typeof NaN =&gt;"number"NaN==NaN =&gt;false NaN和任何值都不相等，和本身也不相等（不是一个数包含范围太广了）--我想知道num存储的值是否为有效数字,下面的代码实现不了，因为NaN和谁都不相等var num = ?;if(num==NaN)&#123; //=&gt;如果条件成立，则num存储的值不是有效数字（可惜这个条件永远都不会成立，不管num是啥）&#125; 如何检测一个值是否为有效数字?=&gt; isNaN：检测一个值是否不是有效数字，返回TRUE代表不是有效数字，FALSE代表是有效数字 1234567891011语法：isNaN([value])运作机制：当使用isNaN用来检测一个值是否为有效数字的时候，如果被检测的值不是数字类型，浏览器首先会把它转换为数字类型，然后再进行检测。isNaN('3') =&gt;false Number('3')-&gt;3 isNaN(3)-&gt;falseisNaN('3px') =&gt;true Number('3px')-&gt;NaN isNaN(NaN)-&gt;true 【布尔 boolean】 只有两个值：true / false 12345678910111213141516//=&gt;把其它数据类型的值转换为布尔类型：//=&gt;除了“NaN/0/''/null/undefined”这五个值会转换为FALSE,其余的都会转换为TRUE//=&gt;哪些情况需要把其它类型值转换为布尔呢？//[手动自己转]Boolean(0) =&gt;falseBoolean([]) =&gt;true!0 =&gt;true 叹号在这里是取反的意思（先转化为布尔类型然后再取反）!!0 =&gt;false 两个叹号只剩下转换为布尔类型了，等价于Boolean//[程序自己需要转换 =&gt;一般都是条件判断的时候]if(1)&#123; //=&gt;如果条件成立，执行大括号中的代码 //=&gt;浏览器会把1作为条件：把它转换为布尔的TRUE，条件成立&#125; 【对象数据类型 object】 对象都有一个特点：每一个对象都是由零到多组属性名和属性值（键值对 key:value）组成的 所谓的属性，其实可以理解为对象的特征，而属性值就是对特征的描述 12345678910111213141516171819202122232425var obj=&#123; name:'婉茹', age:18&#125;;//=&gt;操作对象的键值对1. 对象.属性2. 对象[属性]//=&gt;对象的属性名是字符串和数字格式的，属性值可以是任何数据类型//=&gt;获取obj.nameobj['name']//=&gt;增加/修改//=&gt;一个对象中的属性名是不能重复的，如果当前对象属性已经存在，我们属于修改属性值，不存在才是新增加属性obj['name']='明明'; //=&gt;修改obj['sex']='女'; //=&gt;新增//=&gt;删除[彻底删除：属性和属性值都没有了]delete obj.age / delete obj['age'][假删除：属性还在，只是值为空]obj['age']=null; //=&gt;赋值为null的原因：因为对象没有这个属性，默认获取的值是undefiend，假删除只是设置值为空，但是属性还在，我们最好不要设置为undefined，这样会和默认返回的结果冲突，无法区分到底是有没有这个属性 属性名可能是字符串，也可能是数字，不能是其它类型值（尤其是引用类型） 1234567891011121314151617obj[&#123;xxx:'xxx'&#125;]=100;=&gt;&#123; '[object Object]':100&#125;//=&gt;属性名还可以是数字var ary = [12,23,34];数组对象，我们看到的是属性值，属性名是默认生成的，而且有特点：1.属性名是数字2.数字是从零开始逐级递增的3.有一个字符串属性名length,代表数组的长度我们把数组中的数字属性名称之为“数组的索引”ary[0] =&gt;12ary.0 //=&gt;Uncaught SyntaxError: Unexpected number 语法错误，如果属性名是数字，我们则不能通过 对象.数字 方式来操作属性 12345678var key='name';var obj = &#123; key:100&#125;;obj.key -&gt;100 属性名为'KEY'obj['key'] -&gt;100 属性名为'KEY'obj[key] =&gt;这样写绝对不是获取属性名为KEY的值，因为此时的KEY不是字符串也不是数字，而是变量；KEY代表的是存储的值'name'，所以此处它的意思是 obj['name'] 基本类型值（值类型） VS 引用类型值123456789var n=10;var m=n;m=20;console.log(n);var a=&#123;name:'珠峰'&#125;;var b=a;b.name='培训';console.log(a.name); 123456var n=[12,23,34];var m=n;m[0]=100;m=[100];n[1]=200;console.log(n,m); 12345var obj=&#123; n:10, m:obj.n*10&#125;;console.log(obj.m); 值类型操作都是“按照值来操作的” 赋值的时候，也是直接的把这个值赋值给变量（或者说和变量关联） 一个变量把自己的值赋值给另外一个变量的时候，也是重新开辟一个新的位置，把原有变量存储的值放到新位置一份（新老位置各有相同的值，但是是独立分开的，没有关联），在把新位置上的值赋值给新变量 … 引用数据类型，操作的时候，都是按照“空间的引用地址来操作的” 首先不能像基本基本值一样在作用域中开辟位置存储，需要额外单独开辟一个新的空间（有一个16进制的地址，通过地址可以找到空间） 对于对象数据类型来说，它会把自己本身的键值对依次存储到这个空间中（对于函数来说，在空间中存储的是函数体中的代码字符串） 引用类型是按照引用地址来操作的，所以给变量赋的值是空间的地址，而不是对象本身，以后的操作都是通过地址找到空间然后再操作 12345678【堆占内存】在JS中有两个重要的内存：堆内存/栈内存- 栈内存 + 提供代码执行的环境 + 基本类型值都是直接的存储在栈内存中的- 堆内存 + 引用类型值都存储在堆内存中 1234567891011函数的运作机制：【创建函数】1. 函数也是引用类型值，首先开辟一个新的堆内存（16进制地址）2. 把函数体中实现功能的代码“当做字符串”存储到堆内存中3. 把堆内存的引用地址赋值给函数名（变量名）【执行函数】目的：把函数体中的JS代码执行，以此实现具体的功能和需求1. 首先开辟一个新的栈内存（私有作用域），提供JS代码执行赖以生存的环境2. 把原有在堆内存中存储的“字符串”，拿过来，放到新的栈内存中，变为真正的JS代码，自上而下执行 数据类型转换把其它数据类型值转换为数字类型 [把其它基本类型值转换为数字 =&gt; Number([value])] 基于parseInt/parseFloat/Number去手动转换为数字类型 数学运算：+ - * / %，但是“+”不仅仅是数学运算，还可能是字符串拼接 在基于“==”比较的时候，有时候也会把其它值转换为数字类型 … 123456789101112'3'-1 =&gt;2 Number('3')-&gt;3 3-1-&gt;2'3px'-1 =&gt;NaN'3px'+1 =&gt;'3px1' 字符串拼接var i='3';i=i+1; =&gt;'31'i+=1; =&gt;'31'i++; =&gt;4 i++就是单纯的数学运算，已经摒弃掉字符串拼接的规则 字符串-&gt;数字12345678910111213141516Number('1') : 1Number('-1.3') : -1.3Number('1px') : NaNNumber('') -&gt;0Number(' ') -&gt;0 空格(Space)Number('\n') -&gt;0 换行符(Enter)Number('\t') -&gt;0 制表符(Tab)如果字符串中出现任意一个非有效数字字符，则转换为数字的NaN``` #### 布尔-&gt;数字 ``` JavaScriptNumber(true) : 1Number(false) : 0 空-&gt;数字12Number(null) : 0Number(undefined) : NaN 把引用数据类型转换为数字1234567891011121314151617181920 =&gt;首先toString()把引用值转换为字符串 =&gt;其次调取Number()把字符串转换为数字] isNaN(&#123;name:'xxx'&#125;) -&gt;(&#123;name:'xxx'&#125;).toString() : "[object Object]" 所有普通都对象转换为字符串，结果都是它(客户扩展为啥？) -&gt;Number("[object Object]") : NaN isNaN([12,23]) -&gt;[12,23].toString() : '12,23' -&gt;Number('12,23') : NaN isNaN([]) -&gt;[].toString() : '' -&gt;Number('') : 0 isNaN([12]) -&gt;[12].toString() : '12' -&gt;Number('12') : 12 ... parseInt / parseFloat 1.Number把字符串转化数字，遇到一个非有效数字字符，结果就是NaN了，我们想要提取出字符串中有效数字的部分，需要使用 parseInt / parseFloat 两个方法 2.和Number的区别在于字符串转换分析上 3.Number：出现任意非有效数字字符，结果就是NaN 4.parseInt：把一个字符串中的整数部分解析出来，parseFloat是把一个字符串中小数(浮点数)部分解析出来 12345678910Number('1px') : NaNparseInt('1px') : 1parseInt('1.5px') : 1parseFloat('1.5px') : 1.5parseInt('width:1px') : NaN =&gt;从字符串最左边开始找，遇到一个非有效数字字符后就停止查找了（不管后面是否存在有效数字），把找到的变为数字，一个都没找到结果就是NaNparseInt('1px3') : 1思考题：parseInt支持两个参数（parseInt('10px',2)），这个是啥意思? 把其它类型值转换为字符串1.发生的情况 基于alert/confirm/prompt/document.write等方法输出内容的时候，会把输出的值转换为字符串，然后再输出。 1alert(1) =&gt;'1' 基于“+”进行字符串拼接的时候 把引用类型值转换为数字的时候，首先会转换为字符串，然后再转换为数字 给对象设置属性名，如果不是字符串，首先转换为字符串，然后再当做属性存储到对象中（对象的属性只能是数字或者字符串） 手动调用toString/toFixed/join/String等方法的时候，也是为了转换为字符串 12345var n=Math.PI;//=&gt;获取圆周率：n.toFixed(2) =&gt;'3.14'var ary=[12,23,34];ary.join('+') =&gt;'12+23+34' … 2.转换规律 123456789101112131415//=&gt;调用的方法：toString【除了对象，都是你理解的转换结果】1 -&gt;'1'NaN -&gt;'NaN'null -&gt;'null'[] -&gt;''[13] -&gt;'13'[12,23] -&gt;'12,23'...【对象】&#123;name:'xxx'&#125; -&gt;'[object Object]'&#123;&#125; -&gt;'[object Object]'不管是啥样的普通对象，最后结果都一样 把其它值转换为布尔类型1.发生的情况 基于!/!!/Boolean等方法转换 条件判断中的条件最后都会转换为布尔类型 … 1234567if(n)&#123; //=&gt;把n的值转换为布尔验证条件真假&#125;if('3px'+3)&#123; //=&gt;先计算表达式的结果'3px3'，把结果转换为布尔true，条件成立&#125; 2.转换的规律只有“0/NaN/&#39;&#39;/null/undefined”五个值转换为布尔的false,其余都是转换为true。 !0 =&gt;true 叹号在这里是取反的意思（先转化为布尔类型然后再取反） !!0 =&gt;false 两个叹号只剩下转换为布尔类型了，等价于Boolean 特殊情况：数学运算和字符串拼接 “+”12345678910111213//=&gt;当表达式中出现字符串，就是字符串拼接，否则就是数学运算1+true =&gt;2 数学运算'1'+true =&gt;'1true' 字符串拼接[12]+10 =&gt;'1210' 虽然现在没看见字符串，但是引用类型转换为数字，首先会转换为字符串，所以变为了字符串拼接(&#123;&#125;)+10 =&gt;"[object Object]10"[]+10 =&gt;"10"&#123;&#125;+10 =&gt;10 这个和以上说的没有半毛钱关系，因为它根本就不是数学运算，也不是字符串拼接，它是两部分代码 &#123;&#125; 代表一个代码块（块级作用域） +10 才是我们的操作 严格写法：&#123;&#125;; +10; 实例： 123456789101112131412+true+false+null+undefined+[]+'珠峰'+null+undefined+[]+true=&gt;'NaN珠峰nullundefinedtrue'12+true -&gt;1313+false -&gt;1313+null -&gt;1313+undefined -&gt;NaNNaN+[] -&gt;'NaN''NaN'+'珠峰' -&gt;'NaN珠峰'...'NaN珠峰trueundefined''NaN珠峰trueundefined'+[] -&gt;'NaN珠峰trueundefined'...=&gt;'NaN珠峰trueundefinedtrue' 特殊情况：“==”在进行比较的时候，如果左右两边的数据类型不一样，则先转换为相同的类型，再进行比较对象==对象：不一定相等，因为对象操作的是引用地址，地址不相同则不相等 123456&#123;name:'xxx'&#125;==&#123;name:'xxx'&#125; =&gt;false[]==[] =&gt;falsevar obj1=&#123;&#125;;var obj2=obj1;obj1==obj2 =&gt;true 比较规律： 不同情况的比较，都是把其它值转换为数字，然后再进行比较的。 对象==数字：把对象转换为数字 对象==布尔：把对象转换为数字，把布尔也转换为数字 对象==字符串：把对象转换为数字，把字符串也转换为数字 字符串==数字：字符串转换为数字 字符串==布尔：都转换为数字 布尔==数字：把布尔转换为数字 需要特殊记忆的特殊情况： null==undefined：true null===undefined：false null&amp;&amp;undefined和其它值都不相等 NaN==NaN：false NaN和谁都不相等包括自己 案例： 123456789101==true =&gt;true1==false =&gt;false2==true =&gt;false 规律不要混淆，这里是把true变为数字1[]==true：false 都转换为数字 0==1![]==true：false[]==false：true 都转换为数字 0==0![]==false：true 先算![]，把数组转换为布尔取反=&gt;false =&gt;false==false switch case JS中的一种判断方式 12345678910111213141516171819202122var num = 12;if(num==10)&#123; num++;&#125;else if(num==5)&#123; num--;&#125;else&#123; num=0;&#125;//=&gt;改成switch caseswitch(num)&#123; case 10: num++; break; case 5: num--; break; default: num=0; &#125;//=&gt;switch case 应用于变量（或者表达式等）在不同值情况下的不同操作，每一种case结束后都要加break（结束整个判断） switch case中每一种case情况的比较都是基于”===”绝对相等来完成的 === 绝对比较12345'10'==10 =&gt;true 相等比较,如果等号左右两边的类型不一样，首先会转换为一样的数据类型，然后再进行比较=&gt;当前案例中，就是把字符串'10'转换为数字了，然后再比较的'10'===10 绝对比较，如果两边的数据类型不一样，则直接不相等，它要求类型和值都完全一样才会相等（真实项目中为了保证代码的严谨性，我们应该更多使用绝对比较） FOR-IN循环 遍历一个对象中的键值对的，有多少组键值对，我们就遍历多少次。也支持BREAK和CONTINUE等关键词。 FOR-IN遍历的时候有自己的顺序：先遍历数字属性名（按照小-&gt;大），再遍历字符串属性名（按照书写顺序）。 123456789101112131415161718let obj = &#123;name: 'xxx', age: 27, 0: 0, sex: 0, score: 100, 1: 1&#125;;for (let attr in obj) &#123; console.log(attr);//=&gt;0 1 name age sex score&#125;/*//=&gt;obj.__proto__===Object.prototype : obj是Object这个类的一个实例//=&gt;大括号中的是OBJ的私有属性，Object.prototype上的是OBJ公有属性Object.prototype.bbbb = 1000;for (let key in obj) &#123; //=&gt;FOR-IN循环只遍历当前对象可枚举（可遍历）的属性 //1.对象的私有属性(自己写的)是可枚举的 //2.浏览器内置的属性一般都是不可枚举的 //3.自己在类的原型上设置的属性也是可枚举的,FOR-IN循环的时候也会被遍历出来（一般情况下我们是不想遍历到原型上的公有属性的） if (obj.hasOwnProperty(key)) &#123;//=&gt;一般使用FOR-IN在遍历对象的时候，我们加一个私有属性的验证，只有是私有的属性，我们才做操作 console.log(key); &#125;&#125; 数组扁平化 把多维数组变为一维数组。 面向对象的三大特性封装多态重载：方法名相同，参数的个数或者类型不同，此时名字相同的方法叫做方法的重载（后台语言中的重载），JS中不存在重载的。重写：子类重写父类的方法。 1234567891011 //=&gt;根据传递参数的不同执行不同的方法public void fn(int n,int m)&#123;&#125;public void fn(string n,string m)&#123;&#125;public void fn(int n,int m,int z)&#123;&#125;//iOS里面多态也是重载父类方法。 123456789// 但是JS中不能重载，只会覆盖function fn(n, m) &#123;&#125;function fn(n, m, x) &#123; //=&gt;后面的方法会把前面的方法覆盖掉，不管传递多少实参，执行的都是后面的这个方法（JS中的重载指的是：同一个方法根据传参不一样，实现不同的功能）&#125; 继承子类继承父类的属性和方法 原型继承 call继承 寄生组合继承 ES6中class类实现继承 原型继承定义：让子类的原型指向父类的一个实例。 1234567891011121314function A() &#123; this.x = 100;&#125;A.prototype = &#123; constructor: A, getX: function () &#123; console.log(this.x); &#125;&#125;;function B() &#123; this.y = 200;&#125;B.prototype = new A();let f = new B(); 原理和缺点 A的实例本来就具有父类A的私有属性和prototype上的共有方法，子类B的原型指向它，B的实例就可以访问这些属性和方法了。 JS子类继承父类，并不是把父类的属性方法完全克隆一份给子类的（这样子类和父类就是完全独立的两部分）。JS中的原型继承是让子类和父类建立原型链接的机制，子类的实例调取父类上的方法都是基于原型查找机制完成的。 存在问题：子类可以重写父类原型上的方法，子类和父类不够独立。 1B.prototype.__proto__.getX = null; // 这样A的实例也会受到影响。 call继承CALL继承： 把父类A做为普通函数执行，让A中的THIS变为B的实例，相当于给B的实例增加一些属性和方法（弊端：把父类A当做普通函数执行，和父类原型没啥关系了，仅仅是把A中的私有属性变为子类B实例的私有属性而已，A原型上的公有属性方法和B及它的实例没啥关系）。 123456789101112131415161718//new A() 把A作为类创建它的实例 this:实例//A() 把A作为普通函数执行 this:windowfunction A() &#123; //=&gt;this:f this.x = 100; //=&gt;f.x=100&#125;A.prototype = &#123; constructor: A, getX: function () &#123; console.log(this.x); &#125;&#125;;function B() &#123; //=&gt;this:f A.call(this);//=&gt;call继承 把A执行，让A中的this变为f this.y = 200;&#125;let f = new B(); 寄生组合继承1234567891011121314151617181920212223/* * Object.create：内置Object类天生自带的方法 * 1.创建一个空对象 * 2.让新创建的空对象的__proto__指向第一个传递进来的对象（把OBJ作为新创建空对象的原型） */ function A() &#123; this.x = 100;&#125;A.prototype = &#123; constructor: A, getX: function () &#123; console.log(this.x); &#125;&#125;;function B() &#123; A.call(this);//=&gt;基于CALL把A的私有变为B的私有 f.x=100 this.y = 200;&#125;// B.prototype = A.prototype; //=&gt;一般都不这样处理，因为这种模式可以轻易修改父类A原型上的东西（重写“太方便”了），这样会导致A的其它实例也受到影响B.prototype=Object.create(A.prototype);let f = new B(); ES6中的类和继承ES6中创建类是有自己标准语法的（这种语法创建出来的类只能NEW执行，不能当做普通函数执行）。 12345678910111213141516171819202122232425262728293031class A &#123; constructor() &#123; this.x = 100; &#125;//给A的原型上设置方法，写在这里（只能设置方法不能设置属性） getX() &#123; console.log(this.x); &#125; //=&gt;把AA当做一个普通对象设置的私有方法（和实例没有关系），同样也只能设置方法不能写属性 static AA()&#123; &#125;&#125;// 想要添加属性还是得以这样的方式A.prototype.BB = 100;class B extends A &#123;//=&gt;extends类似于实现了原型继承 constructor() &#123; super();//=&gt;类似于CALL继承：在这里SUPER相当于把A的CONSTRUCTOR给执行了，并且让方法中的THIS是B的实例，SUPER当中传递的实参都是在给A的CONSTRUCTOR传递 this.y = 200; &#125; getY() &#123; console.log(this.y); &#125;&#125;let f = new B(); 图片延迟加载函数柯里化]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CALayer position 和 anchorPoint 的问题]]></title>
    <url>%2F2017%2F08%2F29%2FCALayer%20position%20%E5%92%8C%20anchorPoint%20%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[概要： CALayer 的position白话来讲：position就是layer 自身的anchorPoint相对于父superLayer的坐标位置。常规说来，在iOS上，一个图层的position位于父图层的左上角具体概念参考：这将是你最后一次纠结position与anchorPoint 关于画曲线的角度参考图： 正文：需求是一个扫描匹配的动画： 如上展示的是最终的效果。这里主要用的是一个自定义view PulsingView，重写 (void)drawRect:(CGRect)rect方法，在这个方法内部去画相应的元素，主要包含： 1.外部扩散的脉冲layer。 2.雷达扫面的内圈layer。 3.雷达扫描的扇形layer。首先是外部的脉冲扩散动画实现：这个比较简单，参考网上的好多雷达扫描实现，PulsingView.m文件中 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142 [super drawRect:rect]; [[UIColor whiteColor] setFill]; UIRectFill(rect); UIImage * image = [UIImage imageNamed:@"radar_background"]; [image drawInRect:rect]; CGFloat pulsingWidth = rect.size.width / 2.5; CGFloat pulsingX = self.center.x - pulsingWidth * 0.5; CGFloat pulsingY = self.center.y - pulsingWidth * 0.5;// 脉冲layer CALayer * pulsingLayer = [CALayer layer]; pulsingLayer.frame = CGRectMake(pulsingX, pulsingY, pulsingWidth, pulsingWidth); pulsingLayer.borderColor = [UIColor colorWithRed:201/255.0 green:201/255.0 blue:201/255.0 alpha:1].CGColor; pulsingLayer.cornerRadius = pulsingWidth * 0.5; pulsingLayer.backgroundColor = [UIColor whiteColor].CGColor;//这里必须设置layer层的背景颜色，默认应该是透明的，导致设置的阴影颜色无法显示出来 pulsingLayer.shadowColor = [UIColor blackColor].CGColor; pulsingLayer.shadowOffset = CGSizeMake(0, 0); pulsingLayer.shadowOpacity = 1; pulsingLayer.shadowRadius = 5; [self.layer addSublayer:pulsingLayer]; // 缩放动画 CABasicAnimation * scaleAnimation = [CABasicAnimation animationWithKeyPath:@"transform.scale"]; scaleAnimation.autoreverses = false; scaleAnimation.fromValue = @1.0f; scaleAnimation.toValue = @2.0f; // 透明动画 CAKeyframeAnimation * opacityAnimation = [CAKeyframeAnimation animationWithKeyPath:@"opacity"]; opacityAnimation.keyTimes = @[@0,@0.1,@0.2,@0.3,@0.4,@0.5,@0.6,@0.7,@0.8,@0.9,@1]; opacityAnimation.values = @[@1,@0.9,@0.8,@0.7,@0.6,@0.5,@0.4,@0.3,@0.2,@0.1,@0]; CAAnimationGroup * animationGroup = [CAAnimationGroup animation]; animationGroup.beginTime = CACurrentMediaTime() + 1; animationGroup.fillMode = kCAFillModeBackwards; animationGroup.repeatCount = HUGE_VAL; animationGroup.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear]; animationGroup.duration = 2; animationGroup.animations = @[scaleAnimation,opacityAnimation]; [pulsingLayer addAnimation:animationGroup forKey:@"pulse"]; 这一步做完会出来如下效果： 接下来就是添加雷达的内圈layer,继续在上面的代码下面添加如下代码：123456789101112// 中间圆环CALayer * middleCycle = [CALayer layer];middleCycle.frame = CGRectMake(pulsingX, pulsingY, pulsingWidth, pulsingWidth);middleCycle.cornerRadius = pulsingWidth * 0.5;middleCycle.borderColor = [UIColor colorWithRed:41/255.0 green:152/255.0 blue:241/255.0 alpha:1].CGColor;middleCycle.backgroundColor = [UIColor whiteColor].CGColor;middleCycle.shadowOffset = CGSizeMake(0, 0);middleCycle.borderWidth = 1;middleCycle.shadowRadius = 3;middleCycle.shadowOpacity = 1;middleCycle.shadowColor = [UIColor lightGrayColor].CGColor;[self.layer addSublayer:middleCycle]; 。这里的坑也是出现在这块地方。因为在外部引用PulsingView的时候，设置的frame是控制器view的bounds,此时运行出来的结果如下： 接下来就是最后一步，添加扇形的layer 并添加扫描动画(一开始扇形是打算做成渐变的效果的，不过这里没有完美实现出来，一开始使用了一个三方XHRadarView,单纯的引用里面的扇形view的类，这样就可以直接使用他内部的渐变color，不过出来并不是很完美，所以还是自己画扇形，先不做渐变效果了。）此时就出现了关于position问题导致的坑. 这里一开的思路还是和之前一样，继续在self.layer上添加扇形的layer，以self.center为圆心，画一个90度的曲线： 12345678910CGPoint fanshapedCenter = self.center; UIBezierPath * fanshapedPath = [UIBezierPath bezierPath]; [fanshapedPath addArcWithCenter:fanshapedCenter radius:(pulsingWidth + 20) * 0.5 startAngle:3 * M_PI / 2 endAngle:0 clockwise:YES]; [fanshapedPath addLineToPoint:fanshapedCenter]; [fanshapedPath closePath]; CAShapeLayer * fanshapedLayer = [CAShapeLayer layer]; fanshapedLayer.path = fanshapedPath.CGPath; fanshapedLayer.opacity = 0.7; fanshapedLayer.fillColor = [UIColor colorWithRed:41/255.0 green:152/255.0 blue:241/255.0 alpha:1].CGColor; [self.layer addSublayer:fanshapedLayer]; 此时运行出来静态情况下的都没问题： 然后添加旋转动画，让扇形绕着圆心进行自转： 12345678CABasicAnimation *rotationAnimation = [CABasicAnimation animationWithKeyPath:@"transform.rotation.z"]; rotationAnimation.toValue = [NSNumber numberWithFloat: 3 * M_PI ]; rotationAnimation.duration = 8; rotationAnimation.cumulative = YES; rotationAnimation.removedOnCompletion = NO; rotationAnimation.repeatCount = MAXFLOAT; rotationAnimation.fillMode = kCAFillModeForwards; [fanshapedLayer addAnimation:rotationAnimation forKey:@"rotation"]; 然而运行出来的结果并没有和我们预期的一样： 仔细观察可以发现，扇形是在围绕着self的原点(0,0)点进行公转，一开始一直以为是画扇形的时候出的问题，是不是画法不对之类的，还试过直接用Quaritz2D 去画扇形，然而效果依然如此，经过各种查找，才发现是position 导致的问题，通过断点，打印一下hanshapedLayer可以看到如下信息： 12Printing description of fanshapedLayer:&lt;CAShapeLayer:0x608000233640; position = CGPoint (0 0); bounds = CGRect (0 0; 0 0); allowsGroupOpacity = YES; fillColor = &lt;CGColor 0x6080000bef00&gt; [&lt;CGColorSpace 0x600000228940&gt; (kCGColorSpaceICCBased; kCGColorSpaceModelRGB; sRGB IEC61966-2.1; extended range)] ( 0.160784 0.596078 0.945098 1 ); opacity = 0.7; path = &lt;CGPath 0x60800003bf20&gt;&gt; 可以看到hanshapedLayer的position 是 (0,0),也就是父控件的左上角原点，文章开头我们提到过，layer的position 就是自己anchorPoint 相对于父layer 的坐标，而layer自身旋转也是相对于anchorPoint 旋转，这也就解释了为什么我们上面会出现扇形绕着屏幕的最上角做公转。所以我们就需要将hanshapedLayer 的 position 移到中心点的位置： 1fanshapedLayer.position = fanshapedCenter; 此时我们再来看运行结果： 此时扇形确实是绕着中心点开始转了，但是并不是我们想要的结果。。。此时内心是崩溃的。所以放弃了这种动画的方式，直接将扇形fanshapedLayer添加到中间的内圈layer上，然后让内圈layer自转，最后可以实现最终的效果。 12345678910111213// 扫描的扇形 UIBezierPath * fanshapedPath = [UIBezierPath bezierPath]; [fanshapedPath addArcWithCenter:CGPointMake(middleCycle.frame.size.width * 0.5, middleCycle.frame.size.height * 0.5) radius:(pulsingWidth + 30) * 0.5 startAngle:3 * M_PI / 2 endAngle:0 clockwise:YES]; [fanshapedPath addLineToPoint:CGPointMake(middleCycle.frame.size.width * 0.5, middleCycle.frame.size.height * 0.5)]; CAShapeLayer * fanshaped = [CAShapeLayer layer]; fanshaped.fillColor = [UIColor colorWithRed:41/255.0 green:152/255.0 blue:241/255.0 alpha:1].CGColor; fanshaped.opacity = 0.7; [fanshapedPath closePath]; fanshaped.path = fanshapedPath.CGPath; [middleCycle addSublayer:fanshaped];然后将动画添加到middleCycle上： [middleCycle addAnimation:rotationAnimation forKey:@"rotation"]; 后来在简书上又看到以篇博客也遇到了公转的问题 CALayer旋转动画参考这位 渣孩子博主的作法，将画扇形的代码作如下修改： 12[fanshapedPath addArcWithCenter:CGPointZero radius:(pulsingWidth + 20) * 0.5 startAngle:3 * M_PI / 2 endAngle:0 clockwise:YES]; [fanshapedPath addLineToPoint:CGPointZero]; 现在原点位置画出扇形，然后再设置potisionfanshapedLayer.position = fanshapedCenter;最后终于解决了这个问题。 最后，贴上draw 方法里的全部代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798// An empty implementation adversely affects performance during animation.- (void)drawRect:(CGRect)rect &#123; // Drawing code [super drawRect:rect]; [[UIColor whiteColor] setFill]; UIRectFill(rect); UIImage * image = [UIImage imageNamed:@"radar_background"]; [image drawInRect:rect]; CGFloat pulsingWidth = rect.size.width / 2.5; CGFloat pulsingX = self.center.x - pulsingWidth * 0.5; CGFloat pulsingY = self.center.y - pulsingWidth * 0.5; // 脉冲layer CALayer * pulsingLayer = [CALayer layer]; pulsingLayer.frame = CGRectMake(pulsingX, pulsingY, pulsingWidth, pulsingWidth); pulsingLayer.borderColor = [UIColor colorWithRed:201/255.0 green:201/255.0 blue:201/255.0 alpha:1].CGColor; pulsingLayer.cornerRadius = pulsingWidth * 0.5; pulsingLayer.backgroundColor = [UIColor whiteColor].CGColor;//这里必须设置layer层的背景颜色，默认应该是透明的，导致设置的阴影颜色无法显示出来 pulsingLayer.shadowColor = [UIColor blackColor].CGColor; pulsingLayer.shadowOffset = CGSizeMake(0, 0); pulsingLayer.shadowOpacity = 1; pulsingLayer.shadowRadius = 5; [self.layer addSublayer:pulsingLayer]; // 缩放动画 CABasicAnimation * scaleAnimation = [CABasicAnimation animationWithKeyPath:@"transform.scale"]; scaleAnimation.autoreverses = false; scaleAnimation.fromValue = @1.0f; scaleAnimation.toValue = @2.0f; // 透明动画 CAKeyframeAnimation * opacityAnimation = [CAKeyframeAnimation animationWithKeyPath:@"opacity"]; opacityAnimation.keyTimes = @[@0,@0.1,@0.2,@0.3,@0.4,@0.5,@0.6,@0.7,@0.8,@0.9,@1]; opacityAnimation.values = @[@1,@0.9,@0.8,@0.7,@0.6,@0.5,@0.4,@0.3,@0.2,@0.1,@0]; CAAnimationGroup * animationGroup = [CAAnimationGroup animation]; animationGroup.beginTime = CACurrentMediaTime() + 1; animationGroup.fillMode = kCAFillModeBackwards; animationGroup.repeatCount = HUGE_VAL; animationGroup.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear]; animationGroup.duration = 2; animationGroup.animations = @[scaleAnimation,opacityAnimation]; [pulsingLayer addAnimation:animationGroup forKey:@"pulse"]; // 中间圆环 CALayer * middleCycle = [CALayer layer]; middleCycle.frame = CGRectMake(pulsingX, pulsingY, pulsingWidth, pulsingWidth); middleCycle.cornerRadius = pulsingWidth * 0.5; middleCycle.borderColor = [UIColor colorWithRed:41/255.0 green:152/255.0 blue:241/255.0 alpha:1].CGColor; middleCycle.backgroundColor = [UIColor whiteColor].CGColor; middleCycle.shadowOffset = CGSizeMake(0, 0); middleCycle.borderWidth = 1; middleCycle.shadowRadius = 3; middleCycle.shadowOpacity = 1; middleCycle.shadowColor = [UIColor lightGrayColor].CGColor; [self.layer addSublayer:middleCycle]; // 添加到self.layer上 CGPoint fanshapedCenter = self.center; UIBezierPath * fanshapedPath = [UIBezierPath bezierPath]; [fanshapedPath addArcWithCenter:CGPointZero radius:(pulsingWidth + 20) * 0.5 startAngle:3 * M_PI / 2 endAngle:0 clockwise:YES]; [fanshapedPath addLineToPoint:CGPointZero]; [fanshapedPath closePath]; CAShapeLayer * fanshapedLayer = [CAShapeLayer layer]; fanshapedLayer.path = fanshapedPath.CGPath; fanshapedLayer.opacity = 0.7; fanshapedLayer.position = fanshapedCenter; fanshapedLayer.fillColor = [UIColor colorWithRed:41/255.0 green:152/255.0 blue:241/255.0 alpha:1].CGColor; [self.layer addSublayer:fanshapedLayer]; // 添加到middleCycle上// [fanshapedPath addArcWithCenter:CGPointMake(0,0) radius:(pulsingWidth + 20) * 0.5 startAngle:3 * M_PI / 2 endAngle:0 clockwise:YES];// [fanshapedPath addLineToPoint:CGPointZero];// CAShapeLayer * fanshaped = [CAShapeLayer layer];// fanshaped.fillColor = [UIColor colorWithRed:41/255.0 green:152/255.0 blue:241/255.0 alpha:1].CGColor;// fanshaped.opacity = 0.7;// fanshaped.position = CGPointMake(middleCycle.frame.size.width * 0.5, middleCycle.frame.size.height * 0.5);// [fanshapedPath closePath];// fanshaped.path = fanshapedPath.CGPath;// [middleCycle addSublayer:fanshaped];// NSLog(@"fanshaped==== frame:%@,anchorPoint:%@,bounds:%@,position:%@",NSStringFromCGRect(fanshaped.frame),NSStringFromCGPoint(fanshaped.anchorPoint),NSStringFromCGRect(fanshaped.bounds),NSStringFromCGPoint(fanshaped.position)); CABasicAnimation *rotationAnimation = [CABasicAnimation animationWithKeyPath:@"transform.rotation.z"]; rotationAnimation.toValue = [NSNumber numberWithFloat: 3 * M_PI ]; rotationAnimation.duration = 8; rotationAnimation.cumulative = YES; rotationAnimation.removedOnCompletion = NO; rotationAnimation.repeatCount = MAXFLOAT; rotationAnimation.fillMode = kCAFillModeForwards; // [middleCycle addAnimation:rotationAnimation forKey:@"rotation"]; [fanshapedLayer addAnimation:rotationAnimation forKey:@"rotation"];&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杂记]]></title>
    <url>%2F2017%2F08%2F27%2F%E6%9D%82%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[世界那么大，我想去看看 hexo 常用命令： 123456hexo new postName #新建文章 在source/_posts 下生成hexo new page pageName #新建页面 在source/pageName 下生成hexo deploy #将.deploy目录部署到GitHub 简写指令：hexo dhexo generate #生成静态页面至public目录 简写指令：hexo ghexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）简写指令hexo shexo clean #清除所有静态页面和缓存数据 next 文档：http://theme-next.iissnan.com/getting-started.html 网站改动-加入背景特效 &amp; 自定义页面存放特定文章]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2017%2F07%2F12%2Ftest%2F</url>
    <content type="text"><![CDATA[note: Atom MarkDown文件编辑快捷键：contorl + shift + M 进入预览模式 父目录 ####### 我是子目录 我是孙子目录 删除本地索引库文件1pod repo remove xxxlib 有时候想要改变本地的索引库名称，可以用这个删除掉之前的，然后通过 pod repo add newName git地址来设置新的名称。 事件响应链 寻找最合适的view ####### 我是子目录 我是孙子目录 当一个事件传递给view 的时候会调用 1- (UIView *)hitTest:(CGPOint)point withEvent:(UIEvent *)event; 判断当前点在不在调用的view 的身上。 他是在hitTest方法中调用的。 1- (BOOL)pointInsid:(CGPOint)point withEvent:(UIEvent *)event; 1.先去判断当前的View 是不是控制器的View,如果当前的View是控制器的View，那么，它的上一个响应链就是它所在的控制器 2.如果当前View 不是控制器的View ,那么父控件就是上一个响应链。 #pragma mark - C语言数组动态内存分配数组的缺点： 数组长度必须事先制定，且只能是常整数，不能是变量。 🌰12int a[5] = &#123;1,2,3,4,5&#125;; // 正确int length = 5; a[length]; // error 传统形式定义的数组，程序员无法手动释放该数组的内存。在一个函数运行期间，该函数为该数组分配的空间会一直存在，直到该函数运行完毕，数组的空间才会被释放。 数组的长度不能在函数运行的过程中动态的扩充和缩小。]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript]]></title>
    <url>%2F2017%2F06%2F27%2Fjavascript%2F</url>
    <content type="text"><![CDATA[JavaScript基础 1.JavaScript 包含:ECMA,DOM和BOM。2.JavaScript 的基础类型有number,string和boolean (这些都是小写)。3.JavaScript的复合类型有Number,Array,Date,String,Boolean,RegExp,Math,还有两个核心类型Object和Function。4.JavaScript map 和 reduce“不要使用JavaScript内置的parseInt()函数，利用map和reduce操作实现一个string2int()函数” 123456789101112131415161718function str2Int(s)&#123; // map 是针对数组使用的，所以这里需要先将s转换成字符串数组 // split() 方法用于把一个字符串分割成字符串数组。 var aStr = s.split(&apos;&apos;); // 这里得到的数组里面的元素还是单个字符串，需要转换成数字类型，才能进行reduce 操作 var iArr = aStr.map(x=&gt;+x); return iArr.reduce((x,y)=&gt;x * 10 + y); &#125;// 使用 if(str2Int.toString().indexOf(&apos;parseInt&apos;)!==-1)&#123; alert(&apos;不能使用parseInt&apos;) &#125;else if(str2Int(&apos;123&apos;)===123 &amp;&amp; str2Int(&apos;1500&apos;) === 1500 &amp;&amp; str2Int(&apos;1201&apos;)===1201) &#123; alert(&apos;验证通过&apos;); &#125;else&#123; alert(&apos;验证不通过&apos;); &#125; 参考：Javascript中字符串转数字 JavaScript split() 方法]]></content>
  </entry>
  <entry>
    <title><![CDATA[工作中的坑]]></title>
    <url>%2F2017%2F04%2F01%2F%E5%B7%A5%E4%BD%9C%E4%B8%AD%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[1.通过xib加载的控件在viewDidLoad 中重新计算布局不准确的问题在爱山门实时上门模块，由于之前没有加网络提示器或者没网的空白页之类的，在网络情况差的情况下，直接就是一个空白页放在那里，用户体验特别不好，所以这里需要加上一个网络的提示器在加载的时候进行弹窗提示用户，记载成功的话就直接显示数据，失败的话就提示网络问题。这个直接用SVProgress就可以。由于这里的界面布局比较固定，所以最好可以再做一个本地缓存，利用FMDB将上一次的数据存到本地，下次打开的话先从数据库去获取数据，没有的话再去网络请求。这里遇到了一个问题，折腾了大半个上午。就是每次通过本地缓存去加载数据的时候滑动范围总是不准，在viewDidLoad中已经计算好了scrollView 的高度和tableView 的高度，但是在viewDidDissAppear 中再去打印的话会发现尺寸并不是我们计算的那个结果。下拉刷新或者直接去加载网络的数据的时候就没问题。后来一直调试查找猜测应该是xib 的问题，因为这里的scrollView 和 tableView 都是通过xib 去加载的，通过xib 加载的文件在viewDidLoad中加载的时候并不会去布局frame ，只是拿到xib 中设置的大小属性，只有在 viewDidLayoutSubViews 里才会去根据布局去确定控件的最终尺寸(不过添加view 的操作不能放在这里，因为这个方法会调用多次) 2.导航栏隐藏 push 到下个界面再手势返回的时候显示和隐藏的问题。如下： 好多项目中都会有这样的需求，导航栏透明或者隐藏，但是push 到下一个界面，如果用手势返回的话就会出现如上的问题， 比如积分商城：个人中心界面需要隐藏导航栏，设置如下：12345678- (void)viewWillAppear:(BOOL)animated&#123; [super viewWillAppear:animated]; [self.navigationController setNavigationBarHidden:YES animated:animated]; [self getCenter];&#125; 点击积分商城需要显示导航栏，设置如下：12345678910- (void)viewWillAppear:(BOOL)animated&#123; [super viewWillAppear:animated];// [Glob showTabBar]; [[self rdv_tabBarController] setTabBarHidden:YES animated:YES]; [self.navigationController setNavigationBarHidden:NO animated:YES];&#125; 如果只是这样设置的话手势返回的话就会出现上面的问题。网上找了各种资料和三方库，比如 让我们一次性解决导航栏的所有问题 ),由于之前项目中使用的tabBar 是 三方的RDVTabBarController，所以用上面文章中的三方总会出先手势返回的时候上一个控制器被一个空白的UIView挡住的情况。所以又开始找其他的同样不是很完美。最后抱着瞎猫碰死耗子的心态，就试试网上的一些建议，采用如下写法，在积分商城界面加上如下代码：12345- (void)viewWillDisappear:(BOOL)animated&#123; [self.navigationController setNavigationBarHidden:NO animated:YES]; [super viewWillDisappear:animated] ; // 切记要加这个，不然没效果&#125; 一开始在一个空白的项目中做了测试，这样确实是可以了，但是放到公司项目却还是没用，一开始怀疑是 [super viewWillDisappear:animated]方法应该放在最后调用，后来测试放在前面和后面都没区别。最后发现问题是在个人中心界面，一开始个人中心界面隐藏导航栏的时候，动画那块设置的是NO：1[self.navigationController setNavigationBarHidden:YES animated:NO]; 最后改成如下：123[self.navigationController setNavigationBarHidden:YES animated:animated];至于这里的animated 写成 没有写成YES OR NO 是因为在网上看到过系统返回的属性不只是这两个（虽然我也不懂）不过这里animated 写成YES 也可以。 发现可以正常使用了。效果如下： Perfect!更新后来发现只需要在个人中心设置1[self.navigationController setNavigationBarHidden:YES animated:animated] // 这里animated 写成YES 也可以 不用再在其他界面再添加12345- (void)viewWillDisappear:(BOOL)animated&#123; [self.navigationController setNavigationBarHidden:NO animated:YES]; [super viewWillDisappear:animated] ; // 切记要加这个，不然没效果&#125; 也一样可以实现效果 3.使用字典转模型的时候遇到崩溃 NSInvalidArgumentException -[__NSTaggedPointerString unsignedLongLongValue]: unrecognized selector sent to instance 这个问题，是因为64bit中，NSString 中没有unsignedLongLongValue这个方法了， 而当字典中obj的类型是NSString类型，实体中的key对应的属性是NSUinteger类型，setValue:obj forKey:key 会自动做如下处理：[obj unsignedLongLongValue] 将value转为对应的属性类型，这就导致64bit中找不到该方法而crash。解决是，对NSString写一个category，重新写一个unsignedLongLongValue的方法： 123-(NSUinteger)unsignedLongLongValue &#123; return [self integerValue];&#125; 或者 避免 让系统做NSString-&gt;NSUInteger的类型装换]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清除缓存]]></title>
    <url>%2F2017%2F02%2F07%2F%E6%B8%85%E9%99%A4%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[现在的大多数APP都带有缓存功能，尤其是使用一些第三方框架，比如SDWebImage 就自带缓存功能。当用了一段时间后，缓存就会越来愈大，如果不清除的话就会影响用户体验和性能，所以大多📚APP加了清除缓存的功能。这里的主要实现思路也是根据SDWebImage 的思路去实现。这里需要用到一个 simpholders工具可以直接查看沙盒下的东西。 #1.获取缓存 既然是参考SDWebImage去实现，那么首先就是进去看看他是怎么实现的，首先先导入 #import &lt;SDWebImage/SDImageCache.h&gt;头文件，这是SDWebImage 的一个管理缓存的类，点进去在文件中搜索关键词cache,会看到好多结果，一直往下拉，会看到这么几个方法： 1234567我们看到里面有这样一个方法，很明显这个是我们常写的单例。待会儿会用到/** * Returns global shared cache instance * * @return SDImageCache global instance */+ (SDImageCache *)sharedImageCache; 再往下就看到下面的方法： 这些根据字面意思很容易看出来都是干什么的。既然这里我们的第一步是想先获取缓存，那么我们就主要先看一下getSize方法，点击进去会看到如下方法： 123456789101112- (NSUInteger)getSize &#123; __block NSUInteger size = 0; dispatch_sync(self.ioQueue, ^&#123; NSDirectoryEnumerator *fileEnumerator = [_fileManager enumeratorAtPath:self.diskCachePath]; for (NSString *fileName in fileEnumerator) &#123; NSString *filePath = [self.diskCachePath stringByAppendingPathComponent:fileName]; NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfItemAtPath:filePath error:nil]; size += [attrs fileSize]; &#125; &#125;); return size;&#125; 这里我们看到需要用到一个 _fileManager的对象，这是一个NSFileManager 的对象,我们先回到我们的类文件中，去调用一下getSize 方法获取缓存。通过上面的工具我们可以查看SDWebImage的缓存文件：在default文件下面就是 12345 NSUInteger cach = [[SDImageCache sharedImageCache] getSize]; NXLog(@&quot;sdweb-----caches:%lu&quot;,(unsigned long)cach);打印结果如下2017-02-06 23:41:09.554 BaiSi[44360:1314372] sdweb-----caches:2824429 通过右键查看文件，得到结果如下，比打印结果大是因为这里还包括了隐藏文件.DS 我们也以获取这个文件夹缓存的大小为试验，看看自己写的结果是否和SD 的一样：12345678910111213141516- (void)clearCach&#123; //1.先获取cache 目录的路径 NSString * cachePath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject]; // 这里先以获取 default 文件夹大小做实验，看看是否和 SDImageCache 获取的一样 NSString * directorPath = [cachePath stringByAppendingPathComponent:@&quot;default&quot;]; //2.声明一个文件管理对象 NSFileManager * fileManager = [NSFileManager defaultManager]; //3.在 SDImageCache 的getSize 方法里面我们看到调用了一个方法 NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfItemAtPath:filePath error:nil];所以我们也模仿他去做 NSDictionary * attrs = [fileManager attributesOfItemAtPath:directorPath error:nil]; //4.最后获取size NSUInteger size = [attrs fileSize]; NXLog(@&quot;custom----size:%lu&quot;,(unsigned long)size); //打印结果如下 // 2017-02-06 23:47:01.843 BaiSi[44442:1317486] custom----size:136&#125; 可以看到最后的结果和SD差了相当多，初步判断这个可能不可以获取文件夹的大小，智能或许文件的大小，为了验证，我们拼接一个文件的路径，在上面第一步获取路径下面再加上一个image 的路径，如下：12345NSString * imagePath = [directorPath stringByAppendingPathComponent:@&quot;com.hackemist.SDWebImageCache.default/aa96232fe024aeba562815618fd5e02a.jpg&quot;];第三步里的directorPath 改成 imagePath ,运行//打印结果如下：2017-02-07 00:00:04.244 BaiSi[44688:1326243] custom----size:169817 我们直接通过查看图片属性结果如下： 和我们得到的结果一模一样，说明该属性方法只是获取文件的大小，所以我们需要遍历目的文件夹下的所有文件，将大小累加起来，就是该文件夹的总大小。在SD 的 getSize 方法里面我们可以看到他调用的是 NSDirectoryEnumerator *fileEnumerator = [_fileManager enumeratorAtPath:self.diskCachePath];方法，然后去遍历fileEnumerator。这里我们可以用另一个属性subpathsAtPath:directorPath，改写clearCach如下：1234567891011121314151617181920212223- (void)clearCach&#123; //1.先获取cache 目录的路径 NSString * cachePath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject]; // 这里先以获取 default 文件夹大小做实验，看看是否和 SDImageCache 获取的一样 NSString * directorPath = [cachePath stringByAppendingPathComponent:@&quot;default&quot;]; //2.声明一个文件管理对象 NSFileManager * fileManager = [NSFileManager defaultManager]; //3.在 SDImageCache 的getSize 方法里面我们看到调用了一个方法 NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfItemAtPath:filePath error:nil];所以我们也模仿他去做 //这个可以获取所有的子文件及子文件下的文件 NSArray * subPaths = [fileManager subpathsAtPath:directorPath]; NXLog(@&quot;subPaths:%@&quot;,subPaths); NSDictionary * attrs = [fileManager attributesOfItemAtPath:directorPath error:nil]; //4.最后获取size NSUInteger size = [attrs fileSize]; NXLog(@&quot;custom----size:%lu&quot;,(unsigned long)size); //打印结果如下 // 2017-02-06 23:47:01.843 BaiSi[44442:1317486] custom----size:136&#125; 打印结果： 可以看到 这个方法获取到了default 文件夹下的子文件夹及子文件夹下的文件以及隐藏文件.接下来我们继续修改clearCach 方法：123456789101112131415161718192021222324- (void)clearCach&#123; //1.先获取cache 目录的路径 NSString * cachePath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject]; // 这里先以获取 default 文件夹大小做实验，看看是否和 SDImageCache 获取的一样 NSString * directorPath = [cachePath stringByAppendingPathComponent:@&quot;default&quot;]; //2.声明一个文件管理对象 NSFileManager * fileManager = [NSFileManager defaultManager]; //3.在 SDImageCache 的getSize 方法里面我们看到调用了一个方法 NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfItemAtPath:filePath error:nil];所以我们也模仿他去做 //这个可以获取所有的子文件及子文件下的文件 NSArray * subPaths = [fileManager subpathsAtPath:directorPath]; NSUInteger totoalSize = 0 ; for (NSString * path in subPaths) &#123; NSString * filePath = [directorPath stringByAppendingPathComponent:path]; NSDictionary * attrs = [fileManager attributesOfItemAtPath:filePath error:nil]; //4.最后获取size totoalSize += [attrs fileSize]; &#125; NXLog(@&quot;custom----size:%lu&quot;,(unsigned long)totoalSize);&#125; 最终打印结果如下 基本上和SD 自己获取的大小差不多，这里比SD 的大是因为这里没有排除隐藏文件.DS_Store和下面那个default 文件夹,接下来对这两个文件进行排除：123456789101112131415161718192021222324252627282930313233- (void)clearCach&#123; //1.先获取cache 目录的路径 NSString * cachePath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject]; // 这里先以获取 default 文件夹大小做实验，看看是否和 SDImageCache 获取的一样 NSString * directorPath = [cachePath stringByAppendingPathComponent:@&quot;default&quot;]; //2.声明一个文件管理对象 NSFileManager * fileManager = [NSFileManager defaultManager]; //3.在 SDImageCache 的getSize 方法里面我们看到调用了一个方法 NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfItemAtPath:filePath error:nil];所以我们也模仿他去做 //这个可以获取所有的子文件及子文件下的文件 NSArray * subPaths = [fileManager subpathsAtPath:directorPath]; NSUInteger totoalSize = 0 ; for (NSString * path in subPaths) &#123; NSString * filePath = [directorPath stringByAppendingPathComponent:path]; //判断是否是隐藏文件 if ([filePath containsString:@&quot;.DS&quot;]) &#123; continue; &#125; //判断是否是文件夹 BOOL isDirector; BOOL fileExist = [fileManager fileExistsAtPath:filePath isDirectory:&amp;isDirector]; if (!fileExist || isDirector) &#123; continue; &#125; NSDictionary * attrs = [fileManager attributesOfItemAtPath:filePath error:nil]; //4.最后获取size totoalSize += [attrs fileSize]; &#125; NXLog(@&quot;custom----size:%lu&quot;,(unsigned long)totoalSize); &#125; 这个时候得到的结果就和SD 的一样了。上面的结果基本上已经可以满足功能了，不过为了复用性，还得进行一些修改，最好是能传入一个文件夹的路径然后获取大小，这里吧方法名改了一下：123456789101112131415161718192021222324252627282930313233343536373839- (NSUInteger)getFileSize:(NSString *)directorPath&#123; //2.声明一个文件管理对象 NSFileManager * fileManager = [NSFileManager defaultManager]; //3.在 SDImageCache 的getSize 方法里面我们看到调用了一个方法 NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfItemAtPath:filePath error:nil];所以我们也模仿他去做 //这个可以获取所有的子文件及子文件下的文件 NSArray * subPaths = [fileManager subpathsAtPath:directorPath]; NSUInteger totoalSize = 0 ; for (NSString * path in subPaths) &#123; NSString * filePath = [directorPath stringByAppendingPathComponent:path]; //判断是否是隐藏文件 if ([filePath containsString:@&quot;.DS&quot;]) &#123; continue; &#125; //判断是否是文件夹 BOOL isDirector; BOOL fileExist = [fileManager fileExistsAtPath:filePath isDirectory:&amp;isDirector]; if (!fileExist || isDirector) &#123; continue; &#125; NSDictionary * attrs = [fileManager attributesOfItemAtPath:filePath error:nil]; //4.最后获取size totoalSize += [attrs fileSize]; &#125; NXLog(@&quot;custom----size:%lu&quot;,(unsigned long)totoalSize); return totoalSize;&#125;// 然后在调用的地方如下就可以了： //1.先获取cache 目录的路径 NSString * cachePath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject]; // 这里先以获取 default 文件夹大小做实验，看看是否和 SDImageCache 获取的一样 NSString * directorPath = [cachePath stringByAppendingPathComponent:@&quot;default&quot;]; [self getFileSize:directorPath]; 上面的结果已经基本满足功能了。但是如果是遇到一个很大的文件夹的话，该操作可能会造成卡线程，所以最好能放到异步线程里去操作。由于是异步操作，这里就不适合用return 来返回结果了，可以用block的形式来传结果：12345678910111213141516171819202122232425262728293031323334353637- (void)getFileSize:(NSString *)directorPath completion:(void(^)(NSUInteger totoalSize))completion&#123; //2.声明一个文件管理对象 NSFileManager * fileManager = [NSFileManager defaultManager]; //3.在 SDImageCache 的getSize 方法里面我们看到调用了一个方法 NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfItemAtPath:filePath error:nil];所以我们也模仿他去做 dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; //这个可以获取所有的子文件及子文件下的文件 NSArray * subPaths = [fileManager subpathsAtPath:directorPath]; NSUInteger totoalSize = 0 ; for (NSString * path in subPaths) &#123; NSString * filePath = [directorPath stringByAppendingPathComponent:path]; //判断是否是隐藏文件 if ([filePath containsString:@&quot;.DS&quot;]) &#123; continue; &#125; //判断是否是文件夹 BOOL isDirector; BOOL fileExist = [fileManager fileExistsAtPath:filePath isDirectory:&amp;isDirector]; if (!fileExist || isDirector) &#123; continue; &#125; NSDictionary * attrs = [fileManager attributesOfItemAtPath:filePath error:nil]; //4.最后获取size totoalSize += [attrs fileSize]; &#125; //完成之后回调 //这里需要在主线程去回调。不然接收不到值。这里可以用同步操作，不会太耗时 dispatch_sync(dispatch_get_main_queue(), ^&#123; if (completion) &#123; completion(totoalSize); &#125; &#125;); &#125;);&#125; 到这一步已经可以完成了。不过我们还可以在完善一点，因为我们永远无法想象用户会做什么操作。同样我们将这样的方法丢给同事去调用，也无法去想象他们会传一些什么稀奇古怪的参数，比如，他直接给你传个文件的路径而不是文件夹，所以我们还得加一些异常处理，比如抛异常，就像苹果经常干的那样。最终我们修改后的方法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748- (void)getFileSize:(NSString *)directorPath completion:(void(^)(NSUInteger totoalSize))completion&#123; //2.声明一个文件管理对象 NSFileManager * fileManager = [NSFileManager defaultManager]; // 在这里做一些异常的处理 //判断是否是文件夹 BOOL isDirector; BOOL fileExist = [fileManager fileExistsAtPath:directorPath isDirectory:&amp;isDirector]; if (!fileExist || !isDirector) &#123; NSException * exception = [NSException exceptionWithName:@&quot;PathError&quot; reason:@&quot;hey,man,这里需要的是一个文件夹的路径，并且是存在的&quot; userInfo:nil]; [exception raise]; &#125; //3.在 SDImageCache 的getSize 方法里面我们看到调用了一个方法 NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfItemAtPath:filePath error:nil];所以我们也模仿他去做 dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; //这个可以获取所有的子文件及子文件下的文件 NSArray * subPaths = [fileManager subpathsAtPath:directorPath]; NSUInteger totoalSize = 0 ; for (NSString * path in subPaths) &#123; NSString * filePath = [directorPath stringByAppendingPathComponent:path]; //判断是否是隐藏文件 if ([filePath containsString:@&quot;.DS&quot;]) &#123; continue; &#125; //判断是否是文件夹 BOOL isDirector; BOOL fileExist = [fileManager fileExistsAtPath:filePath isDirectory:&amp;isDirector]; if (!fileExist || isDirector) &#123; continue; &#125; NSDictionary * attrs = [fileManager attributesOfItemAtPath:filePath error:nil]; //4.最后获取size totoalSize += [attrs fileSize]; &#125; //完成之后回调 //这里需要在主线程去回调。不然接收不到值。这里可以用同步操作，不会太耗时 dispatch_sync(dispatch_get_main_queue(), ^&#123; if (completion) &#123; completion(totoalSize); &#125; &#125;); &#125;);&#125; 然后在调用的时候传入一个错误的地址，正如我们所料，Xcode崩了，在控制台出来结果如下：OK，可以收工了。 #清除缓存 清楚缓存相对比较简单，直接贴代码吧:12345678910- (void)removeFiles:(NSString *)directorPath&#123; NSFileManager * manager = [NSFileManager defaultManager]; //这个方法是获取该文件下的所有子文件夹，不会获取子文件夹里的文件(这里没必要了，直接删除文件夹就可以) NSArray * subDirectors = [manager contentsOfDirectoryAtPath:directorPath error:nil]; for (NSString * path in subDirectors) &#123; NSString * filePath = [directorPath stringByAppendingPathComponent:path]; //删除文件夹 [manager removeItemAtPath:filePath error:nil]; &#125; &#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 项目小知识点]]></title>
    <url>%2F2017%2F02%2F05%2FiOS%20%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[[toc] 自定义控件 在- (instancetype)initWithFrame:(CGRect)frame里自定义控件在- (void)layoutSubviews 里布局控件 1234567名字叫attributes并且是NSDictionary *类型的参数，它的key一般都有以下规律 1.iOS7开始 1&gt; 所有的key都来源于： NSAttributedString.h 2&gt; 格式基本都是：NS***AttributeName 2.iOS7之前 1&gt; 所有的key都来源于： UIStringDrawing.h 2&gt; 格式基本都是：UITextAttribute*** 123 NSString * title = [button currentTitle]; // 获取按钮当前title文字 CGSize size = [title sizeWithAttributes:@&#123;NSFontAttributeName:button.titleLabel.font&#125;];//根据字体计算大小_titleUnderLine.backgroundColor = [titleButton titleColorForState:UIControlStateSelected]; //根据按钮title 颜色设置下划线颜色 cell分割线顶头操作1.第一种方法，利用系统的属性去设置 项目中经常会有些需求是cell 的分割线顶头，而系统默认的是前面有一定的间距，其实这是由一个separatorInset 属性造成的(iOS7以后出的)，通过打印： 1234567- (void)viewDidAppear:(BOOL)animated&#123; NXLog(@&quot;margin:%@&quot;,NSStringFromUIEdgeInsets(self.tableView.separatorInset));&#125;打印结果：margin:&#123;0, 15, 0, 0&#125; //可以看出来系统默认有一个15的偏移量 将该属性设置为空，现在tableView里面设置： 12 self.tableView.separatorInset = UIEdgeInsetsZero; //分隔线顶头，这个只是设置tableView 顶头，还需要在cell里设置cell的顶头通过这一步设置发现分割线比之前左移了不少，但是还没顶到头，这里就判断是cell自身的原因 同时在cell 里面进行设置：1self.separatorInset = UIEdgeInsetsZero;//cell分割线顶头 这时候运行再看结果，已经OK顶到头。 tableView底层实现 1.tableView 先把所有cell 的尺寸计算好，保存到一个数组里。2.当cell 要显示的时候就拿到这个cell 去设置frame : cell.frame = frames[row]。 2.第二种方法，重写cell 的setFrame,可以随意设置cell 的间距，比较万能。 主要思路：主要就是利用了上面的tableView 的实现原理。1.首先设置tableView的背景色为分割线的颜色。2.禁掉系统的分割线3.在cell类中重写setFrame 方法。 123456789101112 self.tableView.backgroundColor = NXColor(220, 220, 221); self.tableView.separatorStyle = UITableViewCellSeparatorStyleNone;//在自定义的cell类中：- (void)setFrame:(CGRect)frame&#123; NXLog(@&quot;cellFrame:%@&quot;,NSStringFromCGRect(frame)); //因为之前的frame 都是计算好的，这是在要显示的时候去设置一下，所以这里只去将高度减1，不会影响到其他尺寸 frame.size.height -=1; // 如果想要间距更大的话可以 -=10 等，随意这种方法比较万能 //这个才是系统真正的设置frame。重写了这个方法会将系统的frame清空，所以需要调用这个 [super setFrame:frame];&#125; 屏幕适配 1.一个view从Xib 加载，需不需要重新固定一下尺寸？ 这个是一定得需要的，比较保险。2.一般添加xib view的时候是在viewDidLoad 里面加载，但是设置尺寸frame 最好在viewDidLayoutSubViews 里面去设置。因为viewDidLoad 并不会去布局frame ，只是拿到xib 设置的大小属性，只有在 viewDidLayoutSubViews 里才会去根据布局去确定控件的最终尺寸(不过添加view 的操作不能放在这里，因为这个方法会调用多次) 12345678910111213141516171819202122🌰：- (void)viewDidLoad &#123; [super viewDidLoad]; UIView * loginView = [NXLoginRegistView loginView]; [self.middleView addSubview:loginView]; UIView * registView = [NXLoginRegistView registView]; [self.middleView addSubview:registView]; UIView * fastLogin = [NXFastLoginView fastLoginView]; [self.bottomView addSubview:fastLogin];&#125;- (void)viewDidLayoutSubviews&#123; [super viewDidLayoutSubviews]; //在这里面设置尺寸 UIView * loginView = [self.middleView subviews][0]; loginView.frame = CGRectMake(0, 0, self.middleView.frame.size.width * 0.5, self.middleView.frame.size.height); UIView * registView = [self.middleView subviews][1]; registView.frame = CGRectMake(self.middleView.frame.size.width * 0.5, 0, self.middleView.frame.size.width * 0.5, self.middleView.frame.size.height); UIView * fastLogin = [self.bottomView subviews][0]; fastLogin.frame = CGRectMake(0, 0, self.bottomView.frame.size.width, self.bottomView.frame.size.height);&#125; 从Xib加载的view 设置动画 是通过操作约束去设置，比如要修改x值产生动画就找到x的约束拖线添到类文件中成为属性，然后对该属性进行操作，在设置动画时，必须加上这句 ： 1[self.view layoutIfNeeded]; //这句话很重要，只有重新布局才会产生动画效果，否则没有动画效果 例如 1234[UIView animateWithDuration:1 animations:^&#123; self.testViewWidthConstraint.constant = 200; [self.view layoutIfNeeded]; //这句话很重要，只有重新布局才会产生动画效果，否则没有动画效果&#125;]; 一个xib文件可以管理多个view重写button 的布局 这个在项目中也很常见，默认的按钮布局是左右布局，即左边imageView + 右边label 。而好多项目中需要的是上下布局，所以需要自定义button，重新布局。这里在layoutSubViews 方法里面进行，因为在这个方法里面所有的控件尺寸都已经是计算好的，我们就不需要重新去计算，只要改一下布局就可以。 123456789🌰：- (void)layoutSubviews&#123; [super layoutSubviews]; self.imageView.nx_y = 0; self.imageView.nx_centerX = self.nx_centerX; self.titleLabel.nx_y = self.nx_height - self.titleLabel.nx_height; self.titleLabel.nx_centerX = self.nx_centerX;&#125; 自定义tabBar的问题 项目中需要定制tabBar 的时候需要用到自定义tabBar,这里需要注意的是不能直接通过如下的赋值语法进行替换： 123456🌰： NXTabBar * nTabBar = [[NXTabBar alloc]init]; self.tabBar = nTabBar;这样替换的话是没有效果的，需要用KVC 的形式进行替换： [self setValue:nTabBar forKey:@&quot;tabBar&quot;]; iOS类私有属性的访问和修改http://www.jianshu.com/p/a667f0ce9573 iOS 类别中添加属性（属性和实例变量的区别）【转】iOS中属性与成员变量的区别iOS Category中添加属性和成员变量的区别 通过category 和 runtime 设置textField 的 placehold 的颜色 项目中经常会用到textField ，比如登录注册等。默认的光标是蓝色，而且placeholder的文字颜色也是灰的，不会变化。有时候项目会需求点击后光标为白色，同时placeholder 的文字高亮为白色(或其他颜色)。通过头文件一级一级往上查找，找到了一个如下属性: 1@property(nullable, nonatomic,copy) NSAttributedString *attributedPlaceholder 利用这个属性，用如下方法进行颜色修改： 123//第一个参数: 需要被设置属性的字符串//第二个参数: 需要设置的属性 self.attributedPlaceholder = [[NSAttributedString alloc]initWithString:self.placeholder attributes:@&#123;NSForegroundColorAttributeName:[UIColor whiteColor]&#125;]; 这个方法虽然达到效果了，但是比较麻烦，通过如下图的方式，随便写一个textField ,然后打上短点，我们可以看到在textField 内部有placeholderLabel的属性，所以可以尝试通过对该属性进行操作，直接修改颜色。不过通过下面的调试框可以看到这是一个私有属性。想要对私有属性进行访问和修改可以使用kvc 或者 runtime ,这里使用kvc ,新建一个类别，添加属性placeholderColor,在set 方法里面去进行设置： 1234567891011121314151617181920🌰：h 文件#import &lt;UIKit/UIKit.h&gt;@interface UITextField (NXTextField)@property (nonatomic ,strong)UIColor *placeholdColor;@endm 文件- (void)setPlaceholdColor:(UIColor *)placeholdColor&#123; //根据判断，textField 内部的 placehold 是一个label 的标签 UILabel * placeholderLabel = [self valueForKey:@&quot;placeholderLabel&quot;]; placeholderLabel.textColor = placeholdColor;&#125;- (UIColor *)placeholdColor&#123; return nil; // 暂时先不用，返回一个nil ，去掉系统的警告⚠️&#125; 然后可以在需要设置的地方引入category 的头文件，通过如下方式即可设置颜色： 1self.placeholdColor = [UIColor lightGrayColor]; 通过上面category 的方式基本可以满足需求，但是如果textField 如下设置的时候就会出现无效： 123456789// 这样设置是可以的： self.placeholder = @&quot;44444&quot;; self.placeholdColor = [UIColor lightGrayColor];//将上面的换个顺序执行，就会无效: self.placeholdColor = [UIColor lightGrayColor]; self.placeholder = @&quot;44444&quot;;//这是因为之前没有设置placeholder文字，设置颜色的时候通过断点可以看到，此时获取不到placeholderLabel,所以导致设置颜色无效。 解决这个问题就需要用到runtime1.先将 placeholderColor 保存起来2.在设置placeholder 的时候再取出来设置颜色 123456789101112131415161718192021222324- (void)setPlaceholdColor:(UIColor *)placeholdColor&#123; //先将placeholdColor 存起来 //参数一：给哪个对象添加成员属性 //参数二：成员属性的名字 //参数三：成员属性的值 objc_setAssociatedObject(self, @&quot;placeholdColor&quot;, placeholdColor, OBJC_ASSOCIATION_RETAIN_NONATOMIC); //根据判断，textField 内部的 placehold 是一个label 的标签 UILabel * placeholderLabel = [self valueForKey:@&quot;placeholderLabel&quot;]; placeholderLabel.textColor = placeholdColor;&#125;- (UIColor *)placeholdColor&#123; return objc_getAssociatedObject(self, @&quot;placeholdColor&quot;);&#125;//自顶一个setPlaceholder方法，在内部1.先设置文字。 2.设置颜色- (void)setNX_Placeholder:(NSString *)placeholder&#123; self.placeholder = placeholder; self.placeholdColor = self.placeholdColor;&#125; 上面方法有个缺点就是每次设置placeholder文字还得去调用1[self setNX_Placeholder:@&quot;hhhh&quot;]; 所以想要直接通过: self.placeholder = @”hhhh”; 去设置，就需要用到方法交换。因为交换只需要做一次操作，所以，放到+(void)load方法里去操作,在category文件中加入：12345+ (void)load&#123; Method setPlaceholder = class_getInstanceMethod(self, @selector(setPlaceholder:)); Method setNx_Placeholder = class_getInstanceMethod(self, @selector(setNX_Placeholder:)); method_exchangeImplementations(setPlaceholder, setNx_Placeholder);&#125; 计算总行数的万能公式 1row = (count -1 ) / column +1; tableView 调整cell 间距 用storyBoard 拖出来的cell 默认显示的是如下图的间距(因为要使用到静态单元格，所以用到storyBoard,一般情况下用xib最好) 这里用的是分组style，所以可以通过设置12self.tableView.sectionFooterHeight = 0; self.tableView.sectionHeaderHeight = 0; 得到如下效果: 可以看到每个分组之间的间距已经没了，但是第一个cell 距离顶部还是有好大一部分距离，这里判断可能是tableView 的间距,通过下面打印 可以看到tableView 距离顶部确实有64 的偏移量，但是这个刚好是空出导航栏的高度，所以排除是tableView 的问题，接下来就判断是cell 的问题，通过下面打印 可以看到分组内部第一个cell 的Y 值默认是35 ，那么这里可以在viewDidLoad 方法里进行如下调整就可以（这里需要间隔为10）123self.tableView.sectionFooterHeight = 0; self.tableView.sectionHeaderHeight = 10; self.tableView.contentInset = UIEdgeInsetsMake(-25, 0, 0, 0); 跳转到网页 1.Safari openURL 自带很多功能:进度条，刷新，前进，倒退等功能。但是需要跳出到当前应用。2.UIWebView 在当前应用打开网页，并且带有Safari（自己实现），不能实现进度条。3.SFSafariViewController 专门用来显示网页,既可以在当前应用显示网页，又可以有Safari的功能。iOS9以后才可以用。4.WKWebView 判断view 是否被加载123456789101112随便一个都可以: UIViewController * vc = self.childViewControllers[button.tag]; if (vc.isViewLoaded) &#123;//如果已经被加载过就不重复加载(加载view 的时候会调用 viewDidLoad) return ; &#125; UIView * view = vc.view; if (view.superview) &#123; // 如果有父view ，说明已经被添加过 return; &#125; if (view.window) &#123; //如果有容器，说明已经被添加过 return; &#125; 一些全局常量，尽量使用extern来引用，其次再选择考虑Macro iOS const的使用关于全局常量的定义 xib cell 拖线报错： Terminating app due to uncaught exception ‘NSUnknownKeyException’, reason: ‘[ setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key 如下图，我已开始在File`s Owner里也设置了class是NXTopicCell,所以一直出错，这里吧他清空，设置下面的Topic Cell 的class如下就可以 xib拖的UILabel 没有自动换行：设置约束时不要给定高度就可以自动换行了。 #在heightForRowAtIndexPath获取cell 崩溃http://www.jianshu.com/p/3da539540d21 在网上看到有人是这么获取：1NXTopicCell * cell = (NXTopicCell *)[self tableView:tableView cellForRowAtIndexPath:indexPath]; 试了下好像是可以。 好像xib 里设置的高度是定死的，不会根据不同屏幕去重新计算高度。 退出键盘 1.监听scrollView实时滚动代理方法调用[self.view endEditing:YES]或者[self.textField resignFirstResponse];2.touchBegin方法里,调用[self.view endEditing:YES]或者[self.textField resignFirstResponse]; 父View添加手势，子View不要去响应父View点击事件iOS 点击子视图不让其响应父视图手势 在做这样一个界面的时候 背景的蒙版层是一个UIView,按钮的列表View添加到背景的蒙版View上。在蒙版层添加一个手势，点击dismiss掉这个界面和蒙版。但是遇到问题就是在点击按钮列表的View的时候也出发了单击手势。这个好像是系统默认的，参考事件响应链。为了避免这种效果，在手势触发事件中可以判断当前点击事件是否在父View上，如果是子View上则不去做操作，点击在父View上才去做dismiss的操作。代码如下： 1234567891011121314151617- (void)dismissMoreActionView:(UITapGestureRecognizer *)tap&#123; //根绝tag获取子view UIView *subView = [self viewWithTag:100]; /* BOOL contains = CGRectContainsPoint(CGRect rect, CGPoint point); 判断一个CGRect是否包含再另一个CGRect里面,常用与测试给定的对象之间是否又重叠 - (CGPoint)locationInView:(UIView *)view： 该函数返回一个CGPoint类型的值，表示触摸在view这个视图上的位置，这里返回的位置是针对view的坐标 */ // 判断手势点击的位置是不是包含在子视图上 if (!CGRectContainsPoint(subView.frame, [tap locationInView:self])) &#123; [self removeFromSuperview]; &#125;&#125; 调整导航栏leftBarButtonItem 和 rightBarbuttonItem 的偏移量 如何调整导航条上的leftBarButtonItem和rightBarButtonItem的位置 ####重点：这里需要提到BarButtonSystemItem的样式－ UIBarButtonSystemItemFixedSpace我不多说 请看官方解释:Blank space to add between other items. Only the width property is used when this value is set. 反正我是看不懂 。再来说说negativeSpacer.width = 0 表示leftBarButtonItem的x离屏幕的左边还有15像素 同样表示rightBarButtonItem的CGRectGetMaxX()离屏幕的右边还有15像素 那么好像我们就可以通过negativeSpacer.width来调整leftBarButtonItem的位置。搞了老半天原来就是得靠这家伙。但有一点：negativeSpacer.width赋值负数对于leftBarButtonItem来说是左移多少像素 对于rightBarButtonItem来说是右移多少像素 反之亦然. 我这里想要设置右边的item 右移一点，因为默认的太偏左了：123456789101112131415161718UIButton * buyBtn = [[UIButton alloc]init]; buyBtn.frame = CGRectMake(0, 0, 80, 40); buyBtn.backgroundColor = [UIColor orangeColor]; [buyBtn setTitle:@&quot;马上选购&quot; forState:UIControlStateNormal]; buyBtn.titleLabel.font = [UIFont systemFontOfSize:15]; [buyBtn addTarget:self action:@selector(buyItemAction) forControlEvents:UIControlEventTouchUpInside]; UIBarButtonItem * buyItem = [[UIBarButtonItem alloc]initWithCustomView:buyBtn]; UIBarButtonItem * space = [[UIBarButtonItem alloc]initWithBarButtonSystemItem:UIBarButtonSystemItemFixedSpace target:nil action:nil]; space.width = -10; self.navigationItem.rightBarButtonItems = @[space,buyItem]; 动态修改UIButton的title 的时候字体闪烁的问题： UIButton-system类型 动态改变title 显示文字时闪动(解决方案) assign 修饰代理导致野指针的问题 在下面方法中调用了代理，崩溃指向这里显示野指针的错误，猜测是由于代理被释放而去调用产生的问题。点进去看到之前代理修饰用的是assign 修饰的，改为weak 后好像是可以了。猜测原因是由于assign 修饰的话 assign是指针赋值，不对引用计数操作，使用之后如果没有置为nil，可能就会产生野指针；而weak一旦不进行使用后，永远不会使用了，就不会产生野指针。 12345678910- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123; if ([_delegate respondsToSelector:@selector(numberOfRowsInTableView:Insection:FromView:)]) &#123; NSInteger vRows = [_dataSource numberOfRowsInTableView:tableView Insection:section FromView:self]; mRowCount = vRows; return vRows; &#125; return 0;&#125; 单例问题 在使用单例的时候，经常性就是直接写出下面的代码。不过最近在使用的时候会遇到单例导致崩溃的问题。一开始在写 dispatch_once_t once_token的时候没有用static 来修饰，后来加上static来修饰就好了。 12345678910111213+ (instancetype)shareInstance&#123; static DrawTextView * drawText = nil; static dispatch_once_t once_token; dispatch_once(&amp;once_token, ^&#123; drawText = [[DrawTextView alloc]initWithFrame:CGRectMake(kDeviceW * 0.5- TextLayerWidth * 0.5, kDeviceH * 0.5 - TextLayerHeight * 0.5, TextLayerWidth, TextLayerHeight)]; drawText.backgroundColor = [UIColor orangeColor]; &#125;); return drawText;&#125; 在iPhone5s （10.2系统）拨打电话没有弹框提示，其他手机（10.3）有弹框`// 用这种方法的话会出现上面的问题// NSString * phonNum = [NSString stringWithFormat:@”tel://%@”,self.footerModel.dav_phone]; NSString * phonNum = [NSString stringWithFormat:@&quot;telprompt://%@&quot;, self.footerModel.dav_phone]; ##控制器切换从下往上，并且有导航栏： 可以用CATransition 动画，或者直接用presentModalViewController。http://www.cocoachina.com/bbs/read.php?tid=7668 ##改变SearchBar 的取消按钮颜色，光标颜色 http://www.jianshu.com/p/66b5b777f5dc]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序]]></title>
    <url>%2F2016%2F12%2F14%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[快速创建页面操作步骤说明 新建一个默认（HelloWorld）或者空白项目，或者打开自己的项； 假设我们要在根目录下创建一个页面，取名为：tianxiaxue； 打开微信小程序配置文件【app.json】，在&quot;pages&quot;:[]数据中写入一条页面路径； 同时按住电脑【Ctrl+S】保存。其他同理，需要创建某一路径的页面，可以通过输入页面路径快速创建； 链接：快速创建页面及正则使用技巧 个人理解 app.js 相当于Appdelegate , 是整个程序的入口 index.js/log.js 相当于是每个控制器viewController,对应每个页面逻辑 http/https : 协议, .com/.cn…. : 域名 当有APPID的情况下，进行网络通信，只能和指定的域名进行通信。如果没有进行配置，编译时会报如下错误： 在 iOS 上，小程序的 javascript 代码是运行在 JavaScriptCore 中 在 Android 上，小程序的 javascript 代码是通过 X5 内核来解析 在 开发工具上， 小程序的 javascript 代码是运行在 nwjs（chrome内核） 中。所以开发工具上的效果跟实际效果有所出入。 目录结构 小程序包含一个描述整体程序的 app 和多个描述各自页面的 page。 一个小程序主体部分由三个文件组成，必须放在项目的根目录，如下： 文件 必须 作用 app.js 是 小程序逻辑 app.json 是 小程序公共设置 app.wxss 否 小程序公共样式表，定义在 app.wxss 中的样式为全局样式，可用于任何Page。在 Page 里的 wxss 文件中定义的样式为局部样式，只作用在当前页面，并会覆盖 app.wxss 中相同的选择器 pages目录下为小程序页面，每个页面须建立独立的文件夹，例如上面生成的小程序有两个页面，分别为pages/index、pages/logs，一个页面由四个文件组成，分别是： 文件 必须 作用 js 是 页面逻辑 wxml 是 页面结构 wxss 否 页面样式表 json 否 页面配置 page.json 每一个小程序页面也可以使用.json文件来对本页面的窗口表现进行配置。 页面的配置比app.json全局配置简单得多，只是设置 app.json 中的 window 配置项的内容，页面中配置项会覆盖 app.json 的 window 中相同的配置项。 页面的.json只能设置 window 相关的配置项，以决定本页面的窗口表现，所以无需写 window 这个键，如：1234567&#123; &quot;navigationBarBackgroundColor&quot;: &quot;#ffffff&quot;, &quot;navigationBarTextStyle&quot;: &quot;black&quot;, &quot;navigationBarTitleText&quot;: &quot;微信接口功能演示&quot;, &quot;backgroundColor&quot;: &quot;#eeeeee&quot;, &quot;backgroundTextStyle&quot;: &quot;light&quot;&#125; 资料 从0到1：初学者入门Demo 微信小程序框架详解《一》配置文件及其支持的配置属性 CTT团队实战教程系列《一》小安娜B站系列：准备与事先须知 程序员开发实战系列《二》微信小程序架构篇]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS]]></title>
    <url>%2F2016%2F12%2F01%2Fcss%2F</url>
    <content type="text"><![CDATA[CSS选择器(selectors)引用.css布局: 资料： HTML Tag: link 序号 选择器 含义 1. * 通用元素选择器，匹配任何元素 2. E 标签选择器，匹配所有使用E标签的元素 3. .info class选择器，匹配所有class属性中包含info的元素 4. #footer id选择器，匹配所有id属性等于footer的元素 一个标签可以有多个类选择器，不同的值用空格隔开，这样多个样式便可以应用的一个标签上，如:&lt;div class=&quot;style1 style2&quot;&gt;多个类选择器&lt;/div&gt; 资料：CSS选择器笔记css选择器优先级深入理解10-CSS选择器(小码哥的笔记)CSS属性margin 属性margin 属性接受任何长度单位，可以是像素、英寸、毫米或 em。 12例子1：margin:10px 5px 15px 20px; 上外边距是 10px 右外边距是 5px 下外边距是 15px 左外边距是 20px 12例子2：margin:10px 5px 15px; 上外边距是 10px 右外边距和左外边距是 5px 下外边距是 15px 12例子3：margin:10px 5px; 上外边距和下外边距是 10px 右外边距和左外边距是 5px floatfloat 属性定义元素在哪个方向浮动 值 描述 left 元素向左浮动。 right 元素向右浮动。 none 默认值。元素不浮动，并会显示在其在文本中出现的位置。 inherit 规定应该从父元素继承 float 属性的值。 background-size 属性规定背景图像的尺寸 1234567例子：div&#123;background:url(img_flwr.gif);background-size:80px 60px;background-repeat:no-repeat;&#125; CSS元素显示模式转换 如何转换CSS元素的显示模式? 设置元素的display属性 display取值 block 块级 inline 行内 inline-block 行内块级 快捷键 di display: inline; db display: block; dib display: inline-block; 块级元素和行内元素的区别? 块级元素 独占一行如果没有设置宽度, 那么默认和父元素一样宽 如果设置了宽高, 那么就按照设置的来显示 行内元素 不会独占一行 如果没有设置宽度, 那么默认和内容一样宽 行内元素是不可以设置宽度和高度的 行内块级元素 为了能够让元素既能够不独占一行, 又可以设置宽度和高度, 那么就出现了行内块级元素 不独占一行, 并且可以设置宽高 网页布局方式——定位流默认情况下，所有的网页标签都是在标准流布局中 从上到下，从做往右。 脱离标准流的方法有： float属性 position属性和 left、right、top、bottom属性 这里的各种定位都是相对各种流的，对于一个非前端来说，脑子里完全没有这些所谓流的概念，这里先插入一下所谓标准流，定位流的概念css定位机制：标准流，定位和浮动, 什么是CSS普通流/标准流? 相对定位和绝对定位一般都是用来做覆盖效果的, 当看到某个元素覆盖在另外一个元素上时, 第一时间就要想到定位流 绝对定位使用口诀(子绝父相)资料: 定位流(小码哥) 所有标签想要水平居中 行内标签和行内块级标签：在父标签中设置 text-align:center ; 块级标签：在自身设置：margin : 0 auto ; 所有标签垂直居中 行内标签和行内块级标签：设置行高：line-height:100%; HTML属性HTML style 属性1style 属性将覆盖任何全局的样式设定 1234例子：在 HTML 文档中使用 style 属性：&lt;h1 style=&quot;color:blue; text-align:center&quot;&gt;This is a header&lt;/h1&gt;&lt;p style=&quot;color:red&quot;&gt;This is a paragraph.&lt;/p&gt; Flex布局属性 position float Flex 布局教程：语法篇 Flex 布局教程：实例篇 HTML模板和CSS基准样式（一） 集锦： &lt;a href=&quot;#&quot;&gt;是链接到本页，因为你有的时候需要有个链接 的样式，但是又不希望他跳转 HTML标签元素的分类(行内标签、块级标签、行内块级标签)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git]]></title>
    <url>%2F2015%2F10%2F01%2Fgit%2F</url>
    <content type="text"><![CDATA[一、git常用操作命令 使用git进行版本管理 进入到项目根目录 git init git add . git commit -m ‘初始化’ 提交代码到远程仓库 创建远程代码仓库 添加远程仓库关联 1git remote add origin 远程仓库地址 * ##### 提交代码到远程仓库 1git push origin master 备注：关于权限 使用用户名和密码 生成公钥和私钥。 ssh-keygen 本地打标签备份并提交标签 git tag git push –tags 删除本地/远程标签 删除本地标签1git tag -d 标签名称 删除远程1git push origin : 标签名称 二、cocoapods1.cocoapods的基本使用 cocoapods的安装 gem]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
